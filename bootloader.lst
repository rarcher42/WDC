
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass.exe -c -L bootloader.lst bootloader.asm
; Tue Jun 25 16:01:04 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: bootloader.asm

=$01					MASK0	=	 %00000001
=$02					MASK1	=	 %00000010
=$04					MASK2	=	 %00000100
=$08					MASK3	=	 %00001000
=$10					MASK4	=	 %00010000
=$20					MASK5	=	 %00100000
=$40					MASK6	=	 %01000000
=$80					MASK7	=	 %10000000
=$f0					TEMP 		=   $F0     ; save hex value
=$7f30					ACIA_BASE	= 	$7F30		; This is where the 6551 ACIA starts
=$7f30					SDR = ACIA_BASE       		; RX'ed bytes read, TX bytes written, here
=32561					SSR = ACIA_BASE+1     		; Serial data status register
=32562					SCMD = ACIA_BASE+2     		; Serial command reg. ()
=32563					SCTL = ACIA_BASE+3     		; Serial control reg. ()
=$10					TX_RDY = MASK4
=$08					RX_RDY = MASK3
=$1e					SCTL_V  = %00011110       ; 9600 baud, 8 bits, 1 stop bit, rxclock = txclock
=$0b					SCMD_V  = %00001011       ; No parity, no echo, no tx or rx IRQ (for now), DTR*
=$7fe0					SYSTEM_VIA_IORB     = $7FE0 ; Port B IO register
=$7fe1					SYSTEM_VIA_IORA     = $7FE1 ; Port A IO register
=$7fe2					SYSTEM_VIA_DDRB     = $7FE2 ; Port B data direction register
=$7fe3					SYSTEM_VIA_DDRA     = $7FE3 ; Port A data direction register
=$7fe4					SYSTEM_VIA_T1C_L    = $7FE4 ; Timer 1 counter/latches, low-order
=$7fe5					SYSTEM_VIA_T1C_H    = $7FE5 ; Timer 1 high-order counter
=$7fe6					SYSTEM_VIA_T1L_L    = $7FE6 ; Timer 1 low-order latches
=$7fe7					SYSTEM_VIA_T1L_H    = $7FE7 ; Timer 1 high-order latches
=$7fe8					SYSTEM_VIA_T2C_L    = $7FE8 ; Timer 2 counter/latches, lower-order
=$7fe9					SYSTEM_VIA_T2C_H    = $7FE9 ; Timer 2 high-order counter
=$7fea					SYSTEM_VIA_SR       = $7FEA ; Shift register
=$7feb					SYSTEM_VIA_ACR      = $7FEB ; Auxilliary control register
=$7fec					SYSTEM_VIA_PCR      = $7FEC ; Peripheral control register
=$7fed					SYSTEM_VIA_IFR		= $7FED ; Interrupt flag register
=$7fee					SYSTEM_VIA_IER      = $7FEE ; Interrupt enable register
=$7fef					SYSTEM_VIA_ORA_IRA	= $7FEF ; Port A IO register, but no handshake
=$01					PB0 = MASK0
=$02					PB1 = MASK1
=$04					PB2 = MASK2
=$08					PB3 = MASK3
=$20					PB5 = MASK5
=$01					FIFO_TXE = PB0
=$02					FIFO_RXF = PB1
=$04					FIFO_WR = PB2
=$08					FIFO_RD = PB3
=$20					FIFO_PWREN = PB5
=$7efa					NMIVEC	= 	 	$7EFA	; write actual NMI vector here
=$7efe					IRQVEC   =      $7EFE   ; write IRQ vector here
.f800	78		sei		START   	SEI                     ; disable interrupts
.f801	d8		cld		        	CLD                     ; binary mode arithmetic (not required on 65C02 or 65816)
.f802	a2 ff		ldx #$ff	        	LDX     #$FF            ; Set up the stack pointer
.f804	9a		txs		        	TXS                     ;       "
.f805	a9 f8		lda #$f8	        	LDA     #>START      	; Initialiaze the interrupt vectors
.f807	8d fb 7e	sta $7efb	        	STA     NMIVEC+1        ; User program at ENTRY_POINT may change
.f80a	8d ff 7e	sta $7eff	        	STA     IRQVEC+1	; these vectors.  Just do change before enabling
.f80d	a9 00		lda #$00	        	LDA     #<START		; the interrupts, or you'll end up back in the d/l monitor.
.f80f	8d fa 7e	sta $7efa	        	STA     NMIVEC
.f812	8d fe 7e	sta $7efe	        	STA     IRQVEC
.f815	20 7d f8	jsr $f87d				JSR		INITVIA		; Set up 65C22 to FIFO interface chip (and ROM bank select)
.f818	20 53 f8	jsr $f853				JSR		INITSER
.f81b	a9 2a		lda #$2a				LDA		#'*'
.f81d	20 9c f8	jsr $f89c				JSR		FIFOOUT
.f820	a9 36		lda #$36				LDA		#'6'
.f822	20 9c f8	jsr $f89c				JSR		FIFOOUT
.f825	a9 39		lda #$39				LDA		#'9'
.f827	20 9c f8	jsr $f89c				JSR		FIFOOUT
.f82a	20 ca f8	jsr $f8ca	ECHO		JSR		FIFOIN
.f82d	90 fb		bcc $f82a				BCC		ECHO		; Wait for an incoming character
.f82f	20 9c f8	jsr $f89c				JSR		FIFOOUT
.f832	80 f6		bra $f82a				BRA		ECHO
.f834	a9 2a		lda #$2a				LDA		#'*'
.f836	20 6b f8	jsr $f86b	E1			JSR		PUTSER		; Just send something in case FIFOIN hangs so we know we got this far FIXME: remove this
.f839	90 fb		bcc $f836				BCC		E1
.f83b	a9 36		lda #$36				LDA		#'6'
.f83d	20 6b f8	jsr $f86b	E2			JSR		PUTSER
.f840	90 fb		bcc $f83d				BCC		E2
.f842	a9 39		lda #$39				LDA		#'9'
.f844	20 6b f8	jsr $f86b	E3			JSR 	PUTSER
.f847	90 fb		bcc $f844				BCC		E3
.f849	20 ca f8	jsr $f8ca	ECHO2		JSR		FIFOIN
.f84c	90 fb		bcc $f849				BCC		ECHO2		; Wait for an incoming character
.f84e	20 9c f8	jsr $f89c				JSR		FIFOOUT
.f851	80 f6		bra $f849				BRA		ECHO2
.f853	a9 1e		lda #$1e	INITSER 	LDA     #SCTL_V 	; 9600,n,8,1.  rxclock = txclock
.f855	8d 33 7f	sta $7f33				STA 	SCTL
.f858	a9 0b		lda #$0b				LDA     #SCMD_V 	; No parity, no echo, no tx or rx IRQ (for now), DTR*
.f85a	8d 32 7f	sta $7f32				STA     SCMD
.f85d	60		rts					RTS
.f85e	ad 31 7f	lda $7f31	GETSER 		LDA     SSR    		; look at serial status
.f861	29 08		and #$08				AND     #RX_RDY 	; see if anything is ready
.f863	18		clc					CLC					; signal no character waiting
.f864	f0 04		beq $f86a				BEQ     GSXIT1		; 0 = no character waiting.  Return with C=0
.f866	ad 30 7f	lda $7f30				LDA    	SDR     	; get the character
.f869	38		sec					SEC					; Signal receipt of character
.f86a	60		rts		GSXIT1		RTS
.f86b	da		phx		PUTSER		PHX
.f86c	48		pha					PHA
.f86d	aa		tax					TAX					; save output character in X
.f86e	ad 31 7f	lda $7f31				LDA		SSR
.f871	29 10		and #$10				AND 	#TX_RDY
.f873	18		clc					CLC
.f874	f0 04		beq $f87a				BEQ		PSXIT1		; TXE=0 means transmitter is busy.  Send will fail
.f876	8e 30 7f	stx $7f30				STX		SDR			; send the character
.f879	38		sec					SEC					; indicate success
.f87a	68		pla		PSXIT1		PLA
.f87b	fa		plx					PLX
.f87c	60		rts					RTS
.f87d					INITVIA
.f87d	9c ec 7f	stz $7fec			STZ     SYSTEM_VIA_PCR			; float CB2 (FAMS) hi so flash A16=1; float CA2 (FA15) hi so flash A15=1 (Bank #3)
.f880	9c eb 7f	stz $7feb			STZ 	SYSTEM_VIA_ACR			; Disable PB7, shift register, timer T1 interrupt.  Not absolutely required while interrupts are disabled FIXME: set up timer
.f883	9c e3 7f	stz $7fe3			STZ	SYSTEM_VIA_DDRA			; Set PA0-PA7 to all inputs
.f886	9c e2 7f	stz $7fe2			STZ	SYSTEM_VIA_DDRB			; In case we're not coming off a reset, make PORT B an input and change output register when it's NOT outputting
.f889	a9 08		lda #$08			LDA	#FIFO_RD				;
.f88b	8d e0 7f	sta $7fe0			STA	SYSTEM_VIA_IORB			; Avoid possible glitch by writing to output latch while Port B is still an input (after reset)
.f88e	a9 0c		lda #$0c			LDA	#(FIFO_RD + FIFO_WR)	; Make the FIFO RD and FIFO_WR pins outputs so we can strobe data in and out of the FIFO
.f890	8d e2 7f	sta $7fe2			STA	SYSTEM_VIA_DDRB			; Port B: PB2 and PB3 are outputs; rest are inputs from earlier IORB write
.f893	ea		nop				NOP								; FIXME: Defensive and possibly unnecessary
.f894					FIFOPWR:
.f894	ad e0 7f	lda $7fe0			LDA	SYSTEM_VIA_IORB
.f897	29 20		and #$20			AND	#FIFO_PWREN				; PB5 = PWRENB. 0=enabled 1=disabled
.f899	d0 f9		bne $f894			BNE	FIFOPWR
.f89b	60		rts				RTS
.f89c	85 f0		sta $f0		FIFOOUT 	STA	TEMP			; save output character
.f89e	ad e0 7f	lda $7fe0			LDA	SYSTEM_VIA_IORB		; Read in FIFO status Port for FIFO
.f8a1	29 01		and #$01			AND	#FIFO_TXE		; If TXE is low, we can accept data into FIFO.  If high, return immmediately
.f8a3	18		clc				CLC
.f8a4	d0 23		bne $f8c9			BNE	OFX1			; 0 = OK to write to FIFO; 1 = Wait, FIFO full!
.f8a6	9c e3 7f	stz $7fe3	OFCONT		STZ	SYSTEM_VIA_DDRA		; (Defensive) Start with Port A input/floating
.f8a9	a9 0c		lda #$0c			LDA	#(FIFO_RD + FIFO_WR)	; RD=1 WR=1 (WR must go 1->0 for FIFO write)
.f8ab	8d e0 7f	sta $7fe0			STA	SYSTEM_VIA_IORB		; Make sure write is high (and read too!)
.f8ae	a5 f0		lda $f0				LDA	TEMP
.f8b0	8d e1 7f	sta $7fe1			STA	SYSTEM_VIA_IORA		; Set up output value in advance in Port A (still input so doesn't go out yet)
.f8b3	a9 ff		lda #$ff			LDA	#$FF			; make Port A all outputs with stable output value already set in prior lines
.f8b5	8d e3 7f	sta $7fe3			STA	SYSTEM_VIA_DDRA		; Save data to output latches
.f8b8	ea		nop				NOP				; Some settling time of data output just to be safe
.f8b9	ea		nop				NOP
.f8ba	ea		nop				NOP
.f8bb	ea		nop				NOP
.f8bc	a9 08		lda #$08			LDA	#(FIFO_RD)		; RD=1 WR=0 (WR1->0 transition triggers FIFO transfer!)
.f8be	8d e0 7f	sta $7fe0			STA	SYSTEM_VIA_IORB		; Low-going WR pulse should latch data
.f8c1	ea		nop				NOP				; Hold time following write strobe, to ensure value is latched OK
.f8c2	ea		nop				NOP
.f8c3	ea		nop				NOP
.f8c4	ea		nop				NOP
.f8c5	9c e3 7f	stz $7fe3			STZ	SYSTEM_VIA_DDRA		; Make port A an input again
.f8c8	38		sec				SEC				; signal success of write to caller
.f8c9	60		rts		OFX1	  	RTS
.f8ca	ad e0 7f	lda $7fe0	FIFOIN		LDA	SYSTEM_VIA_IORB	; Check RXF flag
.f8cd	29 02		and #$02			AND	#FIFO_RXF		; If clear, we're OK to read.  If set, there's no data waiting
.f8cf	18		clc				CLC
.f8d0	d0 1b		bne $f8ed			BNE 	INFXIT			; If RXF is 1, then no character is waiting!
.f8d2	9c e3 7f	stz $7fe3			STZ	SYSTEM_VIA_DDRA		; Make Port A inputs
.f8d5	a9 08		lda #$08			LDA	#FIFO_RD
.f8d7	8d e0 7f	sta $7fe0			STA	SYSTEM_VIA_IORB		; RD=1 WR=0 (RD must go to 0 to read
.f8da	ea		nop				NOP
.f8db	9c e0 7f	stz $7fe0			STZ	SYSTEM_VIA_IORB		; RD=0 WR=0	- FIFO presents data to port A
.f8de	ea		nop				NOP
.f8df	ea		nop				NOP
.f8e0	ea		nop				NOP
.f8e1	ea		nop				NOP
.f8e2	ad e1 7f	lda $7fe1			LDA	SYSTEM_VIA_IORA		; read data in
.f8e5	48		pha				PHA
.f8e6	a9 08		lda #$08			LDA	#FIFO_RD		; Restore back to inactive signals RD=1 and WR=0
.f8e8	8d e0 7f	sta $7fe0			STA	SYSTEM_VIA_IORB
.f8eb	68		pla				PLA
.f8ec	38		sec				SEC				; we got a byte!
.f8ed	60		rts		INFXIT		RTS
.f8ee	6c fe 7e	jmp ($7efe)	GOIRQ		JMP	(IRQVEC)
.f8f1	6c fa 7e	jmp ($7efa)	GONMI		JMP	(NMIVEC)
.f8f4	4c 00 f8	jmp $f800	GORST		JMP	START		; Allowing user program to change this is a mistake
>fffa	f1 f8				NMIENT  .word     GONMI
>fffc	f4 f8				RSTENT  .word     GORST
>fffe	ee f8				IRQENT  .word     GOIRQ

;******  End of listing
