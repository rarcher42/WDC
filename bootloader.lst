
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -L bootloader.lst bootloader.asm
; Sun Jun 23 15:16:58 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: bootloader.asm

=$7fe0					SYSTEM_VIA_IOB              = $7FE0 ; Port B IO register
=$7fe1					SYSTEM_VIA_IOA              = $7FE1 ; Port A IO register
=$7fe2					SYSTEM_VIA_DDRB             = $7FE2 ; Port B data direction register
=$7fe3					SYSTEM_VIA_DDRA             = $7FE3 ; Port A data direction register
=$7fe4					SYSTEM_VIA_T1C_L           = $7FE4 ; Timer 1 counter/latches, low-order
=$7fe5					SYSTEM_VIA_T1C_H           = $7FE5 ; Timer 1 high-order counter
=$7fe6					SYSTEM_VIA_T1L_L           = $7FE6 ; Timer 1 low-order latches
=$7fe7					SYSTEM_VIA_T1L_H           = $7FE7 ; Timer 1 high-order latches
=$7fe8					SYSTEM_VIA_T2C_L           = $7FE8 ; Timer 2 counter/latches, lower-order
=$7fe9					SYSTEM_VIA_T2C_H           = $7FE9 ; Timer 2 high-order counter
=$7fea					SYSTEM_VIA_SR              = $7FEA ; Shift register
=$7feb					SYSTEM_VIA_ACR              = $7FEB ; Auxilliary control register
=$7fec					SYSTEM_VIA_PCR              = $7FEC ; Peripheral control register
=$7fed					SYSTEM_VIA_IFR             = $7FED ; Interrupt flag register
=$7fee					SYSTEM_VIA_IER             = $7FEE ; Interrupt enable register
=$7fef					SYSTEM_VIA_ORA_IRA         = $7FEF ; Port A IO register, but no handshake
=$7f30					ACIA_BASE= $7F30	; This is where the 6551 ACIA starts
=$7f30					SDR = ACIA_BASE       	; RX'ed bytes read, TX bytes written, here
=32561					SSR = ACIA_BASE+1     	; Serial data status register. A write here
=32562					SCMD = ACIA_BASE+2     	; Serial command reg. ()
=32563					SCTL = ACIA_BASE+3     	; Serial control reg. ()
=$1f					SCTL_V  = %00011111       ; 1 stop, 8 bits, 19200 baud
=$0b					SCMD_V  = %00001011       ; No parity, no echo, no tx or rx IRQ, DTR*
=$10					TX_RDY  = %00010000       ; AND mask for transmitter ready
=$08					RX_RDY  = %00001000       ; AND mask for receiver buffer full
=$00					DPL =            $00     ; data pointer (two bytes)
=$01					DPH  =           $01     ; high of data pointer
=$02					RECLEN  =        $02     ; record length in bytes
=$03					START_LO  =      $03
=$04					START_HI =       $04
=$05					RECTYPE =        $05
=$06					CHKSUM =         $06     ; record checksum accumulator
=$07					DLFAIL=          $07     ; flag for download failure
=$08					TEMP =          $08     ; save hex value
=$7efa					NMIVEC	= 	 $7EFA	; write actual NMI vector here
=$7efe					IRQVEC   =       $7EFE   ; write IRQ vector here
=$2000					ENTRY_POINT = 	$2000	; where the RAM program MUST have its first instruction
.f800	78		sei		START   sei                     ; disable interrupts
.f801	d8		cld		        cld                     ; binary mode arithmetic
.f802	a2 ff		ldx #$ff	        ldx     #$FF            ; Set up the stack pointer
.f804	9a		txs		        txs                     ;       "
.f805	a9 f8		lda #$f8	        lda     #>START      ; Initialiaze the interrupt vectors
.f807	8d fb 7e	sta $7efb	        sta     NMIVEC+1        ; User program at ENTRY_POINT may change
.f80a	8d ff 7e	sta $7eff	        sta     IRQVEC+1	; these vectors.  Just do change before enabling
.f80d	a9 00		lda #$00	        lda     #<START		; the interrupts, or you'll end up back in the d/l monitor.
.f80f	8d fa 7e	sta $7efa	        sta     NMIVEC
.f812	8d fe 7e	sta $7efe	        sta     IRQVEC
.f815	20 a5 f9	jsr $f9a5		jsr	INITVIA	; Set up 65C22 to FIFO interface chip (and ROM bank select)
.f818	20 9a f9	jsr $f99a	        jsr     INITSER         ; Set up baud rate, parity, etc.
.f81b	20 58 fa	jsr $fa58	FIFOCHK	jsr	GETFIFO
.f81e	90 fb		bcc $f81b		bcc	FIFOCHK		; If no character, nothing to echo
.f820					FIFO_OUT
.f820	20 7e fa	jsr $fa7e		jsr	PUTFIFO
.f823	80 f6		bra $f81b		bra	FIFOCHK
.f825	a9 00		lda #$00	HEXDNLD lda     #0
.f827	85 07		sta $07		        sta     DLFAIL          ;Start by assuming no D/L failure
.f829	20 23 fa	jsr $fa23	        jsr     PUTSTRI
>f82c	0d 0a 0d 0a			        .text   13,10,13,10
>f830	53 65 6e 64 20 36 35 43		        .text   "Send 65C02/65C816 code in"
>f838	30 32 2f 36 35 43 38 31 36 20 63 6f 64 65 20 69
>f848	6e
>f849	20 49 6e 74 65 6c 20 48		        .text   " Intel Hex format"
>f851	65 78 20 66 6f 72 6d 61 74
>f85a	20 61 74 20 31 39 32 30		        .text  " at 19200,n,8,1 ->"
>f862	30 2c 6e 2c 38 2c 31 20 2d 3e
>f86c	0d 0a				        .text   13,10
>f86e	00					.text	0		; Null-terminate unless you prefer to crash.
.f86f	20 d8 f9	jsr $f9d8	HDWRECS jsr     GETSER          ; Wait for start of record mark ':'
.f872	c9 3a		cmp #$3a	        cmp     #':'
.f874	d0 f9		bne $f86f	        bne     HDWRECS         ; not found yet
.f876	20 e3 f9	jsr $f9e3	        jsr     GETHEX          ; Get the record length
.f879	85 02		sta $02		        sta     RECLEN          ; save it
.f87b	85 06		sta $06		        sta     CHKSUM          ; and save first byte of checksum
.f87d	20 e3 f9	jsr $f9e3	        jsr     GETHEX          ; Get the high part of start address
.f880	85 04		sta $04		        sta     START_HI
.f882	18		clc		        clc
.f883	65 06		adc $06		        adc     CHKSUM          ; Add in the checksum
.f885	85 06		sta $06		        sta     CHKSUM          ;
.f887	20 e3 f9	jsr $f9e3	        jsr     GETHEX          ; Get the low part of the start address
.f88a	85 03		sta $03		        sta     START_LO
.f88c	18		clc		        clc
.f88d	65 06		adc $06		        adc     CHKSUM
.f88f	85 06		sta $06		        sta     CHKSUM
.f891	20 e3 f9	jsr $f9e3	        jsr     GETHEX          ; Get the record type
.f894	85 05		sta $05		        sta     RECTYPE         ; & save it
.f896	18		clc		        clc
.f897	65 06		adc $06		        adc     CHKSUM
.f899	85 06		sta $06		        sta     CHKSUM
.f89b	a5 05		lda $05		        lda     RECTYPE
.f89d	d0 2c		bne $f8cb	        bne     HDER1           ; end-of-record
.f89f	a6 02		ldx $02		        ldx     RECLEN          ; number of data bytes to write to memory
.f8a1	a0 00		ldy #$00	        ldy     #0              ; start offset at 0
.f8a3	20 e3 f9	jsr $f9e3	HDLP1   jsr     GETHEX          ; Get the first/next/last data byte
.f8a6	91 03		sta ($03),y	        sta     (START_LO),y    ; Save it to RAM
.f8a8	18		clc		        clc
.f8a9	65 06		adc $06		        adc     CHKSUM
.f8ab	85 06		sta $06		        sta     CHKSUM          ;
.f8ad	c8		iny		        iny                     ; update data pointer
.f8ae	ca		dex		        dex                     ; decrement count
.f8af	d0 f2		bne $f8a3	        bne     HDLP1
.f8b1	20 e3 f9	jsr $f9e3	        jsr     GETHEX          ; get the checksum
.f8b4	18		clc		        clc
.f8b5	65 06		adc $06		        adc     CHKSUM
.f8b7	d0 08		bne $f8c1	        bne     HDDLF1          ; If failed, report it
.f8b9	a9 23		lda #$23	        lda     #'#'            ; Character indicating record OK = '#'
.f8bb	8d 30 7f	sta $7f30	        sta     SDR             ; write it out but don't wait for output
.f8be	4c 6f f8	jmp $f86f	        jmp     HDWRECS         ; get next record
.f8c1	a9 46		lda #$46	HDDLF1  lda     #'F'            ; Character indicating record failure = 'F'
.f8c3	85 07		sta $07		        sta     DLFAIL          ; download failed if non-zero
.f8c5	8d 30 7f	sta $7f30	        sta     SDR             ; write it to transmit buffer register
.f8c8	4c 6f f8	jmp $f86f	        jmp     HDWRECS         ; wait for next record start
.f8cb	c9 01		cmp #$01	HDER1   cmp     #1              ; Check for end-of-record type
.f8cd	f0 31		beq $f900	        beq     HDER2
.f8cf	20 23 fa	jsr $fa23	        jsr     PUTSTRI         ; Warn user of unknown record type
>f8d2	0d 0a 0d 0a			        .text   13,10,13,10
>f8d6	55 6e 6b 6e 6f 77 6e 20		        .text   "Unknown record type $"
>f8de	72 65 63 6f 72 64 20 74 79 70 65 20 24
>f8eb	00					.text	0		; null-terminate unless you prefer to crash!
.f8ec	a5 05		lda $05		        lda     RECTYPE         ; Get it
.f8ee	85 07		sta $07			sta	DLFAIL		; non-zero --> download has failed
.f8f0	20 05 fa	jsr $fa05	        jsr     PUTHEX          ; print it
.f8f3	a9 0d		lda #$0d		lda     #13		; but we'll let it finish so as not to
.f8f5	20 18 fa	jsr $fa18	        jsr     PUTSER		; falsely start a new d/l from existing
.f8f8	a9 0a		lda #$0a	        lda     #10		; file that may still be coming in for
.f8fa	20 18 fa	jsr $fa18	        jsr     PUTSER		; quite some time yet.
.f8fd	4c 6f f8	jmp $f86f		jmp	HDWRECS
.f900	20 e3 f9	jsr $f9e3	HDER2   jsr     GETHEX          ; get the checksum
.f903	18		clc		        clc
.f904	65 06		adc $06		        adc     CHKSUM          ; Add previous checksum accumulator value
.f906	f0 21		beq $f929	        beq     HDER3           ; checksum = 0 means we're OK!
.f908	20 23 fa	jsr $fa23	        jsr     PUTSTRI         ; Warn user of bad checksum
>f90b	0d 0a 0d 0a			        .text   13,10,13,10
>f90f	42 61 64 20 72 65 63 6f		        .text   "Bad record checksum!",13,10
>f917	72 64 20 63 68 65 63 6b 73 75 6d 21 0d 0a
>f925	00				        .text   0		; Null-terminate or 6502 go bye-bye
.f926	4c 00 f8	jmp $f800	        jmp     START
.f929	a5 07		lda $07		HDER3   lda     DLFAIL
.f92b	f0 27		beq $f954	        beq     HDEROK
.f92d	20 23 fa	jsr $fa23	        jsr     PUTSTRI
>f930	0d 0a 0d 0a			        .text   13,10,13,10
>f934	44 6f 77 6e 6c 6f 61 64		        .text   "Download Failed",13,10
>f93c	20 46 61 69 6c 65 64 0d 0a
>f945	41 62 6f 72 74 69 6e 67		        .text   "Aborting!",13,10
>f94d	21 0d 0a
>f950	00					.text	0		; null-terminate every string yada yada.
.f951	4c 00 f8	jmp $f800	        jmp     START
.f954	20 23 fa	jsr $fa23	HDEROK  jsr     PUTSTRI
>f957	0d 0a 0d 0a			        .text   13,10,13,10
>f95b	44 6f 77 6e 6c 6f 61 64		        .text   "Download Successful!",13,10
>f963	20 53 75 63 63 65 73 73 66 75 6c 21 0d 0a
>f971	4a 75 6d 70 69 6e 67 20		        .text   "Jumping to location $"
>f979	74 6f 20 6c 6f 63 61 74 69 6f 6e 20 24
>f986	00					.text	0			; by now, I figure you know what this is for. :)
.f987	a9 20		lda #$20	        lda	#>ENTRY_POINT		; Print the entry point in hex
.f989	20 05 fa	jsr $fa05	        jsr	PUTHEX
.f98c	a9 00		lda #$00	        lda	#<ENTRY_POINT
.f98e	20 05 fa	jsr $fa05		jsr	PUTHEX
.f991	20 23 fa	jsr $fa23	        jsr	PUTSTRI
>f994	0d 0a				        .text   13,10
>f996	00				        .text   0		; stop lemming-like march of the program ctr. thru data
.f997	4c 00 20	jmp $2000	        jmp     ENTRY_POINT	; jump to canonical entry point
.f99a	a9 1f		lda #$1f	INITSER lda     #SCTL_V 	; Set baud rate 'n stuff
.f99c	8d 33 7f	sta $7f33	        sta     SCTL
.f99f	a9 0b		lda #$0b	        lda     #SCMD_V 	; set parity, interrupt disable, n'stuff
.f9a1	8d 32 7f	sta $7f32	        sta     SCMD
.f9a4	60		rts		        rts
.f9a5	9c eb 7f	stz $7feb	INITVIA	STZ     SYSTEM_VIA_ACR	; Disable PB7, shift register, timer T1 interrupt.
.f9a8	9c ec 7f	stz $7fec	        STZ     SYSTEM_VIA_PCR
.f9ab	a9 18		lda #$18	        lda     #$18
.f9ad	8d e0 7f	sta $7fe0	        STA     SYSTEM_VIA_IOB
.f9b0	a9 1c		lda #$1c	        lda     #$1C
.f9b2	8d e2 7f	sta $7fe2	        STA     SYSTEM_VIA_DDRB
.f9b5	9c e3 7f	stz $7fe3	        STZ     SYSTEM_VIA_DDRA
.f9b8	ad e0 7f	lda $7fe0	        lda     SYSTEM_VIA_IOB
.f9bb	48		pha		        PHA
.f9bc	29 ef		and #$ef	        AND     #$EF
.f9be	8d e0 7f	sta $7fe0	        STA     SYSTEM_VIA_IOB
.f9c1	a2 5d		ldx #$5d	        LDX     #$5D
.f9c3	20 aa fa	jsr $faaa	        JSR     WASTETM
.f9c6	68		pla		        PLA
.f9c7	8d e0 7f	sta $7fe0	        STA     SYSTEM_VIA_IOB
.f9ca	a9 20		lda #$20	        lda     #$20
.f9cc					WFPWRBIT
.f9cc	ad e0 7f	lda $7fe0		LDA	SYSTEM_VIA_IOB
.f9cf	d0 fb		bne $f9cc	        BNE     WFPWRBIT
.f9d1	60		rts		        RTS
.f9d2	ad 31 7f	lda $7f31	SERRDY  lda     SSR     	; look at serial status
.f9d5	29 08		and #$08	        and     #RX_RDY 	; strip off "character waiting" bit
.f9d7	60		rts		        rts             	; if zero, nothing waiting.
.f9d8	ad 31 7f	lda $7f31	GETSER  lda     SSR    		; look at serial status
.f9db	29 08		and #$08	        and     #RX_RDY 	; see if anything is ready
.f9dd	f0 f9		beq $f9d8	        beq     GETSER  	; busy-wait until character comes in!
.f9df	ad 30 7f	lda $7f30	        lda     SDR     	; get the character
.f9e2	60		rts		        rts
.f9e3	20 d8 f9	jsr $f9d8	GETHEX  jsr     GETSER
.f9e6	20 fa f9	jsr $f9fa	        jsr     MKNIBL  	; Convert to 0..F numeric
.f9e9	0a		asl a		        asl     a
.f9ea	0a		asl a		        asl     a
.f9eb	0a		asl a		        asl     a
.f9ec	0a		asl a		        asl     a       	; This is the upper nibble
.f9ed	29 f0		and #$f0	        and     #$F0
.f9ef	85 08		sta $08		        sta     TEMP
.f9f1	20 d8 f9	jsr $f9d8	        jsr     GETSER
.f9f4	20 fa f9	jsr $f9fa	        jsr     MKNIBL
.f9f7	05 08		ora $08		        ora     TEMP
.f9f9	60		rts		        rts             	; return with the nibble received
.f9fa	c9 3a		cmp #$3a	MKNIBL  cmp     #'9'+1  	; See if it's 0-9 or 'A'..'F' (no lowercase yet)
.f9fc	90 02		bcc $fa00	        bcc     MKNNH   	; If we borrowed, we lost the carry so 0..9
.f9fe	e9 08		sbc #$08	        sbc     #7+1    	; Subtract off extra 7 (sbc subtracts off one less)
.fa00	e9 2f		sbc #$2f	MKNNH   sbc     #'0'-1  	; subtract off '0' (if carry clear coming in)
.fa02	29 0f		and #$0f	        and     #$0F    	; no upper nibble no matter what
.fa04	60		rts		        rts             	; and return the nibble
.fa05	48		pha		PUTHEX  pha             	;
.fa06	4a		lsr a		        lsr a
.fa07	4a		lsr a		        lsr a
.fa08	4a		lsr a		        lsr a
.fa09	4a		lsr a		        lsr a
.fa0a	20 0e fa	jsr $fa0e	        jsr     PRNIBL
.fa0d	68		pla		        pla
.fa0e	29 0f		and #$0f	PRNIBL  and     #$0F    	; strip off the low nibble
.fa10	c9 0a		cmp #$0a	        cmp     #$0A
.fa12	90 02		bcc $fa16	        bcc     NOTHEX  	; if it's 0-9, add '0' else also add 7
.fa14	69 06		adc #$06	        adc     #6      	; Add 7 (6+carry=1), result will be carry clear
.fa16	69 30		adc #$30	NOTHEX  adc     #'0'    	; If carry clear, we're 0-9
.fa18	8d 30 7f	sta $7f30	PUTSER  sta     SDR     	; write to transmit register
.fa1b	ad 31 7f	lda $7f31	WRS1    lda     SSR     	; get status
.fa1e	29 10		and #$10	        and     #TX_RDY 	; see if transmitter is busy
.fa20	f0 f9		beq $fa1b	        beq     WRS1    	; if it is, wait
.fa22	60		rts		        rts
.fa23	68		pla		PUTSTRI pla			; Get the low part of "return" address (data start address)
.fa24	85 00		sta $00		        sta     DPL
.fa26	68		pla		        pla
.fa27	85 01		sta $01		        sta     DPH             ; Get the high part of "return" address
.fa29	a0 01		ldy #$01	PSINB   ldy     #1
.fa2b	b1 00		lda ($00),y	        lda     (DPL),y         ; Get the next string character
.fa2d	e6 00		inc $00		        inc     DPL             ; update the pointer
.fa2f	d0 02		bne $fa33	        bne     PSICHO          ; if not, we're pointing to next character
.fa31	e6 01		inc $01		        inc     DPH             ; account for page crossing
.fa33	09 00		ora #$00	PSICHO  ora     #0              ; Set flags according to contents of Accumulator
.fa35	f0 06		beq $fa3d	        beq     PSIX1           ; don't print the final NULL
.fa37	20 18 fa	jsr $fa18	        jsr     PUTSER          ; write it out
.fa3a	4c 29 fa	jmp $fa29	        jmp     PSINB           ; back around
.fa3d	e6 00		inc $00		PSIX1   inc     DPL             ;
.fa3f	d0 02		bne $fa43	        bne     PSIX2           ;
.fa41	e6 01		inc $01		        inc     DPH             ; account for page crossing
.fa43	6c 00 00	jmp ($0000)	PSIX2   jmp     (DPL)           ; return to byte following final NULL
.fa46					Is_VIA_USB_RX_Data_Avail:
.fa46	a9 00		lda #$00	        LDA     #$00
.fa48	8d e3 7f	sta $7fe3	        STA     SYSTEM_VIA_DDRA
.fa4b	a9 02		lda #$02	        LDA     #$02
.fa4d	2c e0 7f	bit $7fe0	        bit     SYSTEM_VIA_IOB
.fa50	d0 03		bne $fa55	        bne     not_zero
.fa52	a9 01		lda #$01	        LDA     #$01
.fa54	60		rts		        RTS
.fa55					not_zero
.fa55	a9 00		lda #$00		LDA     #$00	; It is high, meaning there is no data available to read.
.fa57	60		rts		        RTS
.fa58	da		phx		GETFIFO	PHX				; Save X
.fa59	9c e3 7f	stz $7fe3		STZ     SYSTEM_VIA_DDRA		; D0-D7 from FIFO --> CPU (00 = make all port A pins inputs)
.fa5c	a9 02		lda #$02	        LDA     #$02
.fa5e	2c e0 7f	bit $7fe0		BIT     SYSTEM_VIA_IOB	; AND with b1 to see if RXF is low (character awaiting read) or RXF=1 (no data waiting)
.fa61	f0 03		beq $fa66	       	BEQ     GFRD		; 0 = FIFO has a character, so read it in
.fa63	18		clc			CLC			; carry clear means nothing is waiting
.fa64	80 16		bra $fa7c		BRA GFXIT		; And return with carry clear because is waiting
.fa66	ad e0 7f	lda $7fe0	GFRD: 	lda     SYSTEM_VIA_IOB
.fa69	09 08		ora #$08	        ora     #$08    ; Save a copy of port B with PB3 set high.
.fa6b	aa		tax		        tax     ; This will be used later.
.fa6c	29 f7		and #$f7	        and     #$F7
.fa6e	8d e0 7f	sta $7fe0	        STA     SYSTEM_VIA_IOB
.fa71	ea		nop		        nop	; FIXME: This is some dumb bullshift. That's ONE machine cycle.
.fa72	ea		nop		        nop	; FIXME: Will retain for now in case it's papering over some other problem that the original firmware is working around.
.fa73	ea		nop		        nop
.fa74	ea		nop		        NOP
.fa75	ad e1 7f	lda $7fe1	        LDA     SYSTEM_VIA_IOA
.fa78	8e e0 7f	stx $7fe0	        stx     SYSTEM_VIA_IOB
.fa7b	38		sec			SEC		; Signal that a valid character is waiting
.fa7c	fa		plx		GFXIT	PLX		; Restore X as it was used in routine
.fa7d	60		rts			RTS
.fa7e					PUTFIFO
.fa7e	9c e3 7f	stz $7fe3		STZ     SYSTEM_VIA_DDRA		; Set all bits on port A to inputs.
.fa81	8d e1 7f	sta $7fe1	       	STA     SYSTEM_VIA_IOA
.fa84	a9 01		lda #$01	        LDA     #$01
.fa86					WFTXEBL
.fa86	2c e0 7f	bit $7fe0		bit     SYSTEM_VIA_IOB
.fa89	d0 fb		bne $fa86	        BNE     WFTXEBL
.fa8b	ad e0 7f	lda $7fe0	        lda     SYSTEM_VIA_IOB
.fa8e	29 fb		and #$fb	        AND     #$FB	; Save a copy of port B with PB2 low.
.fa90	aa		tax		        TAX
.fa91	09 04		ora #$04	        ora     #$04	; Set PB2 high.
.fa93	8d e0 7f	sta $7fe0	        STA     SYSTEM_VIA_IOB
.fa96	a9 ff		lda #$ff	        lda     #$FF
.fa98	8d e3 7f	sta $7fe3	        STA     SYSTEM_VIA_DDRA
.fa9b	ea		nop		        NOP
.fa9c	ea		nop		        NOP
.fa9d	8e e0 7f	stx $7fe0	        STX     SYSTEM_VIA_IOB
.faa0	ad e1 7f	lda $7fe1	        LDA     SYSTEM_VIA_IOA
.faa3	a2 00		ldx #$00	        ldx     #$00
.faa5	8e e3 7f	stx $7fe3	        STX     SYSTEM_VIA_DDRA
.faa8	60		rts		        rts
.faa9					Do_Nothing_Subroutine_1:
.faa9	60		rts		        rts
.faaa	da		phx		WASTETM	phx
.faab	a2 00		ldx #$00	        ldx     #$00
.faad					loop_256_times:
.faad	ca		dex		        dex
.faae	d0 fd		bne $faad	        bne     loop_256_times
.fab0	fa		plx		        plx
.fab1	ca		dex		        dex
.fab2	d0 f6		bne $faaa	        bne    	WASTETM
.fab4	60		rts		        rts
.fab5	6c fe 7e	jmp ($7efe)	GOIRQ	jmp	(IRQVEC)
.fab8	6c fa 7e	jmp ($7efa)	GONMI	jmp	(NMIVEC)
.fabb	4c 00 f8	jmp $f800	GORST	jmp	START		; Allowing user program to change this is a mistake
>fffa	b8 fa				NMIENT  .word     GONMI
>fffc	bb fa				RSTENT  .word     GORST
>fffe	b5 fa				IRQENT  .word     GOIRQ

;******  End of listing
