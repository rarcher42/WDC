
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -L monitor.lst --intel-hex -o monitor.hex monitor.asm
; Mon Jul 15 17:58:08 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: monitor.asm


;******  Processing file: via_symbols.inc

=$7fe0					SYS_VIA_BASE	    = 	$7FE0
=32736					SYSTEM_VIA_IORB     =  	SYS_VIA_BASE+0	; Port B IO register
=32737					SYSTEM_VIA_IORA     =	SYS_VIA_BASE+1 	; Port A IO register
=32738					SYSTEM_VIA_DDRB     = 	SYS_VIA_BASE+2	; Port B data direction register
=32739					SYSTEM_VIA_DDRA     = 	SYS_VIA_BASE+3	; Port A data direction register
=32740					SYSTEM_VIA_T1C_L    =	SYS_VIA_BASE+4 	; Timer 1 counter/latches, low-order
=32741					SYSTEM_VIA_T1C_H    = 	SYS_VIA_BASE+5	; Timer 1 high-order counter
=32742					SYSTEM_VIA_T1L_L    = 	SYS_VIA_BASE+6	; Timer 1 low-order latches
=32743					SYSTEM_VIA_T1L_H    = 	SYS_VIA_BASE+7	; Timer 1 high-order latches
=32744					SYSTEM_VIA_T2C_L    = 	SYS_VIA_BASE+8	; Timer 2 counter/latches, lower-order
=32745					SYSTEM_VIA_T2C_H    = 	SYS_VIA_BASE+9	; Timer 2 high-order counter
=32746					SYSTEM_VIA_SR       = 	SYS_VIA_BASE+10	; Shift register
=32747					SYSTEM_VIA_ACR      = 	SYS_VIA_BASE+11	; Auxilliary control register
=32748					SYSTEM_VIA_PCR      =	SYS_VIA_BASE+12	; Peripheral control register
=32749					SYSTEM_VIA_IFR	    =	SYS_VIA_BASE+13 ; Interrupt flag register
=32750					SYSTEM_VIA_IER      = 	SYS_VIA_BASE+14	; Interrupt enable register
=32751					SYSTEM_VIA_ORA_IRA  =	SYS_VIA_BASE+15	; Port A IO register, but no handshake
=$7fc0					DEBUG_VIA_BASE	    = 	$7FC0
=32704					DEBUG_VIA_IORB     =  	DEBUG_VIA_BASE+0	; Port B IO register
=32705					DEBUG_VIA_IORA     =	DEBUG_VIA_BASE+1 	; Port A IO register
=32706					DEBUG_VIA_DDRB     = 	DEBUG_VIA_BASE+2	; Port B data direction register
=32707					DEBUG_VIA_DDRA     = 	DEBUG_VIA_BASE+3	; Port A data direction register
=32708					DEBUG_VIA_T1C_L    =	DEBUG_VIA_BASE+4 	; Timer 1 counter/latches, low-order
=32709					DEBUG_VIA_T1C_H    = 	DEBUG_VIA_BASE+5	; Timer 1 high-order counter
=32710					DEBUG_VIA_T1L_L    = 	DEBUG_VIA_BASE+6	; Timer 1 low-order latches
=32711					DEBUG_VIA_T1L_H    = 	DEBUG_VIA_BASE+7	; Timer 1 high-order latches
=32712					DEBUG_VIA_T2C_L    = 	DEBUG_VIA_BASE+8	; Timer 2 counter/latches, lower-order
=32713					DEBUG_VIA_T2C_H    = 	DEBUG_VIA_BASE+9	; Timer 2 high-order counter
=32714					DEBUG_VIA_SR       = 	DEBUG_VIA_BASE+10	; Shift register
=32715					DEBUG_VIA_ACR      = 	DEBUG_VIA_BASE+11	; Auxilliary control register
=32716					DEBUG_VIA_PCR      =	DEBUG_VIA_BASE+12	; Peripheral control register
=32717					DEBUG_VIA_IFR	    =	DEBUG_VIA_BASE+13 ; Interrupt flag register
=32718					DEBUG_VIA_IER      = 	DEBUG_VIA_BASE+14	; Interrupt enable register
=32719					DEBUG_VIA_ORA_IRA  =	DEBUG_VIA_BASE+15	; Port A IO register, but no handshake
=$01					PB0 = MASK0
=$02					PB1 = MASK1
=$04					PB2 = MASK2
=$08					PB3 = MASK3
=$10					PB4 = MASK4
=$20					PB5 = MASK5
=$40					PB6 = MASK6
=$80					PB7 = MASK7
=$01					PA0 = MASK0
=$02					PA1 = MASK1
=$04					PA2 = MASK2
=$08					PA3 = MASK3
=$10					PA4 = MASK4
=$20					PA5 = MASK5
=$40					PA6 = MASK6
=$80					PA7 = MASK7

;******  Return to file: monitor.asm


;******  Processing file: acia_symbols.inc

=$7f80					ACIA_BASE = $7F80		; This is where the 6551 ACIA starts
=$7f80					SDR = ACIA_BASE       		; RX'ed bytes read, TX bytes written, here
=32641					SSR = ACIA_BASE+1     		; Serial data status register
=32642					SCMD = ACIA_BASE+2     		; Serial command reg. ()
=32643					SCTL = ACIA_BASE+3     		; Serial control reg. ()
=$10					TX_RDY = MASK4
=$08					RX_RDY = MASK3
=$00					ALL_INPUTS = $00
=$ff					ALL_OUTPUTS = $FF

;******  Return to file: monitor.asm

=$03					CTRL_C	= $03
=$08					BS		= $08
=$0a					LF		= $0A
=$0d					CR		= $0D
=$20					SP		= $20
=$7f					DEL     = $7F
=$01					MASK0		= %00000001
=$02					MASK1		= %00000010
=$04					MASK2		= %00000100
=$08					MASK3		= %00001000
=$10					MASK4		= %00010000
=$20					MASK5		= %00100000
=$40					MASK6 		= %01000000
=$80					MASK7		= %10000000
=$80					N_FLAG		= MASK7
=$40					V_FLAG		= MASK6
=$20					M_FLAG		= MASK5
=$10					X_FLAG		= MASK4
=$08					D_FLAG		= MASK3
=$04					I_FLAG		= MASK2
=$02					Z_FLAG		= MASK1
=$01					C_FLAG		= MASK0
=$43					TERMFLAGS = $43
=$01					RDRDY	= $01				; 1 = character waiting
=$04					XONXOFF = $04				; 0 = hardware handshake 1= XON/XOFF
=$20					ECHOOFF = $20
>00e0					REC_TYPE	.byte 	?
>00e1					DP_START	.byte	?
>00e2					PTR_L		.byte	?	; Generic pointer
>00e3					PTR_H		.byte	?
>00e4					PTR_B		.byte	?
=$e2					PTR			=		PTR_L
>00e5					CTR_L		.byte	?	; Counter
>00e6					CTR_H		.byte	?
>00e7					CTR_B		.byte	?
=$e5					CTR			= 		CTR_L
>00e8					SA_L		.byte 	?	; Starting address storage for various commands & loader
>00e9					SA_H		.byte 	?
>00ea					SA_B		.byte	?
=$e8					SA			=		SA_L
>00eb					EA_L		.byte 	?	; Starting address storage for various commands
>00ec					EA_H		.byte 	?
>00ed					EA_B		.byte	?
=$eb					EA			=		EA_L
>00ee					DATA_CNT	.byte 	?	; Count of record's actual storable data bytes
>00ef					TEMP2		.byte	?
>00f0					SUBTEMP 	.byte	?	; Any subroutine that doesn't call others can use as local scratchpad space
>00f1					HEXASSY		.byte	?
>0400					CMDBUF 		.fill	256	; can be smaller than 256 but must not cross 8 bit page boundary
>0500					CB_RDPTR	.word	?	; Use LDA/STA 0,X typically
>0502					CB_WRPTR	.word 	?	; Use LAD/STA 0,Y typically
>0504					PRM_SA	.word	?		; Parameter start address
>0506					PRM_SIZ	.byte	?		; Size of current parameter
>0507					EOLFLAG	.byte	?		; 0 = EOL not found, !0 = EOL has been encountered
>0508					BYTECNT	.byte 	?
>0509					HEXIO_L	.byte	?
>050a					HEXIO_H	.byte	?
>050b					HEXIO_B	.byte	?
=$0509					HEXIO		=	HEXIO_L				; 24 bit HEX value to print
=$7eff					STACKTOP	=	$7EFF				; Top of RAM = $07EFF (I/O is $7F00-$7FFF)
.f800					START
.f800	78		sei					SEI
.f801	18		clc					CLC
.f802	fb		xce					XCE
.f803	c2 18		rep #$18				REP	#(X_FLAG | D_FLAG)
.f805	e2 20		sep #$20				SEP	#M_FLAG
.f807	a2 ff 7e	ldx #$7eff				LDX	#STACKTOP
.f80a	9a		txs					TXS
.f80b	20 4a f9	jsr $f94a				JSR	INIT_FIFO
.f80e	a0 51 f0	ldy #$f051				LDY	#QBFMSG			; Start of monitor loop
.f811	20 88 fb	jsr $fb88				JSR	PUT_STR
.f814					MONGETL
.f814	20 b2 f8	jsr $f8b2				JSR	GETLINE
.f817	20 3d f8	jsr $f83d				JSR	PARSELINE
.f81a	80 f8		bra $f814				BRA	MONGETL			; End of monitor loop
.f81c					INITPARS
.f81c	9c 06 05	stz $0506				STZ	PRM_SIZ			; No known parameter size
.f81f	9c 07 05	stz $0507				STZ	EOLFLAG			; No EOL found yet
.f822	a9 04		lda #$04				LDA	#>CMDBUF		; Initialize the read pointers
.f824	8d 01 05	sta $0501				STA	CB_RDPTR+1		; High address byte to high pointer byte
.f827	8d 05 05	sta $0505				STA	PRM_SA+1
.f82a	a9 00		lda #$00				LDA	#<CMDBUF		; Low address byte to low pointer byte
.f82c	8d 00 05	sta $0500				STA	CB_RDPTR
.f82f	8d 04 05	sta $0504				STA	PRM_SA			; CB_WRPTR, PRMSA are pointers into CMDBUF e.g. LDA 0,Y/x
.f832	60		rts					RTS
.f833					CLRCMD
.f833	a2 00 04	ldx #$0400				LDX	#CMDBUF			; Point CB_WRPTR to start of command buffer
.f836	8e 02 05	stx $0502				STX	CB_WRPTR
.f839	9c 00 04	stz $0400				STZ	CMDBUF			; Null terminate the empty buffer
.f83c	60		rts					RTS
.f83d					PARSELINE
.f83d	20 1c f8	jsr $f81c				JSR	INITPARS
.f840					FINDCMD
.f840	20 69 f8	jsr $f869				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.f843	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.f846	d0 20		bne $f868				BNE	PLIX2			; We hit an EOL before an actionable character, so quit
.f848	a9 00		lda #$00				LDA	#0
.f84a	eb		xba					XBA				; Make B zero so when TAX times comes, MSB of X will be 0! (0 emphasis not 0 factorial)
.f84b	ae 00 05	ldx $0500				LDX	CB_RDPTR		; point to command byte
.f84e	b5 00		lda $00,x				LDA	0,X			; Get command byte
.f850	e8		inx					INX				; Point past the command byte to save each subroutine from doing this
.f851	8e 00 05	stx $0500				STX	CB_RDPTR		; "
.f854	c9 41		cmp #$41				CMP	#'A'
.f856	90 0d		bcc $f865				BCC	PLERRXIT		; < 'A', so not a command
.f858	c9 5b		cmp #$5b				CMP	#'Z'+1
.f85a	b0 09		bcs $f865				BCS	PLERRXIT		; > 'Z', so not a command
.f85c	e9 40		sbc #$40				SBC	#'A'-1			; Carry clear, so subtract one less to account for borrow
.f85e	0a		asl a					ASL	A			; Two bytes per JSR table entry
.f85f	aa		tax					TAX						; X now holds offset in MONTABLE
.f860	fc 94 fd	jsr ($fd94,x)				JSR	(MONTBL,X)		; No JSR indirect indexed.  Each table entry MUST end in RTS not RTL!
.f863	80 03		bra $f868				BRA	PLIX2			; We're done dispatching.
.f865					PLERRXIT:
.f865	20 52 fb	jsr $fb52				JSR	LOLWUT			; Print non-understood buffer plus ?[CR][LF]
.f868					PLIX2
.f868	60		rts					RTS
.f869					FINDSTART
.f869	ac 00 05	ldy $0500				LDY	CB_RDPTR
.f86c					FSN1
.f86c	b9 00 00	lda $0000,y				LDA	0,Y			; Get next character
.f86f	f0 0f		beq $f880				BEQ	FSEOL			; Null --> End of line encountered.  We are done
.f871	c9 0d		cmp #$0d				CMP	#CR
.f873	f0 0b		beq $f880				BEQ	FSEOL			; CR = end of line also
.f875	c9 03		cmp #$03				CMP	#CTRL_C
.f877	f0 07		beq $f880				BEQ	FSEOL			; CTRL-C = end of line
.f879	c9 21		cmp #$21				CMP	#SP+1			; if space or less, and not CR or CTRL-C, skip over
.f87b	b0 08		bcs $f885				BCS	FSDUN			; A non-whitespace character.  We're done looking
.f87d	c8		iny					INY				; Keep looking for a valid parameter byte
.f87e	80 ec		bra $f86c				BRA	FSN1			; Next character
.f880					FSEOL
.f880	a9 01		lda #$01				LDA	#1
.f882	8d 07 05	sta $0507				STA	EOLFLAG
.f885					FSDUN
.f885	8c 00 05	sty $0500				STY	CB_RDPTR		; Save pointers by current value of Y
.f888	8c 04 05	sty $0504				STY	PRM_SA			; Save pointers by current value of Y
.f88b	60		rts					RTS
.f88c					FINDEND
.f88c	9c 06 05	stz $0506				STZ	PRM_SIZ			; No known parameter bytes yet
.f88f	ac 00 05	ldy $0500				LDY	CB_RDPTR
.f892					FEN1
.f892	b9 00 00	lda $0000,y				LDA	0,Y			; Get next character
.f895	f0 12		beq $f8a9				BEQ	FEEOL			; Null --> End of line encountered.  We are done
.f897	c9 0d		cmp #$0d				CMP	#CR
.f899	f0 0e		beq $f8a9				BEQ	FEEOL			; CR = end of line also
.f89b	c9 03		cmp #$03				CMP	#CTRL_C
.f89d	f0 0a		beq $f8a9				BEQ	FEEOL			; CTRL-C = end of line
.f89f	c9 21		cmp #$21				CMP	#SP+1			; if space or less, and not CR or CTRL-C,
.f8a1	90 0b		bcc $f8ae				BCC	FEDUN1			; A whitespace character.  We're done looking
.f8a3	c8		iny					INY
.f8a4	ee 06 05	inc $0506				INC	PRM_SIZ			; add one more to size of parameter
.f8a7	80 e9		bra $f892				BRA	FEN1
.f8a9					FEEOL
.f8a9	a9 01		lda #$01				LDA	#1
.f8ab	8d 07 05	sta $0507				STA	EOLFLAG
.f8ae					FEDUN1
.f8ae	8c 00 05	sty $0500				STY	CB_RDPTR		; Save pointers by current value of read pointer (don't update PRM_SA)
.f8b1	60		rts					RTS
.f8b2					GETLINE
.f8b2	20 63 fb	jsr $fb63				JSR	CRLF
.f8b5	a9 3e		lda #$3e				LDA	#'>'
.f8b7	20 84 fb	jsr $fb84				JSR	PUTCHAR
.f8ba	20 33 f8	jsr $f833				JSR	CLRCMD
.f8bd					GLLP1
.f8bd	20 a3 fb	jsr $fba3				JSR	GETCHAR				; Do not echo
.f8c0	c9 0d		cmp #$0d				CMP	#CR
.f8c2	d0 05		bne $f8c9				BNE	GLNC0
.f8c4	20 84 fb	jsr $fb84				JSR	PUTCHAR
.f8c7	80 43		bra $f90c				BRA	GLXIT1				; end of message
.f8c9					GLNC0
.f8c9	c9 03		cmp #$03				CMP	#CTRL_C
.f8cb	d0 14		bne $f8e1				BNE	GLNC1
.f8cd	a9 5e		lda #$5e				LDA	#'^'
.f8cf	20 84 fb	jsr $fb84				JSR	PUTCHAR
.f8d2	a9 43		lda #$43				LDA	#'C'
.f8d4	20 84 fb	jsr $fb84				JSR	PUTCHAR
.f8d7	a9 0d		lda #$0d				LDA	#CR
.f8d9	20 84 fb	jsr $fb84				JSR	PUTCHAR
.f8dc	20 33 f8	jsr $f833				JSR	CLRCMD				; zotch out any command in buffer
.f8df	80 2b		bra $f90c				BRA	GLXIT1
.f8e1					GLNC1
.f8e1	c9 0a		cmp #$0a				CMP	#LF
.f8e3	d0 02		bne $f8e7				BNE	GLNC2
.f8e5	80 d6		bra $f8bd				BRA	GLLP1
.f8e7					GLNC2
.f8e7	c9 08		cmp #$08				CMP	#BS				; We will not tolerate BS here
.f8e9	d0 16		bne $f901				BNE	GLNC9
.f8eb	c9 7f		cmp #$7f				CMP	#DEL
.f8ed	d0 12		bne $f901				BNE	GLNC9
.f8ef	74 00		stz $00,x				STZ	0,X
.f8f1	e0 00 04	cpx #$0400				CPX	#CMDBUF
.f8f4	f0 c7		beq $f8bd				BEQ	GLLP1				; Already backed over the first character. No index to decrement
.f8f6	20 84 fb	jsr $fb84				JSR	PUTCHAR
.f8f9	ca		dex					DEX					; change buffer pointer
.f8fa	8e 02 05	stx $0502				STX	CB_WRPTR
.f8fd	74 00		stz $00,x				STZ	0,X				; Character we backed over is now end of string
.f8ff	80 bc		bra $f8bd				BRA	GLLP1
.f901					GLNC9
.f901	95 00		sta $00,x				STA	0,X				; store it
.f903	20 84 fb	jsr $fb84				JSR	PUTCHAR
.f906	e8		inx					INX
.f907	8e 02 05	stx $0502				STX	CB_WRPTR
.f90a	80 b1		bra $f8bd				BRA	GLLP1
.f90c					GLXIT1
.f90c	74 00		stz $00,x				STZ	0,X				; null-terminate the line
.f90e	60		rts					RTS
.f90f					TOPUPPER
.f90f	c9 61		cmp #$61				CMP	#'a'				; Make character PupperCase
.f911	90 06		bcc $f919				BCC	PUPX1				; A < 'a' so can't be lowercase char
.f913	c9 7b		cmp #$7b				CMP	#'z'+1
.f915	b0 02		bcs $f919				BCS	PUPX1				; A > 'z', so can't be lowercase char
.f917	e9 1f		sbc #$1f				SBC	#'a'-'A'-1			; Adjust upper case to lower case
.f919					PUPX1
.f919	60		rts					RTS
=$01					FIFO_TXE = PB0
=$02					FIFO_RXF = PB1
=$04					FIFO_WR = PB2
=$08					FIFO_RD = PB3
=$20					FIFO_PWREN = PB5
=$80					FIFO_DEBUG = PB7		; Handy debug toggle output free for any use
.f91a					PUT_FIFO
.f91a	20 72 f9	jsr $f972				JSR	PUT_FRAW
.f91d	b0 fb		bcs $f91a				BCS	PUT_FIFO
.f91f	60		rts					RTS
.f920	20 9c f9	jsr $f99c	GET_FIFO	JSR GET_FRAW
.f923	b0 fb		bcs $f920				BCS	GET_FIFO
.f925	60		rts					RTS
.f926					SEL_BANK3
.f926	a9 ff		lda #$ff				LDA	#%11111111
.f928	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f92b	60		rts					RTS
.f92c					SEL_BANK2
.f92c	a9 fd		lda #$fd				LDA	#%11111101
.f92e	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f931	60		rts					RTS
.f932					SEL_BANK1
.f932	a9 df		lda #$df				LDA	#%11011111
.f934	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f937	60		rts					RTS
.f938					SEL_BANK0
.f938	a9 dd		lda #$dd				LDA	#%11011101
.f93a	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f93d	60		rts					RTS
.f93e					INIT_SYSVIA
.f93e	a9 ff		lda #$ff				LDA	#%11111111
.f940	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f943	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA
.f946	9c e2 7f	stz $7fe2				STZ	SYSTEM_VIA_DDRB
.f949	60		rts					RTS
.f94a					INIT_FIFO
.f94a	a9 ff		lda #$ff				LDA	#$FF
.f94c	8d ec 7f	sta $7fec				STA SYSTEM_VIA_PCR			; CB2=FAMS=flash A16=1;  CA2=FA15=A15=1; Select flash Bank #3
.f94f	9c eb 7f	stz $7feb				STZ SYSTEM_VIA_ACR			; Disable PB7, shift register, timer T1 interrupt.  Not absolutely required while interrupts are disabled FIXME: set up timer
.f952	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Set PA0-PA7 to all inputs
.f955	9c e2 7f	stz $7fe2				STZ	SYSTEM_VIA_DDRB			; In case we're not coming off a reset, make PORT B an input and change output register when it's NOT outputting
.f958	a9 08		lda #$08				LDA	#FIFO_RD				;
.f95a	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Avoid possible glitch by writing to output latch while Port B is still an input (after reset)
.f95d	a9 8c		lda #$8c				LDA	#(FIFO_RD + FIFO_WR + FIFO_DEBUG)	; Make FIFO RD & WR pins outputs so we can strobe data in and out of the FIFO
.f95f	8d e2 7f	sta $7fe2				STA	SYSTEM_VIA_DDRB			; Port B: PB2 and PB3 are outputs; rest are inputs from earlier IORB write
.f962	20 bd f9	jsr $f9bd				JSR	TXCHDLY
.f965	20 bd f9	jsr $f9bd				JSR	TXCHDLY
.f968	20 bd f9	jsr $f9bd				JSR	TXCHDLY
.f96b	20 bd f9	jsr $f9bd				JSR	TXCHDLY
.f96e	20 bd f9	jsr $f9bd				JSR	TXCHDLY
.f971	60		rts					RTS					; FUBAR - don't wait on the FIFO which stupidly may not even have power if not USB powered
.f972					PUT_FRAW
.f972	85 ef		sta $ef					STA	TEMP2
.f974	ad e0 7f	lda $7fe0				LDA	SYSTEM_VIA_IORB			; Read in FIFO status Port for FIFO
.f977	29 01		and #$01				AND	#FIFO_TXE				; If TXE is low, we can accept data into FIFO.  If high, return immmediately
.f979	38		sec					SEC							; FIFO is full, so don't try to queue it!
.f97a	d0 1d		bne $f999				BNE	OFX1					; 0 = OK to write to FIFO; 1 = Wait, FIFO full!
.f97c					OFCONT
.f97c	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; (Defensive) Start with Port A input/floating
.f97f	a9 0c		lda #$0c				LDA	#(FIFO_RD + FIFO_WR)	; RD=1 WR=1 (WR must go 1->0 for FIFO write)
.f981	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Make sure write is high (and read too!)
.f984	a5 ef		lda $ef					LDA TEMP2							; Restore the data to send
.f986	8d e1 7f	sta $7fe1				STA	SYSTEM_VIA_IORA			; Set up output value in advance in Port A (still input so doesn't go out yet)
.f989	a9 ff		lda #$ff				LDA	#$FF				; make Port A all outputs with stable output value already set in prior lines
.f98b	8d e3 7f	sta $7fe3				STA	SYSTEM_VIA_DDRA			; Save data to output latches
.f98e	ea		nop					NOP					; Some settling time of data output just to be safe
.f98f	a9 08		lda #$08				LDA	#(FIFO_RD)			; RD=1 WR=0 (WR1->0 transition triggers FIFO transfer!)
.f991	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Low-going WR pulse should latch data
.f994	ea		nop					NOP							; Hold time following write strobe, to ensure value is latched OK
.f995	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Make port A an input again
.f998	18		clc					CLC					; signal success of write to caller
.f999					OFX1
.f999	a5 ef		lda $ef					LDA	TEMP2
.f99b	60		rts					RTS
.f99c					GET_FRAW
.f99c	ad e0 7f	lda $7fe0				LDA	SYSTEM_VIA_IORB			; Check RXF flag
.f99f	29 02		and #$02				AND	#FIFO_RXF			; If clear, we're OK to read.  If set, there's no data waiting
.f9a1	38		sec					SEC
.f9a2	d0 18		bne $f9bc				BNE 	INFXIT				; If RXF is 1, then no character is waiting!
.f9a4	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Make Port A inputs
.f9a7	a9 08		lda #$08				LDA	#FIFO_RD
.f9a9	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; RD=1 WR=0 (RD must go to 0 to read
.f9ac	ea		nop					NOP
.f9ad	9c e0 7f	stz $7fe0				STZ	SYSTEM_VIA_IORB			; RD=0 WR=0	- FIFO presents data to port A
.f9b0	ea		nop					NOP
.f9b1	ad e1 7f	lda $7fe1				LDA	SYSTEM_VIA_IORA			; read data in
.f9b4	48		pha					PHA
.f9b5	a9 08		lda #$08				LDA	#FIFO_RD			; Restore back to inactive signals RD=1 and WR=0
.f9b7	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB
.f9ba	68		pla					PLA
.f9bb	18		clc					CLC					; we got a byte!
.f9bc					INFXIT
.f9bc	60		rts					RTS
=$0940					TX_DLY_CYCLES = $0940						; Not tuned.  As it's temporary, optimum settings are unimportant.
.f9bd					TXCHDLY
.f9bd	5a		phy					PHY
.f9be	a0 40 09	ldy #$0940				LDY	#TX_DLY_CYCLES		; FIXME: Very bad work-around until timers are up
.f9c1					DLY_Y
.f9c1	88		dey					DEY
.f9c2	ea		nop					NOP
.f9c3	ea		nop					NOP
.f9c4	ea		nop					NOP
.f9c5	d0 fa		bne $f9c1				BNE	DLY_Y
.f9c7	7a		ply					PLY
.f9c8	60		rts					RTS
.f9c9					CMD_DUMPHEX
.f9c9	20 63 fb	jsr $fb63				JSR	CRLF			; Give some space
.f9cc	20 69 f8	jsr $f869				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.f9cf	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.f9d2	f0 03		beq $f9d7				BEQ	CDH_NOTEOL		; Not EOL, so start dumping data
.f9d4	82 d6 00	brl $faad				BRL	DHEXX2			; We hit an EOL before an actionable character, so quit
.f9d7					CDH_NOTEOL
.f9d7	9c 08 05	stz $0508				STZ	BYTECNT			; First line and every 16 bytes will show current address
.f9da	20 8c f8	jsr $f88c				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.f9dd	20 bf fc	jsr $fcbf				JSR	CONVHEX			; Get starting address in HEXIO
.f9e0	ad 0b 05	lda $050b				LDA	HEXIO_B			; Put starting address in PTR
.f9e3	85 e4		sta $e4					STA	PTR_B
.f9e5	ad 0a 05	lda $050a				LDA	HEXIO_H
.f9e8	85 e3		sta $e3					STA	PTR_H
.f9ea	ad 09 05	lda $0509				LDA	HEXIO_L
.f9ed	85 e2		sta $e2					STA	PTR_L
.f9ef	20 69 f8	jsr $f869				JSR	FINDSTART		;Get next parameter
.f9f2	ad 07 05	lda $0507				LDA	EOLFLAG			; is there one?
.f9f5	f0 0b		beq $fa02				BEQ	DHSAVEA			; save end address if not EOL after start address read
.f9f7	64 e7		stz $e7					STZ	CTR_B
.f9f9	64 e6		stz $e6					STZ	CTR_H
.f9fb	a9 01		lda #$01				LDA	#1
.f9fd	85 e5		sta $e5					STA	CTR_L
.f9ff	82 3b 00	brl $fa3d				BRL	DUMPITNOW
.fa02					DHSAVEA
.fa02	20 8c f8	jsr $f88c				JSR	FINDEND
.fa05	20 bf fc	jsr $fcbf				JSR	CONVHEX			; get 8 to 24 bit end address
.fa08	ad 0b 05	lda $050b				LDA	HEXIO_B
.fa0b	85 ed		sta $ed					STA	EA_B
.fa0d	ad 0a 05	lda $050a				LDA	HEXIO_H
.fa10	85 ec		sta $ec					STA	EA_H
.fa12	ad 09 05	lda $0509				LDA	HEXIO_L
.fa15	85 eb		sta $eb					STA	EA_L
.fa17	38		sec					SEC
.fa18	a5 eb		lda $eb					LDA	EA_L
.fa1a	e5 e2		sbc $e2					SBC	PTR_L
.fa1c	85 e5		sta $e5					STA	CTR_L
.fa1e	a5 ec		lda $ec					LDA	EA_H
.fa20	e5 e3		sbc $e3					SBC	PTR_H
.fa22	85 e6		sta $e6					STA	CTR_H
.fa24	a5 ed		lda $ed					LDA	EA_B
.fa26	e5 e4		sbc $e4					SBC	PTR_B			; Just to be thorough, should we support > 64K dump someday
.fa28	85 e7		sta $e7					STA	CTR_B
.fa2a	18		clc					CLC				; Probably can make this more efficient
.fa2b	a5 e5		lda $e5					LDA	CTR_L			; Calculate byte count of dump in CTR
.fa2d	69 01		adc #$01				ADC	#1
.fa2f	85 e5		sta $e5					STA	CTR_L
.fa31	a5 e6		lda $e6					LDA	CTR_H
.fa33	69 00		adc #$00				ADC	#0
.fa35	85 e6		sta $e6					STA	CTR_H
.fa37	a5 e7		lda $e7					LDA	CTR_B
.fa39	69 00		adc #$00				ADC	#0
.fa3b	85 e7		sta $e7					STA	CTR_B
.fa3d					DUMPITNOW
.fa3d	a5 e5		lda $e5					LDA	CTR_L			; Check for done
.fa3f	05 e6		ora $e6					ORA	CTR_H
.fa41	05 e7		ora $e7					ORA	CTR_B
.fa43	f0 68		beq $faad				BEQ 	DHEXX1			; We're done
.fa45	ad 08 05	lda $0508				LDA	BYTECNT
.fa48	d0 24		bne $fa6e				BNE	DUMPITN1		;
.fa4a					DHEXC6
.fa4a	20 63 fb	jsr $fb63				JSR	CRLF
.fa4d	a5 e4		lda $e4					LDA	PTR_B
.fa4f	8d 0b 05	sta $050b				STA	HEXIO_B
.fa52	a5 e3		lda $e3					LDA	PTR_H
.fa54	8d 0a 05	sta $050a				STA	HEXIO_H
.fa57	a5 e2		lda $e2					LDA	PTR_L
.fa59	8d 09 05	sta $0509				STA	HEXIO_L
.fa5c	20 39 fd	jsr $fd39				JSR	PUTHEX24		; Print the address
.fa5f	a9 3a		lda #$3a				LDA	#':'
.fa61	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fa64	a9 20		lda #$20				LDA	#SP
.fa66	20 84 fb	jsr $fb84				JSR	PUTCHAR			;
.fa69	a9 20		lda #$20				LDA	#SP
.fa6b	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fa6e					DUMPITN1
.fa6e	a7 e2		lda [$e2]				LDA	[PTR]			; Dump CTR bytes starting at [PTR]
.fa70	20 51 fd	jsr $fd51				JSR	PUTHEXA
.fa73	a9 20		lda #$20				LDA	#' '
.fa75	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fa78	18		clc					CLC
.fa79	a5 e2		lda $e2					LDA	PTR_L
.fa7b	69 01		adc #$01				ADC	#1
.fa7d	85 e2		sta $e2					STA	PTR_L
.fa7f	a5 e3		lda $e3					LDA	PTR_H
.fa81	69 00		adc #$00				ADC	#0
.fa83	85 e3		sta $e3					STA	PTR_H
.fa85	a5 e4		lda $e4					LDA	PTR_B
.fa87	69 00		adc #$00				ADC	#0
.fa89	85 e4		sta $e4					STA	PTR_B
.fa8b					DHEXC3
.fa8b	38		sec					SEC
.fa8c	a5 e5		lda $e5					LDA	CTR_L			; one less byte to print out
.fa8e	e9 01		sbc #$01				SBC	#1
.fa90	85 e5		sta $e5					STA	CTR_L
.fa92	a5 e6		lda $e6					LDA	CTR_H
.fa94	e9 00		sbc #$00				SBC	#0
.fa96	85 e6		sta $e6					STA	CTR_H
.fa98	a5 e7		lda $e7					LDA	CTR_B
.fa9a	e9 00		sbc #$00				SBC	#0
.fa9c	85 e7		sta $e7					STA	CTR_B
.fa9e	ee 08 05	inc $0508				INC 	BYTECNT
.faa1	ad 08 05	lda $0508				LDA	BYTECNT
.faa4	c9 10		cmp #$10				CMP	#16
.faa6	d0 95		bne $fa3d				BNE	DUMPITNOW
.faa8	9c 08 05	stz $0508				STZ	BYTECNT
.faab	80 90		bra $fa3d				BRA	DUMPITNOW		; Print the address at start of new line
.faad					DHEXX1
.faad					DHEXX2
.faad	60		rts					RTS
.faae					CMD_WRITEBYTES
.faae	20 63 fb	jsr $fb63				JSR	CRLF			; Give some space
.fab1	20 69 f8	jsr $f869				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.fab4	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.fab7	d0 5e		bne $fb17				BNE	CWBXX2			; We hit an EOL before an actionable character, so quit
.fab9	20 8c f8	jsr $f88c				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.fabc	20 bf fc	jsr $fcbf				JSR	CONVHEX			; Get starting address in HEXIO
.fabf	ad 0b 05	lda $050b				LDA	HEXIO_B			; Transfer starting address from HEXIO to PTR
.fac2	85 e4		sta $e4					STA	PTR_B
.fac4	ad 0a 05	lda $050a				LDA	HEXIO_H
.fac7	85 e3		sta $e3					STA	PTR_H
.fac9	ad 09 05	lda $0509				LDA	HEXIO_L
.facc	85 e2		sta $e2					STA	PTR_L
.face					CWLOOP1
.face	20 69 f8	jsr $f869				JSR	FINDSTART		; Get next byte
.fad1	ad 07 05	lda $0507				LDA	EOLFLAG
.fad4	d0 41		bne $fb17				BNE	CWBXX2
.fad6	20 8c f8	jsr $f88c				JSR	FINDEND			; Find end of Parameter
.fad9	20 98 fc	jsr $fc98				JSR	RDHEX8
.fadc	87 e2		sta [$e2]				STA	[PTR]			; Attempt to store.  If ROM, output will show failure to write
.fade	a5 e4		lda $e4					LDA	PTR_B
.fae0	8d 0b 05	sta $050b				STA	HEXIO_B
.fae3	a5 e3		lda $e3					LDA	PTR_H
.fae5	8d 0a 05	sta $050a				STA	HEXIO_H
.fae8	a5 e2		lda $e2					LDA	PTR_L
.faea	8d 09 05	sta $0509				STA	HEXIO_L
.faed	20 39 fd	jsr $fd39				JSR	PUTHEX24
.faf0	a9 3c		lda #$3c				LDA	#'<'
.faf2	20 84 fb	jsr $fb84				JSR	PUTCHAR
.faf5	a9 2d		lda #$2d				LDA	#'-'
.faf7	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fafa	a7 e2		lda [$e2]				LDA	[PTR]			; Read the actual byte (if ROM, won't match input)
.fafc	20 51 fd	jsr $fd51				JSR	PUTHEXA
.faff	20 63 fb	jsr $fb63				JSR	CRLF
.fb02	18		clc					CLC
.fb03	a5 e2		lda $e2					LDA	PTR_L
.fb05	69 01		adc #$01				ADC	#1
.fb07	85 e2		sta $e2					STA	PTR_L
.fb09	a5 e3		lda $e3					LDA	PTR_H
.fb0b	69 00		adc #$00				ADC	#0
.fb0d	85 e3		sta $e3					STA	PTR_H
.fb0f	a5 e4		lda $e4					LDA	PTR_B
.fb11	69 00		adc #$00				ADC	#0
.fb13	85 e4		sta $e4					STA	PTR_B
.fb15	80 b7		bra $face				BRA	CWLOOP1
.fb17					CWBXX2
.fb17	60		rts					RTS
.fb18					CMD_LOAD
.fb18	a0 49 f2	ldy #$f249				LDY	#MSG_LOAD
.fb1b	20 88 fb	jsr $fb88				JSR	PUT_STR
.fb1e	20 b2 fb	jsr $fbb2				JSR	SREC_LOADER
.fb21	60		rts					RTS
.fb22					CMD_GO
.fb22	20 63 fb	jsr $fb63				JSR	CRLF			; Give some space
.fb25	20 69 f8	jsr $f869				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.fb28	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.fb2b	d0 24		bne $fb51				BNE	CGXIT1			; We hit an EOL before an actionable character, so quit
.fb2d	20 8c f8	jsr $f88c				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.fb30	20 bf fc	jsr $fcbf				JSR	CONVHEX			; Get starting address in HEXIO
.fb33	ad 0b 05	lda $050b				LDA	HEXIO_B			; Transfer starting address from HEXIO to PTR
.fb36	85 e4		sta $e4					STA	PTR_B
.fb38	ad 0a 05	lda $050a				LDA	HEXIO_H
.fb3b	85 e3		sta $e3					STA	PTR_H
.fb3d	ad 09 05	lda $0509				LDA	HEXIO_L
.fb40	85 e2		sta $e2					STA	PTR_L
.fb42	a0 6b f2	ldy #$f26b				LDY	#MSG_JUMP
.fb45	20 88 fb	jsr $fb88				JSR	PUT_STR
.fb48	20 39 fd	jsr $fd39				JSR	PUTHEX24
.fb4b	20 63 fb	jsr $fb63				JSR	CRLF			; get rid of return address since we're not returing!
.fb4e	dc e2 00	jmp [$00e2]				JML	[PTR]			; There's really no exit
.fb51					CGXIT1
.fb51	60		rts					RTS						; Might return if no valid jump address
.fb52					LOLWUT
.fb52	20 63 fb	jsr $fb63				JSR	CRLF
.fb55	a0 00 04	ldy #$0400				LDY	#CMDBUF
.fb58	20 94 fb	jsr $fb94				JSR	PUT_STR_CTRL		; Display buffer contents not understood; show non-printing too!
.fb5b	20 63 fb	jsr $fb63				JSR	CRLF
.fb5e	a9 3f		lda #$3f				LDA	#'?'
.fb60	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fb63					CRLF
.fb63	a9 0a		lda #$0a				LDA	#LF
.fb65	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fb68					JUSTCR
.fb68	a9 0d		lda #$0d				LDA	#CR
.fb6a	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fb6d	60		rts					RTS
.fb6e					CMD_A
.fb6e					CMD_B
.fb6e					CMD_C
.fb6e					CMD_D
.fb6e					CMD_E
.fb6e					CMD_F
.fb6e					CMD_H
.fb6e					CMD_I
.fb6e					CMD_J
.fb6e					CMD_K
.fb6e					CMD_M
.fb6e					CMD_N
.fb6e					CMD_O
.fb6e					CMD_P
.fb6e					CMD_Q
.fb6e					CMD_R
.fb6e					CMD_S
.fb6e					CMD_T
.fb6e					CMD_U
.fb6e					CMD_V
.fb6e					CMD_X
.fb6e					CMD_Y
.fb6e					CMD_Z
.fb6e	a0 00 f0	ldy #$f000				LDY	#MSG_UNIMPLEMENTED
.fb71	20 88 fb	jsr $fb88				JSR	PUT_STR
.fb74	60		rts					RTS
.fb75					PUTCHARTR
.fb75	c9 20		cmp #$20				CMP	#$20
.fb77	b0 0b		bcs $fb84				BCS	PUTCHAR
.fb79	48		pha					PHA					; Display as hex value
.fb7a	a9 5c		lda #$5c				LDA	#'\'
.fb7c	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fb7f	68		pla					PLA
.fb80	20 51 fd	jsr $fd51				JSR	PUTHEXA
.fb83					PUTCRX1
.fb83	60		rts					RTS
.fb84					PUTCHAR
.fb84	20 1a f9	jsr $f91a				JSR	PUT_FIFO
.fb87	60		rts					RTS
.fb88					PUT_STR
.fb88	b9 00 00	lda $0000,y				LDA	0,Y				; Y points directly to string
.fb8b	f0 06		beq $fb93				BEQ	PUTSX
.fb8d	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fb90	c8		iny					INY					; point to next character
.fb91	80 f5		bra $fb88				BRA	PUT_STR
.fb93					PUTSX
.fb93	60		rts					RTS
.fb94					PUT_STR_CTRL
.fb94	b9 00 00	lda $0000,y				LDA	0,Y				; Y points directly to string
.fb97	f0 06		beq $fb9f				BEQ	PUTSRX
.fb99	20 75 fb	jsr $fb75				JSR	PUTCHARTR			; Show control characters, etc.
.fb9c	c8		iny					INY					; point to next character
.fb9d	80 f5		bra $fb94				BRA	PUT_STR_CTRL
.fb9f					PUTSRX
.fb9f	60		rts					RTS
.fba0					GET_RAW
.fba0	82 7d fd	brl $f920				BRL	GET_FIFO
.fba3					GETCHAR
.fba3	a5 43		lda $43					LDA	TERMFLAGS		; relying on W265 SBC char in buffer (temporarily)
.fba5	29 df		and #$df				AND	#%11011111		; Turn off ECHO
.fba7	09 10		ora #$10				ORA	#%00010000		; Turn off hardware handshaking to 265 (not run)
.fba9	85 43		sta $43					STA 	TERMFLAGS
.fbab	20 a0 fb	jsr $fba0				JSR	GET_RAW
.fbae	20 0f f9	jsr $f90f				JSR	TOPUPPER		; Make alphabetics Puppercase
.fbb1	60		rts					RTS
.fbb2					SREC_LOADER
.fbb2					SYNC
.fbb2	20 a3 fb	jsr $fba3				JSR	GETCHAR			; Wait for "S" to start a new record
.fbb5	c9 53		cmp #$53				CMP	#'S'
.fbb7	d0 f9		bne $fbb2				BNE	SYNC
.fbb9	a9 40		lda #$40				LDA	#'@'
.fbbb	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fbbe	20 a3 fb	jsr $fba3				JSR	GETCHAR
.fbc1	85 e0		sta $e0					STA	REC_TYPE
.fbc3	20 04 fd	jsr $fd04				JSR	GETHEX			; Get message length byte
.fbc6	85 ee		sta $ee					STA	DATA_CNT		; Save number of bytes in record
.fbc8	a5 e0		lda $e0					LDA	REC_TYPE		; Decode and dispatch
.fbca	f0 23		beq $fbef				BEQ	GETREMS			; read the comment block
.fbcc	c9 31		cmp #$31				CMP	#'1'
.fbce	f0 3e		beq $fc0e				BEQ	GET16ADDR
.fbd0	c9 32		cmp #$32				CMP	#'2'
.fbd2	f0 27		beq $fbfb				BEQ	GET24ADDR
.fbd4	c9 35		cmp #$35				CMP	#'5'
.fbd6	d0 02		bne $fbda				BNE	SLC4
.fbd8	80 64		bra $fc3e				BRA	CNT16
.fbda					SLC4
.fbda	c9 36		cmp #$36				CMP	#'6'
.fbdc	d0 02		bne $fbe0				BNE	SLC2
.fbde	80 67		bra $fc47				BRA	CNT24
.fbe0					SLC2
.fbe0	c9 38		cmp #$38				CMP	#'8'
.fbe2	d0 03		bne $fbe7				BNE	SLC1
.fbe4	82 85 00	brl $fc6c				BRL	SA24			; Too far for relative branch
.fbe7					SLC1
.fbe7	c9 39		cmp #$39				CMP	#'9'
.fbe9	d0 02		bne $fbed				BNE	SLC3
.fbeb	80 76		bra $fc63				BRA	SA16
.fbed					SLC3
.fbed	80 c3		bra $fbb2				BRA	SYNC
.fbef					GETREMS
.fbef	a9 30		lda #$30				LDA	#'0'
.fbf1	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fbf4	a9 23		lda #$23				LDA	#'#'
.fbf6	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fbf9	80 b7		bra $fbb2				BRA	SYNC
.fbfb					GET24ADDR
.fbfb	a9 32		lda #$32				LDA	#'2'
.fbfd	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fc00	a5 ee		lda $ee					LDA	DATA_CNT
.fc02	38		sec					SEC
.fc03	e9 04		sbc #$04				SBC	#4			; Data length -= 3 bytes address + 1 byte checksum
.fc05	85 ee		sta $ee					STA	DATA_CNT		; Adjust data count to include only payload data bytes
.fc07	20 04 fd	jsr $fd04				JSR	GETHEX
.fc0a	85 e4		sta $e4					STA	PTR_B
.fc0c	80 0e		bra $fc1c				BRA	GET1624
.fc0e					GET16ADDR
.fc0e	a9 31		lda #$31				LDA	#'1'
.fc10	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fc13	a5 ee		lda $ee					LDA	DATA_CNT
.fc15	38		sec					SEC
.fc16	e9 03		sbc #$03				SBC	#3			; Data length -= 2 bytes address + 1 byte checksum
.fc18	85 ee		sta $ee					STA	DATA_CNT		; Adjust data count to include only payload data bytes
.fc1a	64 e4		stz $e4					STZ	PTR_B			; 16 bit records.  Default Bank to 0!  (0+! NOT 0!=1)
.fc1c					GET1624
.fc1c	20 04 fd	jsr $fd04				JSR	GETHEX			; Got bank value (or set to 0). Now get high and low address
.fc1f	85 e3		sta $e3					STA	PTR_H
.fc21	20 04 fd	jsr $fd04				JSR	GETHEX
.fc24	85 e2		sta $e2					STA	PTR_L
.fc26					SAVDAT:
.fc26	a5 ee		lda $ee					LDA	DATA_CNT		; A record can have 0 data bytes, theoretically. So check at top
.fc28	f0 0c		beq $fc36				BEQ	SAVDX1			; No more data to PARSELINE
.fc2a					SAVDAT2
.fc2a	20 04 fd	jsr $fd04				JSR	GETHEX
.fc2d	87 e2		sta [$e2]				STA	[PTR]			; 24 bit indirect save
.fc2f	20 8d fc	jsr $fc8d				JSR	INC_PTR			; Point to next byte
.fc32	c6 ee		dec $ee					DEC	DATA_CNT
.fc34	d0 f4		bne $fc2a				BNE	SAVDAT2
.fc36					SAVDX1
.fc36	a9 23		lda #$23				LDA	#'#'
.fc38	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fc3b	82 74 ff	brl $fbb2				BRL	SYNC			; FIXME: parse the checksum and end of line
.fc3e					CNT16
.fc3e	a9 35		lda #$35				LDA	#'5'
.fc40	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fc43	64 e7		stz $e7					STZ	CTR_B
.fc45	80 0a		bra $fc51				BRA	CN16C1
.fc47					CNT24:
.fc47	a9 36		lda #$36				LDA	#'6'
.fc49	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fc4c	20 04 fd	jsr $fd04				JSR	GETHEX
.fc4f	85 e7		sta $e7					STA	CTR_B
.fc51					CN16C1
.fc51	20 04 fd	jsr $fd04				JSR	GETHEX			; bits 15-8
.fc54	85 e6		sta $e6					STA	CTR_H
.fc56	20 04 fd	jsr $fd04				JSR	GETHEX			; bits 7-0
.fc59	85 e5		sta $e5					STA	CTR_L
.fc5b	a9 23		lda #$23				LDA	#'#'
.fc5d	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fc60	82 4f ff	brl $fbb2				BRL	SYNC			; FIXME: parse the rest of the record & end of line
.fc63					SA16
.fc63	a9 39		lda #$39				LDA	#'9'
.fc65	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fc68	64 ea		stz $ea					STZ	SA_B
.fc6a	80 0a		bra $fc76				BRA	SA16C1
.fc6c					SA24
.fc6c	a9 38		lda #$38				LDA	#'8'
.fc6e	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fc71	20 04 fd	jsr $fd04				JSR	GETHEX			; length byte
.fc74	64 ea		stz $ea					STZ	SA_B
.fc76					SA16C1
.fc76	20 04 fd	jsr $fd04				JSR	GETHEX			; bits 15-8
.fc79	85 e9		sta $e9					STA	SA_H
.fc7b	20 04 fd	jsr $fd04				JSR	GETHEX			; bits 7-0
.fc7e	85 e8		sta $e8					STA	SA_L
.fc80	a9 26		lda #$26				LDA	#'&'
.fc82	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fc85					GOEOL
.fc85	20 a3 fb	jsr $fba3				JSR	GETCHAR
.fc88	c9 0d		cmp #$0d				CMP	#CR
.fc8a	d0 f9		bne $fc85				BNE	GOEOL
.fc8c	60		rts					RTS
.fc8d					INC_PTR
.fc8d	e6 e2		inc $e2					INC	PTR_L			; point to the next byte to save to
.fc8f	d0 06		bne $fc97				BNE	INCPX1
.fc91	e6 e3		inc $e3					INC	PTR_H
.fc93	d0 02		bne $fc97				BNE	INCPX1
.fc95	e6 e4		inc $e4					INC	PTR_B
.fc97					INCPX1
.fc97	60		rts					RTS
.fc98					RDHEX8
.fc98	5a		phy					PHY
.fc99	ac 04 05	ldy $0504				LDY	PRM_SA			; Start at beginning of current parameter
.fc9c					RDHX8L1
.fc9c	b9 00 00	lda $0000,y				LDA	0,Y			; Get MSB from *(parameter)
.fc9f	c8		iny					INY				; advance to (hopefully) ASCII LSB
.fca0	c9 3a		cmp #$3a				CMP	#':'			; Kludgey special handling for ':'
.fca2	f0 f8		beq $fc9c				BEQ	RDHX8L1
.fca4					RDHX8C1
.fca4	20 68 fd	jsr $fd68				JSR	MKNIBL
.fca7	0a		asl a					ASL	A			; Note: MKNIBL ANDs off higher 4 bits, so no '1' sign extension can occur
.fca8	0a		asl a					ASL	A
.fca9	0a		asl a					ASL	A
.fcaa	0a		asl a					ASL	A			; shift left 4 because upper nibble
.fcab	85 f1		sta $f1					STA	HEXASSY			; temporary storage.  Only used within this function. Can re-use in any foreground context.
.fcad					RDHX8L2
.fcad	b9 00 00	lda $0000,y				LDA	0,Y			; Get LSB *(parameter+1)
.fcb0	c8		iny					INY				; point to next ASCII hex byte (if any)
.fcb1	c9 3a		cmp #$3a				CMP	#':'
.fcb3	f0 f8		beq $fcad				BEQ	RDHX8L2			; Anti-metamucel (ignore colons) Note pathological buffer with all ':' is possible.  We will tolerate.
.fcb5	8c 04 05	sty $0504				STY	PRM_SA			;	"
.fcb8	20 68 fd	jsr $fd68				JSR	MKNIBL
.fcbb	05 f1		ora $f1					ORA	HEXASSY			; Assemble the parts
.fcbd	7a		ply					PLY
.fcbe	60		rts					RTS				; return the byte in A
.fcbf					CONVHEX
.fcbf	9c 0b 05	stz $050b				STZ	HEXIO_B			; Only write bytes explicitly set in buffer parameter string, else 0
.fcc2	9c 0a 05	stz $050a				STZ	HEXIO_H
.fcc5	9c 09 05	stz $0509				STZ	HEXIO_L
.fcc8	ad 06 05	lda $0506				LDA	PRM_SIZ			; 24 bit cases are "00:1234" or "001234", 16 bit is "1234", 8 bit is "2A"
.fccb	c9 02		cmp #$02				CMP	#2			; See if not even 8 bits (must be two digits to qualify as a hex value by fiat)
.fccd	90 34		bcc $fd03				BCC	CVHKWIT			; Too short to be a valid hex parameter.  Must be 2 or more characters
.fccf	c9 03		cmp #$03				CMP	#3
.fcd1	b0 08		bcs $fcdb				BCS	CHXCHK16
.fcd3	20 98 fc	jsr $fc98				JSR	RDHEX8
.fcd6	8d 09 05	sta $0509				STA	HEXIO_L
.fcd9	80 28		bra $fd03				BRA	CVHKWIT
.fcdb					CHXCHK16
.fcdb	c9 05		cmp #$05				CMP	#5
.fcdd	b0 0e		bcs $fced				BCS	CHXCHK24
.fcdf	20 98 fc	jsr $fc98				JSR	RDHEX8
.fce2	8d 0a 05	sta $050a				STA	HEXIO_H
.fce5	20 98 fc	jsr $fc98				JSR	RDHEX8
.fce8	8d 09 05	sta $0509				STA	HEXIO_L
.fceb	80 16		bra $fd03				BRA	CVHKWIT
.fced					CHXCHK24
.fced	c9 08		cmp #$08				CMP	#8
.fcef	b0 12		bcs $fd03				BCS	CVHKWIT			; Give up if >= 8 characters!
.fcf1	20 98 fc	jsr $fc98				JSR	RDHEX8
.fcf4	8d 0b 05	sta $050b				STA	HEXIO_B
.fcf7	20 98 fc	jsr $fc98				JSR	RDHEX8
.fcfa	8d 0a 05	sta $050a				STA	HEXIO_H
.fcfd	20 98 fc	jsr $fc98				JSR	RDHEX8
.fd00	8d 09 05	sta $0509				STA	HEXIO_L
.fd03					CVHKWIT
.fd03	60		rts					RTS
.fd04					GETHEX
.fd04	20 a3 fb	jsr $fba3				JSR 	GETCHAR
.fd07	c9 03		cmp #$03				CMP	#CTRL_C
.fd09	d0 0b		bne $fd16				BNE	GHECC1
.fd0b	a9 5e		lda #$5e				LDA	#'^'
.fd0d	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fd10	a9 43		lda #$43				LDA	#'C'
.fd12	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fd15	60		rts		       		RTS				; bail
.fd16					GHECC1
.fd16	20 68 fd	jsr $fd68				JSR     MKNIBL  		; Convert to 0..F numeric
.fd19	0a		asl a					ASL     A
.fd1a	0a		asl a					ASL     A
.fd1b	0a		asl a					ASL     A
.fd1c	0a		asl a					ASL     A       		; This is the upper nibble
.fd1d	29 f0		and #$f0				AND     #$F0
.fd1f	85 f0		sta $f0					STA     SUBTEMP
.fd21	20 a3 fb	jsr $fba3				JSR     GETCHAR
.fd24	c9 03		cmp #$03				CMP	#CTRL_C
.fd26	d0 0b		bne $fd33				BNE	GHECC2
.fd28	a9 5e		lda #$5e				LDA	#'^'
.fd2a	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fd2d	a9 43		lda #$43				LDA	#'C'
.fd2f	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fd32	60		rts					RTS				; bail
.fd33					GHECC2
.fd33	20 68 fd	jsr $fd68				JSR     MKNIBL
.fd36	05 f0		ora $f0		        		ORA    	SUBTEMP
.fd38	60		rts		        		RTS
.fd39					PUTHEX24:
.fd39	ad 0b 05	lda $050b				LDA	HEXIO_B
.fd3c	20 51 fd	jsr $fd51				JSR	PUTHEXA
.fd3f	a9 3a		lda #$3a				LDA	#':'
.fd41	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fd44					PUTHEX16:
.fd44	ad 0a 05	lda $050a				LDA	HEXIO_H
.fd47	20 51 fd	jsr $fd51				JSR	PUTHEXA
.fd4a					PUTHEX8:
.fd4a	ad 09 05	lda $0509				LDA	HEXIO_L
.fd4d	20 51 fd	jsr $fd51				JSR	PUTHEXA
.fd50	60		rts					RTS
.fd51					PUTHEXA
.fd51	48		pha					PHA             	;
.fd52	4a		lsr a		        		LSR 	A
.fd53	4a		lsr a		        		LSR 	A
.fd54	4a		lsr a					LSR 	A
.fd55	4a		lsr a					LSR 	A
.fd56	20 5a fd	jsr $fd5a	        		JSR     PRNIBL
.fd59	68		pla		        		PLA
.fd5a					PRNIBL
.fd5a	29 0f		and #$0f				AND     #$0F    	; strip off the low nibble
.fd5c	c9 0a		cmp #$0a	       		 	CMP     #$0A
.fd5e	90 02		bcc $fd62	       		 	BCC  	NOTHEX  	; if it's 0-9, add '0' else also add 7
.fd60	69 06		adc #$06	       		 	ADC     #6      	; Add 7 (6+carry=1), result will be carry clear
.fd62					NOTHEX
.fd62	69 30		adc #$30				ADC     #'0'    	; If carry clear, we're 0-9
.fd64					PUTCH
.fd64	20 84 fb	jsr $fb84				JSR	PUTCHAR
.fd67	60		rts					RTS
.fd68					MKNIBL
.fd68	c9 3a		cmp #$3a				CMP     #'9'+1  	; See if it's 0-9 or 'A'..'F' (no lowercase yet)
.fd6a	90 02		bcc $fd6e	 		    BCC     MKNNH   	; If we borrowed, we lost the carry so 0..9
.fd6c	e9 08		sbc #$08	        		SBC     #7+1    	; Subtract off extra 7 (sbc subtracts off one less)
.fd6e					MKNNH
.fd6e	e9 2f		sbc #$2f				SBC     #'0'-1  	; subtract off '0' (if carry clear coming in)
.fd70	29 0f		and #$0f	        		AND     #$0F    	; no upper nibble no matter what
.fd72	60		rts		        		RTS             	; and return the nibble
=$1e					SCTL_V  = %00011110       ; 9600 baud, 8 bits, 1 stop bit, rxclock = txclock
=$0b					SCMD_V  = %00001011       ; No parity, no echo, no tx or rx IRQ (for now), DTR*
.fd73					INIT_SER
.fd73	a9 1e		lda #$1e				LDA     #SCTL_V 	; 9600,n,8,1.  rxclock = txclock
.fd75	8d 83 7f	sta $7f83				STA 	SCTL
.fd78	a9 0b		lda #$0b				LDA     #SCMD_V 	; No parity, no echo, no tx or rx IRQ (for now), DTR*
.fd7a	8d 82 7f	sta $7f82				STA     SCMD
.fd7d	60		rts					RTS
.fd7e					GETSER
.fd7e	ad 81 7f	lda $7f81				LDA	SSR
.fd81	29 08		and #$08				AND	#RX_RDY
.fd83	f0 f9		beq $fd7e				BEQ	GETSER
.fd85	ad 80 7f	lda $7f80				LDA	SDR
.fd88	18		clc					CLC			; Temporary compatibility return value for blocking/non-blocking
.fd89	60		rts					RTS
.fd8a					PUTSER
.fd8a	48		pha					PHA
.fd8b	8d 80 7f	sta $7f80				STA	SDR
.fd8e	20 bd f9	jsr $f9bd				JSR	TXCHDLY		; Awful kludge
.fd91	68		pla					PLA
.fd92	18		clc					CLC			; Temporary compatibility return value for integration for blocking/non-blocking
.fd93	60		rts					RTS
.fd94					MONTBL
>fd94	6e fb							.word 	CMD_A		; Index 0 = "A"
>fd96	6e fb							.word	CMD_B
>fd98	6e fb							.word	CMD_C
>fd9a	6e fb							.word	CMD_D
>fd9c	6e fb							.word	CMD_E
>fd9e	6e fb							.word	CMD_F
>fda0	22 fb							.word	CMD_GO
>fda2	6e fb							.word	CMD_H
>fda4	6e fb							.word	CMD_I
>fda6	22 fb							.word	CMD_GO
>fda8	6e fb							.word	CMD_K
>fdaa	18 fb							.word	CMD_LOAD
>fdac	6e fb							.word	CMD_M
>fdae	6e fb							.word	CMD_N
>fdb0	6e fb							.word	CMD_O
>fdb2	6e fb							.word	CMD_P
>fdb4	6e fb							.word	CMD_Q
>fdb6	c9 f9							.word	CMD_DUMPHEX
>fdb8	6e fb							.word	CMD_S
>fdba	6e fb							.word	CMD_T
>fdbc	6e fb							.word	CMD_U
>fdbe	6e fb							.word	CMD_V
>fdc0	ae fa							.word	CMD_WRITEBYTES
>fdc2	6e fb							.word	CMD_X
>fdc4	6e fb							.word	CMD_Y
>fdc6	6e fb							.word	CMD_Z
.f000					MSG_UNIMPLEMENTED
>f000	0d 55 6e 69 6d 70 6c 65				.text	CR,"Unimplemented instruction",CR
>f008	6d 65 6e 74 65 64 20 69 6e 73 74 72 75 63 74 69
>f018	6f 6e 0d
>f01b	00						.text	0
.f01c					MSG_6HEX
>f01c	0d 45 6e 74 65 72 20 36				.text	CR,"Enter 6 digit hex address:",0
>f024	20 64 69 67 69 74 20 68 65 78 20 61 64 64 72 65
>f034	73 73 3a 00
.f038					MSG_CONFIRM
>f038	0d 49 73 20 74 68 69 73				.text	CR,"Is this correct (Y/x)?:",0
>f040	20 63 6f 72 72 65 63 74 20 28 59 2f 78 29 3f 3a
>f050	00
.f051					QBFMSG
>f051	0d 0a 0d 0a					.text 		CR,LF,CR,LF
>f055	20 20 20 20 20 20 20 20				.text	"                  VCBmon v 1.00",CR,LF
>f05d	20 20 20 20 20 20 20 20 20 20 56 43 42 6d 6f 6e
>f06d	20 76 20 31 2e 30 30 0d 0a
>f076	20 20 20 20 20 20 20 20				.text 	"          ******************************",CR,LF
>f07e	20 20 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f08e	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f09e	0d 0a
>f0a0	20 20 20 20 20 20 20 20				.text 	"          *                            *",CR,LF
>f0a8	20 20 2a 20 20 20 20 20 20 20 20 20 20 20 20 20
>f0b8	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 2a
>f0c8	0d 0a
>f0ca	20 20 20 20 20 20 20 20				.text 	"          *    The Quick brown Dog     *",CR,LF
>f0d2	20 20 2a 20 20 20 20 54 68 65 20 51 75 69 63 6b
>f0e2	20 62 72 6f 77 6e 20 44 6f 67 20 20 20 20 20 2a
>f0f2	0d 0a
>f0f4	20 20 20 20 20 20 20 20				.text 	"          *  Jumps over the Lazy Fox!  *",CR,LF
>f0fc	20 20 2a 20 20 4a 75 6d 70 73 20 6f 76 65 72 20
>f10c	74 68 65 20 4c 61 7a 79 20 46 6f 78 21 20 20 2a
>f11c	0d 0a
>f11e	20 20 20 20 20 20 20 20				.text 	"          *                            *",CR,LF
>f126	20 20 2a 20 20 20 20 20 20 20 20 20 20 20 20 20
>f136	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 2a
>f146	0d 0a
>f148	20 20 20 20 20 20 20 20				.text 	"          ******************************",CR,LF
>f150	20 20 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f160	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f170	0d 0a
.f172					PROMPT
>f172	0d 0a						.text	CR,LF
>f174	20 20 20 20 20 20 20 20				.text	"        _,-=._              /|_/|",CR,LF
>f17c	5f 2c 2d 3d 2e 5f 20 20 20 20 20 20 20 20 20 20
>f18c	20 20 20 20 2f 7c 5f 2f 7c 0d 0a
>f197	20 20 20 20 20 20 20 2a		 		.text	"       *-.}   `=._,.-=-._.,  @ @._,",CR,LF
>f19f	2d 2e 7d 20 20 20 60 3d 2e 5f 2c 2e 2d 3d 2d 2e
>f1af	5f 2e 2c 20 20 40 20 40 2e 5f 2c 0d 0a
>f1bc	20 20 20 20 20 20 20 20		 		.text   "          `._ _,-.   )      _,.-'",CR,LF
>f1c4	20 20 60 2e 5f 20 5f 2c 2d 2e 20 20 20 29 20 20
>f1d4	20 20 20 20 5f 2c 2e 2d 27 0d 0a
>f1df	20 20 20 20 20 20 20 20				 .text   "             `    G.m-'^m'm'",CR,CR,LF
>f1e7	20 20 20 20 20 60 20 20 20 20 47 2e 6d 2d 27 5e
>f1f7	6d 27 6d 27 0d 0d 0a
>f1fe	00				   		 .text	0
.f1ff					ANYKEY
>f1ff	0d 0a 0d 0a					.text	CR,LF,CR,LF
>f203	50 72 65 73 73 20 74 68				.text 	"Press the ANY key (CTRL-C) to return to monitor",CR
>f20b	65 20 41 4e 59 20 6b 65 79 20 28 43 54 52 4c 2d
>f21b	43 29 20 74 6f 20 72 65 74 75 72 6e 20 74 6f 20
>f22b	6d 6f 6e 69 74 6f 72 0d
>f233	65 6c 73 65 20 63 6f 6e				.text   "else continue foxing:"
>f23b	74 69 6e 75 65 20 66 6f 78 69 6e 67 3a
>f248	00						.text	0
.f249					MSG_LOAD
>f249	0d 53 45 4e 44 20 53 31				.text 	CR,"SEND S19 or S28 S-RECORD file:",CR,LF
>f251	39 20 6f 72 20 53 32 38 20 53 2d 52 45 43 4f 52
>f261	44 20 66 69 6c 65 3a 0d 0a
>f26a	00						.text 	0
.f26b					MSG_JUMP
>f26b	0d 4a 75 6d 70 69 6e 67				.text 	CR,"Jumping to address: $"
>f273	20 74 6f 20 61 64 64 72 65 73 73 3a 20 24
>f281	00						.text 	0
.ffe4					NCOP
>ffe4	00 f8						.word	START		; COP exception in native mode
.ffe6					NBRK
>ffe6	00 f8						.word	START		; BRK in native mode
.ffe8					NABORT
>ffe8	00 f8						.word	START
.ffea					NNMI
>ffea	00 f8						.word	START		; NMI interrupt in native mode
.ffee					NIRQ
>ffee	00 f8						.word	START
.fff4					ECOP
>fff4	00 f8						.word	START		; COP exception in 65c02 emulation mode
.fff8					EABORT
>fff8	00 f8						.word	START
.fffa					ENMI
>fffa	00 f8						.word	START		; NMI interrupt in 65c02 emulation mode
.fffc					ERESET
>fffc	00 f8						.word	START		; RESET exception in all modes
.fffe					EIRQ
>fffe	00 f8						.word	START

;******  End of listing
