
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -L monitor.lst --intel-hex -o monitor.hex monitor.asm
; Tue Jul 16 09:13:07 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: monitor.asm


;******  Processing file: via_symbols.inc

=$7fe0					SYS_VIA_BASE	    = 	$7FE0
=32736					SYSTEM_VIA_IORB     =  	SYS_VIA_BASE+0	; Port B IO register
=32737					SYSTEM_VIA_IORA     =	SYS_VIA_BASE+1 	; Port A IO register
=32738					SYSTEM_VIA_DDRB     = 	SYS_VIA_BASE+2	; Port B data direction register
=32739					SYSTEM_VIA_DDRA     = 	SYS_VIA_BASE+3	; Port A data direction register
=32740					SYSTEM_VIA_T1C_L    =	SYS_VIA_BASE+4 	; Timer 1 counter/latches, low-order
=32741					SYSTEM_VIA_T1C_H    = 	SYS_VIA_BASE+5	; Timer 1 high-order counter
=32742					SYSTEM_VIA_T1L_L    = 	SYS_VIA_BASE+6	; Timer 1 low-order latches
=32743					SYSTEM_VIA_T1L_H    = 	SYS_VIA_BASE+7	; Timer 1 high-order latches
=32744					SYSTEM_VIA_T2C_L    = 	SYS_VIA_BASE+8	; Timer 2 counter/latches, lower-order
=32745					SYSTEM_VIA_T2C_H    = 	SYS_VIA_BASE+9	; Timer 2 high-order counter
=32746					SYSTEM_VIA_SR       = 	SYS_VIA_BASE+10	; Shift register
=32747					SYSTEM_VIA_ACR      = 	SYS_VIA_BASE+11	; Auxilliary control register
=32748					SYSTEM_VIA_PCR      =	SYS_VIA_BASE+12	; Peripheral control register
=32749					SYSTEM_VIA_IFR	    =	SYS_VIA_BASE+13 ; Interrupt flag register
=32750					SYSTEM_VIA_IER      = 	SYS_VIA_BASE+14	; Interrupt enable register
=32751					SYSTEM_VIA_ORA_IRA  =	SYS_VIA_BASE+15	; Port A IO register, but no handshake
=$7fc0					DEBUG_VIA_BASE	    = 	$7FC0
=32704					DEBUG_VIA_IORB     =  	DEBUG_VIA_BASE+0	; Port B IO register
=32705					DEBUG_VIA_IORA     =	DEBUG_VIA_BASE+1 	; Port A IO register
=32706					DEBUG_VIA_DDRB     = 	DEBUG_VIA_BASE+2	; Port B data direction register
=32707					DEBUG_VIA_DDRA     = 	DEBUG_VIA_BASE+3	; Port A data direction register
=32708					DEBUG_VIA_T1C_L    =	DEBUG_VIA_BASE+4 	; Timer 1 counter/latches, low-order
=32709					DEBUG_VIA_T1C_H    = 	DEBUG_VIA_BASE+5	; Timer 1 high-order counter
=32710					DEBUG_VIA_T1L_L    = 	DEBUG_VIA_BASE+6	; Timer 1 low-order latches
=32711					DEBUG_VIA_T1L_H    = 	DEBUG_VIA_BASE+7	; Timer 1 high-order latches
=32712					DEBUG_VIA_T2C_L    = 	DEBUG_VIA_BASE+8	; Timer 2 counter/latches, lower-order
=32713					DEBUG_VIA_T2C_H    = 	DEBUG_VIA_BASE+9	; Timer 2 high-order counter
=32714					DEBUG_VIA_SR       = 	DEBUG_VIA_BASE+10	; Shift register
=32715					DEBUG_VIA_ACR      = 	DEBUG_VIA_BASE+11	; Auxilliary control register
=32716					DEBUG_VIA_PCR      =	DEBUG_VIA_BASE+12	; Peripheral control register
=32717					DEBUG_VIA_IFR	    =	DEBUG_VIA_BASE+13 ; Interrupt flag register
=32718					DEBUG_VIA_IER      = 	DEBUG_VIA_BASE+14	; Interrupt enable register
=32719					DEBUG_VIA_ORA_IRA  =	DEBUG_VIA_BASE+15	; Port A IO register, but no handshake
=$01					PB0 = MASK0
=$02					PB1 = MASK1
=$04					PB2 = MASK2
=$08					PB3 = MASK3
=$10					PB4 = MASK4
=$20					PB5 = MASK5
=$40					PB6 = MASK6
=$80					PB7 = MASK7
=$01					PA0 = MASK0
=$02					PA1 = MASK1
=$04					PA2 = MASK2
=$08					PA3 = MASK3
=$10					PA4 = MASK4
=$20					PA5 = MASK5
=$40					PA6 = MASK6
=$80					PA7 = MASK7

;******  Return to file: monitor.asm


;******  Processing file: acia_symbols.inc

=$7f80					ACIA_BASE = $7F80		; This is where the 6551 ACIA starts
=$7f80					SDR = ACIA_BASE       		; RX'ed bytes read, TX bytes written, here
=32641					SSR = ACIA_BASE+1     		; Serial data status register
=32642					SCMD = ACIA_BASE+2     		; Serial command reg. ()
=32643					SCTL = ACIA_BASE+3     		; Serial control reg. ()
=$10					TX_RDY = MASK4
=$08					RX_RDY = MASK3
=$00					ALL_INPUTS = $00
=$ff					ALL_OUTPUTS = $FF

;******  Return to file: monitor.asm

=$03					CTRL_C	= $03
=$08					BS		= $08
=$0a					LF		= $0A
=$0d					CR		= $0D
=$20					SP		= $20
=$7f					DEL     = $7F
=$01					MASK0		= %00000001
=$02					MASK1		= %00000010
=$04					MASK2		= %00000100
=$08					MASK3		= %00001000
=$10					MASK4		= %00010000
=$20					MASK5		= %00100000
=$40					MASK6 		= %01000000
=$80					MASK7		= %10000000
=$80					N_FLAG		= MASK7
=$40					V_FLAG		= MASK6
=$20					M_FLAG		= MASK5
=$10					X_FLAG		= MASK4
=$08					D_FLAG		= MASK3
=$04					I_FLAG		= MASK2
=$02					Z_FLAG		= MASK1
=$01					C_FLAG		= MASK0
=$43					TERMFLAGS = $43
=$01					RDRDY	= $01				; 1 = character waiting
=$04					XONXOFF = $04				; 0 = hardware handshake 1= XON/XOFF
=$20					ECHOOFF = $20
>00e0					REC_TYPE	.byte 	?
>00e1					DP_START	.byte	?
>00e2					PTR_L		.byte	?	; Generic pointer
>00e3					PTR_H		.byte	?
>00e4					PTR_B		.byte	?
=$e2					PTR			=		PTR_L
>00e5					CTR_L		.byte	?	; Counter
>00e6					CTR_H		.byte	?
>00e7					CTR_B		.byte	?
=$e5					CTR			= 		CTR_L
>00e8					SA_L		.byte 	?	; Starting address storage for various commands & loader
>00e9					SA_H		.byte 	?
>00ea					SA_B		.byte	?
=$e8					SA			=		SA_L
>00eb					EA_L		.byte 	?	; Starting address storage for various commands
>00ec					EA_H		.byte 	?
>00ed					EA_B		.byte	?
=$eb					EA			=		EA_L
>00ee					DATA_CNT	.byte 	?	; Count of record's actual storable data bytes
>00ef					FIFO_PIT	.byte	?
>00f0					SUBTEMP 	.byte	?	; Any subroutine that doesn't call others can use as local scratchpad space
>00f1					HEXASSY		.byte	?
>0400					CMDBUF 		.fill	256	; can be smaller than 256 but must not cross 8 bit page boundary
>0500					CB_RDPTR	.word	?	; Use LDA/STA 0,X typically
>0502					CB_WRPTR	.word 	?	; Use LAD/STA 0,Y typically
>0504					PRM_SA	.word	?		; Parameter start address
>0506					PRM_SIZ	.byte	?		; Size of current parameter
>0507					EOLFLAG	.byte	?		; 0 = EOL not found, !0 = EOL has been encountered
>0508					BYTECNT	.byte 	?
>0509					HEXIO_L	.byte	?
>050a					HEXIO_H	.byte	?
>050b					HEXIO_B	.byte	?
=$0509					HEXIO		=	HEXIO_L				; 24 bit HEX value to print
=$7eff					STACKTOP	=	$7EFF				; Top of RAM = $07EFF (I/O is $7F00-$7FFF)
.f800					START
.f800	78		sei					SEI
.f801	18		clc					CLC
.f802	fb		xce					XCE
.f803	c2 18		rep #$18				REP	#(X_FLAG | D_FLAG)
.f805	e2 20		sep #$20				SEP	#M_FLAG
.f807	a2 ff 7e	ldx #$7eff				LDX	#STACKTOP
.f80a	9a		txs					TXS
.f80b	20 43 f9	jsr $f943				JSR	INIT_FIFO
.f80e	a0 51 f0	ldy #$f051				LDY	#QBFMSG			; Start of monitor loop
.f811	20 93 fb	jsr $fb93				JSR	PUT_STR
.f814					MONGETL
.f814	20 ab f8	jsr $f8ab				JSR	GETLINE
.f817	20 36 f8	jsr $f836				JSR	PARSELINE
.f81a	80 f8		bra $f814				BRA	MONGETL			; End of monitor loop
.f81c					INITPARS
.f81c	9c 06 05	stz $0506				STZ	PRM_SIZ			; No known parameter size
.f81f	9c 07 05	stz $0507				STZ	EOLFLAG			; No EOL found yet
.f822	a2 00 04	ldx #$0400				LDX	#CMDBUF
.f825	8e 00 05	stx $0500				STX	CB_RDPTR		; Start read pointer at start of command buffer
.f828	8e 04 05	stx $0504				STX	PRM_SA			; First parameter starts at command buffer[0]
.f82b	60		rts					RTS
.f82c					CLRCMD
.f82c	a2 00 04	ldx #$0400				LDX	#CMDBUF			; Point CB_WRPTR to start of command buffer
.f82f	8e 02 05	stx $0502				STX	CB_WRPTR
.f832	9c 00 04	stz $0400				STZ	CMDBUF			; Null terminate the empty buffer
.f835	60		rts					RTS
.f836					PARSELINE
.f836	20 1c f8	jsr $f81c				JSR	INITPARS
.f839					FINDCMD
.f839	20 62 f8	jsr $f862				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.f83c	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.f83f	d0 20		bne $f861				BNE	PLIX2			; We hit an EOL before an actionable character, so quit
.f841	a9 00		lda #$00				LDA	#0
.f843	eb		xba					XBA				; Make B zero so when TAX times comes, MSB of X will be 0! (0 emphasis not 0 factorial)
.f844	ae 00 05	ldx $0500				LDX	CB_RDPTR		; point to command byte
.f847	b5 00		lda $00,x				LDA	0,X			; Get command byte
.f849	e8		inx					INX				; Point past the command byte to save each subroutine from doing this
.f84a	8e 00 05	stx $0500				STX	CB_RDPTR		; "
.f84d	c9 41		cmp #$41				CMP	#'A'
.f84f	90 0d		bcc $f85e				BCC	PLERRXIT		; < 'A', so not a command
.f851	c9 5b		cmp #$5b				CMP	#'Z'+1
.f853	b0 09		bcs $f85e				BCS	PLERRXIT		; > 'Z', so not a command
.f855	e9 40		sbc #$40				SBC	#'A'-1			; Carry clear, so subtract one less to account for borrow
.f857	0a		asl a					ASL	A			; Two bytes per JSR table entry
.f858	aa		tax					TAX						; X now holds offset in MONTABLE
.f859	fc 9f fd	jsr ($fd9f,x)				JSR	(MONTBL,X)		; No JSR indirect indexed.  Each table entry MUST end in RTS not RTL!
.f85c	80 03		bra $f861				BRA	PLIX2			; We're done dispatching.
.f85e					PLERRXIT:
.f85e	20 53 fb	jsr $fb53				JSR	LOLWUT			; Print non-understood buffer plus ?[CR][LF]
.f861					PLIX2
.f861	60		rts					RTS
.f862					FINDSTART
.f862	ac 00 05	ldy $0500				LDY	CB_RDPTR
.f865					FSN1
.f865	b9 00 00	lda $0000,y				LDA	0,Y			; Get next character
.f868	f0 0f		beq $f879				BEQ	FSEOL			; Null --> End of line encountered.  We are done
.f86a	c9 0d		cmp #$0d				CMP	#CR
.f86c	f0 0b		beq $f879				BEQ	FSEOL			; CR = end of line also
.f86e	c9 03		cmp #$03				CMP	#CTRL_C
.f870	f0 07		beq $f879				BEQ	FSEOL			; CTRL-C = end of line
.f872	c9 21		cmp #$21				CMP	#SP+1			; if space or less, and not CR or CTRL-C, skip over
.f874	b0 08		bcs $f87e				BCS	FSDUN			; A non-whitespace character.  We're done looking
.f876	c8		iny					INY				; Keep looking for a valid parameter byte
.f877	80 ec		bra $f865				BRA	FSN1			; Next character
.f879					FSEOL
.f879	a9 01		lda #$01				LDA	#1
.f87b	8d 07 05	sta $0507				STA	EOLFLAG
.f87e					FSDUN
.f87e	8c 00 05	sty $0500				STY	CB_RDPTR		; Save pointers by current value of Y
.f881	8c 04 05	sty $0504				STY	PRM_SA			; Save pointers by current value of Y
.f884	60		rts					RTS
.f885					FINDEND
.f885	9c 06 05	stz $0506				STZ	PRM_SIZ			; No known parameter bytes yet
.f888	ac 00 05	ldy $0500				LDY	CB_RDPTR
.f88b					FEN1
.f88b	b9 00 00	lda $0000,y				LDA	0,Y			; Get next character
.f88e	f0 12		beq $f8a2				BEQ	FEEOL			; Null --> End of line encountered.  We are done
.f890	c9 0d		cmp #$0d				CMP	#CR
.f892	f0 0e		beq $f8a2				BEQ	FEEOL			; CR = end of line also
.f894	c9 03		cmp #$03				CMP	#CTRL_C
.f896	f0 0a		beq $f8a2				BEQ	FEEOL			; CTRL-C = end of line
.f898	c9 21		cmp #$21				CMP	#SP+1			; if space or less, and not CR or CTRL-C,
.f89a	90 0b		bcc $f8a7				BCC	FEDUN1			; A whitespace character.  We're done looking
.f89c	c8		iny					INY
.f89d	ee 06 05	inc $0506				INC	PRM_SIZ			; add one more to size of parameter
.f8a0	80 e9		bra $f88b				BRA	FEN1
.f8a2					FEEOL
.f8a2	a9 01		lda #$01				LDA	#1
.f8a4	8d 07 05	sta $0507				STA	EOLFLAG
.f8a7					FEDUN1
.f8a7	8c 00 05	sty $0500				STY	CB_RDPTR		; Save pointers by current value of read pointer (don't update PRM_SA)
.f8aa	60		rts					RTS
.f8ab					GETLINE
.f8ab	20 64 fb	jsr $fb64				JSR	CRLF
.f8ae	a9 3e		lda #$3e				LDA	#'>'
.f8b0	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.f8b3	20 2c f8	jsr $f82c				JSR	CLRCMD
.f8b6					GLLP1
.f8b6	20 ae fb	jsr $fbae				JSR	GETCHAR				; Do not echo
.f8b9	c9 0d		cmp #$0d				CMP	#CR
.f8bb	d0 05		bne $f8c2				BNE	GLNC0
.f8bd	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.f8c0	80 43		bra $f905				BRA	GLXIT1				; end of message
.f8c2					GLNC0
.f8c2	c9 03		cmp #$03				CMP	#CTRL_C
.f8c4	d0 14		bne $f8da				BNE	GLNC1
.f8c6	a9 5e		lda #$5e				LDA	#'^'
.f8c8	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.f8cb	a9 43		lda #$43				LDA	#'C'
.f8cd	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.f8d0	a9 0d		lda #$0d				LDA	#CR
.f8d2	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.f8d5	20 2c f8	jsr $f82c				JSR	CLRCMD				; zotch out any command in buffer
.f8d8	80 2b		bra $f905				BRA	GLXIT1
.f8da					GLNC1
.f8da	c9 0a		cmp #$0a				CMP	#LF
.f8dc	d0 02		bne $f8e0				BNE	GLNC2
.f8de	80 d6		bra $f8b6				BRA	GLLP1
.f8e0					GLNC2
.f8e0	c9 08		cmp #$08				CMP	#BS				; We will not tolerate BS here
.f8e2	d0 16		bne $f8fa				BNE	GLNC9
.f8e4	c9 7f		cmp #$7f				CMP	#DEL
.f8e6	d0 12		bne $f8fa				BNE	GLNC9
.f8e8	74 00		stz $00,x				STZ	0,X
.f8ea	e0 00 04	cpx #$0400				CPX	#CMDBUF
.f8ed	f0 c7		beq $f8b6				BEQ	GLLP1				; Already backed over the first character. No index to decrement
.f8ef	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.f8f2	ca		dex					DEX					; change buffer pointer
.f8f3	8e 02 05	stx $0502				STX	CB_WRPTR
.f8f6	74 00		stz $00,x				STZ	0,X				; Character we backed over is now end of string
.f8f8	80 bc		bra $f8b6				BRA	GLLP1
.f8fa					GLNC9
.f8fa	95 00		sta $00,x				STA	0,X				; store it
.f8fc	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.f8ff	e8		inx					INX
.f900	8e 02 05	stx $0502				STX	CB_WRPTR
.f903	80 b1		bra $f8b6				BRA	GLLP1
.f905					GLXIT1
.f905	74 00		stz $00,x				STZ	0,X				; null-terminate the line
.f907	60		rts					RTS
.f908					TOPUPPER
.f908	c9 61		cmp #$61				CMP	#'a'				; Make character PupperCase
.f90a	90 06		bcc $f912				BCC	PUPX1				; A < 'a' so can't be lowercase char
.f90c	c9 7b		cmp #$7b				CMP	#'z'+1
.f90e	b0 02		bcs $f912				BCS	PUPX1				; A > 'z', so can't be lowercase char
.f910	e9 1f		sbc #$1f				SBC	#'a'-'A'-1			; Adjust upper case to lower case
.f912					PUPX1
.f912	60		rts					RTS
=$01					FIFO_TXE = PB0
=$02					FIFO_RXF = PB1
=$04					FIFO_WR = PB2
=$08					FIFO_RD = PB3
=$20					FIFO_PWREN = PB5
=$80					FIFO_DEBUG = PB7		; Handy debug toggle output free for any use
.f913					PUT_FIFO
.f913	20 6b f9	jsr $f96b				JSR	PUT_FRAW
.f916	b0 fb		bcs $f913				BCS	PUT_FIFO
.f918	60		rts					RTS
.f919					GET_FIFO
.f919	20 95 f9	jsr $f995				JSR 	GET_FRAW
.f91c	b0 fb		bcs $f919				BCS	GET_FIFO
.f91e	60		rts					RTS
.f91f					SEL_BANK3
.f91f	a9 ff		lda #$ff				LDA	#%11111111
.f921	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f924	60		rts					RTS
.f925					SEL_BANK2
.f925	a9 fd		lda #$fd				LDA	#%11111101
.f927	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f92a	60		rts					RTS
.f92b					SEL_BANK1
.f92b	a9 df		lda #$df				LDA	#%11011111
.f92d	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f930	60		rts					RTS
.f931					SEL_BANK0
.f931	a9 dd		lda #$dd				LDA	#%11011101
.f933	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f936	60		rts					RTS
.f937					INIT_SYSVIA
.f937	a9 ff		lda #$ff				LDA	#$FF
.f939	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f93c	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA
.f93f	9c e2 7f	stz $7fe2				STZ	SYSTEM_VIA_DDRB
.f942	60		rts					RTS
.f943					INIT_FIFO
.f943	a9 ff		lda #$ff				LDA	#$FF
.f945	8d ec 7f	sta $7fec				STA 	SYSTEM_VIA_PCR			; CB2=FAMS=flash A16=1;  CA2=FA15=A15=1; Select flash Bank #3
.f948	9c eb 7f	stz $7feb				STZ 	SYSTEM_VIA_ACR			; Disable PB7, shift register, timer T1 interrupt.  Not absolutely required while interrupts are disabled FIXME: set up timer
.f94b	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Set PA0-PA7 to all inputs
.f94e	9c e2 7f	stz $7fe2				STZ	SYSTEM_VIA_DDRB			; In case we're not coming off a reset, make PORT B an input and change output register when it's NOT outputting
.f951	a9 08		lda #$08				LDA	#FIFO_RD				;
.f953	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Avoid possible glitch by writing to output latch while Port B is still an input (after reset)
.f956	a9 0c		lda #$0c				LDA	#(FIFO_RD + FIFO_WR)		; Make FIFO RD & WR pins outputs so we can strobe data in and out of the FIFO
.f958	8d e2 7f	sta $7fe2				STA	SYSTEM_VIA_DDRB			; Port B: PB2 and PB3 are outputs; rest are inputs from earlier IORB write
.f95b	20 b6 f9	jsr $f9b6				JSR	TXCHDLY				; Should wait (with timeout!) on PWERENB signal going low on power up or after.
.f95e	20 b6 f9	jsr $f9b6				JSR	TXCHDLY				; Timeout is essential in case board is powered off RS232 port,
.f961	20 b6 f9	jsr $f9b6				JSR	TXCHDLY				; in which case the FIFO will not get power and this pin will never be (active) low.
.f964	20 b6 f9	jsr $f9b6				JSR	TXCHDLY
.f967	20 b6 f9	jsr $f9b6				JSR	TXCHDLY
.f96a	60		rts					RTS
.f96b					PUT_FRAW
.f96b	85 ef		sta $ef					STA	FIFO_PIT
.f96d	ad e0 7f	lda $7fe0				LDA	SYSTEM_VIA_IORB			; Read in FIFO status Port for FIFO
.f970	29 01		and #$01				AND	#FIFO_TXE				; If TXE is low, we can accept data into FIFO.  If high, return immmediately
.f972	38		sec					SEC							; FIFO is full, so don't try to queue it!
.f973	d0 1d		bne $f992				BNE	OFX1					; 0 = OK to write to FIFO; 1 = Wait, FIFO full!
.f975					OFCONT
.f975	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; (Defensive) Start with Port A input/floating
.f978	a9 0c		lda #$0c				LDA	#(FIFO_RD + FIFO_WR)	; RD=1 WR=1 (WR must go 1->0 for FIFO write)
.f97a	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Make sure write is high (and read too!)
.f97d	a5 ef		lda $ef					LDA 	FIFO_PIT			; Restore the data to send
.f97f	8d e1 7f	sta $7fe1				STA	SYSTEM_VIA_IORA			; Set up output value in advance in Port A (still input so doesn't go out yet)
.f982	a9 ff		lda #$ff				LDA	#$FF				; make Port A all outputs with stable output value already set in prior lines
.f984	8d e3 7f	sta $7fe3				STA	SYSTEM_VIA_DDRA			; Save data to output latches
.f987	ea		nop					NOP					; Some settling time of data output just to be safe
.f988	a9 08		lda #$08				LDA	#(FIFO_RD)			; RD=1 WR=0 (WR1->0 transition triggers FIFO transfer!)
.f98a	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Low-going WR pulse should latch data
.f98d	ea		nop					NOP							; Hold time following write strobe, to ensure value is latched OK
.f98e	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Make port A an input again
.f991	18		clc					CLC					; signal success of write to caller
.f992					OFX1
.f992	a5 ef		lda $ef					LDA	FIFO_PIT
.f994	60		rts					RTS
.f995					GET_FRAW
.f995	ad e0 7f	lda $7fe0				LDA	SYSTEM_VIA_IORB			; Check RXF flag
.f998	29 02		and #$02				AND	#FIFO_RXF			; If clear, we're OK to read.  If set, there's no data waiting
.f99a	38		sec					SEC
.f99b	d0 18		bne $f9b5				BNE 	INFXIT				; If RXF is 1, then no character is waiting!
.f99d	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Make Port A inputs
.f9a0	a9 08		lda #$08				LDA	#FIFO_RD
.f9a2	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; RD=1 WR=0 (RD must go to 0 to read
.f9a5	ea		nop					NOP
.f9a6	9c e0 7f	stz $7fe0				STZ	SYSTEM_VIA_IORB			; RD=0 WR=0	- FIFO presents data to port A
.f9a9	ea		nop					NOP
.f9aa	ad e1 7f	lda $7fe1				LDA	SYSTEM_VIA_IORA			; read data in
.f9ad	48		pha					PHA
.f9ae	a9 08		lda #$08				LDA	#FIFO_RD			; Restore back to inactive signals RD=1 and WR=0
.f9b0	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB
.f9b3	68		pla					PLA
.f9b4	18		clc					CLC					; we got a byte!
.f9b5					INFXIT
.f9b5	60		rts					RTS
=$0940					TX_DLY_CYCLES = $0940						; Not tuned.  As it's temporary, optimum settings are unimportant.
.f9b6					TXCHDLY
.f9b6	5a		phy					PHY
.f9b7	a0 40 09	ldy #$0940				LDY	#TX_DLY_CYCLES		; FIXME: Very bad work-around until timers are up
.f9ba					DLY_Y
.f9ba	88		dey					DEY
.f9bb	ea		nop					NOP
.f9bc	ea		nop					NOP
.f9bd	ea		nop					NOP
.f9be	d0 fa		bne $f9ba				BNE	DLY_Y
.f9c0	7a		ply					PLY
.f9c1	60		rts					RTS
.f9c2					INC_SA24
.f9c2	18		clc					CLC
.f9c3	a5 e2		lda $e2					LDA	PTR_L
.f9c5	69 01		adc #$01				ADC	#1
.f9c7	85 e2		sta $e2					STA	PTR_L
.f9c9	a5 e3		lda $e3					LDA	PTR_H
.f9cb	69 00		adc #$00				ADC	#0
.f9cd	85 e3		sta $e3					STA	PTR_H
.f9cf	a5 e4		lda $e4					LDA	PTR_B
.f9d1	69 00		adc #$00				ADC	#0
.f9d3	85 e4		sta $e4					STA	PTR_B
.f9d5	60		rts					RTS
.f9d6					DEC_CTR24
.f9d6	38		sec					SEC
.f9d7	a5 e5		lda $e5					LDA	CTR_L			; one less byte to print out
.f9d9	e9 01		sbc #$01				SBC	#1
.f9db	85 e5		sta $e5					STA	CTR_L
.f9dd	a5 e6		lda $e6					LDA	CTR_H
.f9df	e9 00		sbc #$00				SBC	#0
.f9e1	85 e6		sta $e6					STA	CTR_H
.f9e3	a5 e7		lda $e7					LDA	CTR_B
.f9e5	e9 00		sbc #$00				SBC	#0
.f9e7	85 e7		sta $e7					STA	CTR_B
.f9e9	60		rts					RTS
.f9ea					CMD_DUMPHEX
.f9ea	20 64 fb	jsr $fb64				JSR	CRLF			; Give some space
.f9ed	20 62 f8	jsr $f862				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.f9f0	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.f9f3	f0 03		beq $f9f8				BEQ	CDH_NOTEOL		; Not EOL, so start dumping data
.f9f5	82 b6 00	brl $faae				BRL	DHEXX1			; We hit an EOL before an actionable character, so quit
.f9f8					CDH_NOTEOL
.f9f8	9c 08 05	stz $0508				STZ	BYTECNT			; First line and every 16 bytes will show current address
.f9fb	20 85 f8	jsr $f885				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.f9fe	20 ca fc	jsr $fcca				JSR	CONVHEX			; Get starting address in HEXIO
.fa01	ad 0b 05	lda $050b				LDA	HEXIO_B			; Put starting address in PTR
.fa04	85 e4		sta $e4					STA	PTR_B
.fa06	ad 0a 05	lda $050a				LDA	HEXIO_H
.fa09	85 e3		sta $e3					STA	PTR_H
.fa0b	ad 09 05	lda $0509				LDA	HEXIO_L
.fa0e	85 e2		sta $e2					STA	PTR_L
.fa10	20 62 f8	jsr $f862				JSR	FINDSTART		;Get next parameter
.fa13	ad 07 05	lda $0507				LDA	EOLFLAG			; is there one?
.fa16	f0 0b		beq $fa23				BEQ	DHSAVEA			; save end address if not EOL after start address read
.fa18	64 e7		stz $e7					STZ	CTR_B
.fa1a	64 e6		stz $e6					STZ	CTR_H
.fa1c	a9 01		lda #$01				LDA	#1
.fa1e	85 e5		sta $e5					STA	CTR_L
.fa20	82 3b 00	brl $fa5e				BRL	DUMPITNOW
.fa23					DHSAVEA
.fa23	20 85 f8	jsr $f885				JSR	FINDEND
.fa26	20 ca fc	jsr $fcca				JSR	CONVHEX			; get 8 to 24 bit end address
.fa29	ad 0b 05	lda $050b				LDA	HEXIO_B
.fa2c	85 ed		sta $ed					STA	EA_B
.fa2e	ad 0a 05	lda $050a				LDA	HEXIO_H
.fa31	85 ec		sta $ec					STA	EA_H
.fa33	ad 09 05	lda $0509				LDA	HEXIO_L
.fa36	85 eb		sta $eb					STA	EA_L
.fa38	38		sec					SEC
.fa39	a5 eb		lda $eb					LDA	EA_L
.fa3b	e5 e2		sbc $e2					SBC	PTR_L
.fa3d	85 e5		sta $e5					STA	CTR_L
.fa3f	a5 ec		lda $ec					LDA	EA_H
.fa41	e5 e3		sbc $e3					SBC	PTR_H
.fa43	85 e6		sta $e6					STA	CTR_H
.fa45	a5 ed		lda $ed					LDA	EA_B
.fa47	e5 e4		sbc $e4					SBC	PTR_B			; Just to be thorough, should we support > 64K dump someday
.fa49	85 e7		sta $e7					STA	CTR_B
.fa4b	18		clc					CLC				; Probably can make this more efficient
.fa4c	a5 e5		lda $e5					LDA	CTR_L			; Calculate byte count of dump in CTR
.fa4e	69 01		adc #$01				ADC	#1
.fa50	85 e5		sta $e5					STA	CTR_L
.fa52	a5 e6		lda $e6					LDA	CTR_H
.fa54	69 00		adc #$00				ADC	#0
.fa56	85 e6		sta $e6					STA	CTR_H
.fa58	a5 e7		lda $e7					LDA	CTR_B
.fa5a	69 00		adc #$00				ADC	#0
.fa5c	85 e7		sta $e7					STA	CTR_B
.fa5e					DUMPITNOW
.fa5e	a5 e5		lda $e5					LDA	CTR_L			; Check for done
.fa60	05 e6		ora $e6					ORA	CTR_H
.fa62	05 e7		ora $e7					ORA	CTR_B
.fa64	f0 48		beq $faae				BEQ 	DHEXX1			; We're done
.fa66	ad 08 05	lda $0508				LDA	BYTECNT
.fa69	d0 24		bne $fa8f				BNE	DUMPITN1		;
.fa6b					DHEXC6
.fa6b	20 64 fb	jsr $fb64				JSR	CRLF
.fa6e	a5 e4		lda $e4					LDA	PTR_B
.fa70	8d 0b 05	sta $050b				STA	HEXIO_B
.fa73	a5 e3		lda $e3					LDA	PTR_H
.fa75	8d 0a 05	sta $050a				STA	HEXIO_H
.fa78	a5 e2		lda $e2					LDA	PTR_L
.fa7a	8d 09 05	sta $0509				STA	HEXIO_L
.fa7d	20 44 fd	jsr $fd44				JSR	PUTHEX24		; Print the address
.fa80	a9 3a		lda #$3a				LDA	#':'
.fa82	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fa85	a9 20		lda #$20				LDA	#SP
.fa87	20 8f fb	jsr $fb8f				JSR	PUTCHAR			;
.fa8a	a9 20		lda #$20				LDA	#SP
.fa8c	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fa8f					DUMPITN1
.fa8f	a7 e2		lda [$e2]				LDA	[PTR]			; Dump CTR bytes starting at [PTR]
.fa91	20 5c fd	jsr $fd5c				JSR	PUTHEXA
.fa94	a9 20		lda #$20				LDA	#' '
.fa96	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fa99	20 c2 f9	jsr $f9c2				JSR	INC_SA24		; Next source address
.fa9c					DHEXC3
.fa9c	20 d6 f9	jsr $f9d6				JSR	DEC_CTR24
.fa9f	ee 08 05	inc $0508				INC 	BYTECNT
.faa2	ad 08 05	lda $0508				LDA	BYTECNT
.faa5	c9 10		cmp #$10				CMP	#16
.faa7	d0 b5		bne $fa5e				BNE	DUMPITNOW
.faa9	9c 08 05	stz $0508				STZ	BYTECNT
.faac	80 b0		bra $fa5e				BRA	DUMPITNOW		; Print the address at start of new line
.faae					DHEXX1
.faae	60		rts					RTS
.faaf					CMD_WRITEBYTES
.faaf	20 64 fb	jsr $fb64				JSR	CRLF			; Give some space
.fab2	20 62 f8	jsr $f862				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.fab5	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.fab8	d0 5e		bne $fb18				BNE	CWBXX2			; We hit an EOL before an actionable character, so quit
.faba	20 85 f8	jsr $f885				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.fabd	20 ca fc	jsr $fcca				JSR	CONVHEX			; Get starting address in HEXIO
.fac0	ad 0b 05	lda $050b				LDA	HEXIO_B			; Transfer starting address from HEXIO to PTR
.fac3	85 e4		sta $e4					STA	PTR_B
.fac5	ad 0a 05	lda $050a				LDA	HEXIO_H
.fac8	85 e3		sta $e3					STA	PTR_H
.faca	ad 09 05	lda $0509				LDA	HEXIO_L
.facd	85 e2		sta $e2					STA	PTR_L
.facf					CWLOOP1
.facf	20 62 f8	jsr $f862				JSR	FINDSTART		; Get next byte
.fad2	ad 07 05	lda $0507				LDA	EOLFLAG
.fad5	d0 41		bne $fb18				BNE	CWBXX2
.fad7	20 85 f8	jsr $f885				JSR	FINDEND			; Find end of Parameter
.fada	20 a3 fc	jsr $fca3				JSR	RDHEX8
.fadd	87 e2		sta [$e2]				STA	[PTR]			; Attempt to store.  If ROM, output will show failure to write
.fadf	a5 e4		lda $e4					LDA	PTR_B
.fae1	8d 0b 05	sta $050b				STA	HEXIO_B
.fae4	a5 e3		lda $e3					LDA	PTR_H
.fae6	8d 0a 05	sta $050a				STA	HEXIO_H
.fae9	a5 e2		lda $e2					LDA	PTR_L
.faeb	8d 09 05	sta $0509				STA	HEXIO_L
.faee	20 44 fd	jsr $fd44				JSR	PUTHEX24
.faf1	a9 3c		lda #$3c				LDA	#'<'
.faf3	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.faf6	a9 2d		lda #$2d				LDA	#'-'
.faf8	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fafb	a7 e2		lda [$e2]				LDA	[PTR]			; Read the actual byte (if ROM, won't match input)
.fafd	20 5c fd	jsr $fd5c				JSR	PUTHEXA
.fb00	20 64 fb	jsr $fb64				JSR	CRLF
.fb03	18		clc					CLC
.fb04	a5 e2		lda $e2					LDA	PTR_L
.fb06	69 01		adc #$01				ADC	#1
.fb08	85 e2		sta $e2					STA	PTR_L
.fb0a	a5 e3		lda $e3					LDA	PTR_H
.fb0c	69 00		adc #$00				ADC	#0
.fb0e	85 e3		sta $e3					STA	PTR_H
.fb10	a5 e4		lda $e4					LDA	PTR_B
.fb12	69 00		adc #$00				ADC	#0
.fb14	85 e4		sta $e4					STA	PTR_B
.fb16	80 b7		bra $facf				BRA	CWLOOP1
.fb18					CWBXX2
.fb18	60		rts					RTS
.fb19					CMD_LOAD
.fb19	a0 49 f2	ldy #$f249				LDY	#MSG_LOAD
.fb1c	20 93 fb	jsr $fb93				JSR	PUT_STR
.fb1f	20 bd fb	jsr $fbbd				JSR	SREC_LOADER
.fb22	60		rts					RTS
.fb23					CMD_GO
.fb23	20 64 fb	jsr $fb64				JSR	CRLF			; Give some space
.fb26	20 62 f8	jsr $f862				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.fb29	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.fb2c	d0 24		bne $fb52				BNE	CGXIT1			; We hit an EOL before an actionable character, so quit
.fb2e	20 85 f8	jsr $f885				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.fb31	20 ca fc	jsr $fcca				JSR	CONVHEX			; Get starting address in HEXIO
.fb34	ad 0b 05	lda $050b				LDA	HEXIO_B			; Transfer starting address from HEXIO to PTR
.fb37	85 e4		sta $e4					STA	PTR_B
.fb39	ad 0a 05	lda $050a				LDA	HEXIO_H
.fb3c	85 e3		sta $e3					STA	PTR_H
.fb3e	ad 09 05	lda $0509				LDA	HEXIO_L
.fb41	85 e2		sta $e2					STA	PTR_L
.fb43	a0 6b f2	ldy #$f26b				LDY	#MSG_JUMP
.fb46	20 93 fb	jsr $fb93				JSR	PUT_STR
.fb49	20 44 fd	jsr $fd44				JSR	PUTHEX24
.fb4c	20 64 fb	jsr $fb64				JSR	CRLF			; get rid of return address since we're not returing!
.fb4f	dc e2 00	jmp [$00e2]				JML	[PTR]			; There's really no exit
.fb52					CGXIT1
.fb52	60		rts					RTS						; Might return if no valid jump address
.fb53					LOLWUT
.fb53	20 64 fb	jsr $fb64				JSR	CRLF
.fb56	a0 00 04	ldy #$0400				LDY	#CMDBUF
.fb59	20 9f fb	jsr $fb9f				JSR	PUT_STR_CTRL		; Display buffer contents not understood; show non-printing too!
.fb5c	20 64 fb	jsr $fb64				JSR	CRLF
.fb5f	a9 3f		lda #$3f				LDA	#'?'
.fb61	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fb64					CRLF
.fb64	a9 0a		lda #$0a				LDA	#LF
.fb66	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fb69					JUSTCR
.fb69	a9 0d		lda #$0d				LDA	#CR
.fb6b	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fb6e	60		rts					RTS
.fb6f					CMD_A
.fb6f					CMD_B
.fb6f					CMD_C
.fb6f					CMD_D
.fb6f					CMD_E
.fb6f					CMD_F
.fb6f					CMD_H
.fb6f					CMD_I
.fb6f					CMD_J
.fb6f					CMD_K
.fb6f					CMD_M
.fb6f					CMD_N
.fb6f					CMD_O
.fb6f					CMD_P
.fb6f					CMD_Q
.fb6f					CMD_R
.fb6f					CMD_S
.fb6f					CMD_T
.fb6f					CMD_U
.fb6f					CMD_V
.fb6f					CMD_X
.fb6f					CMD_Y
.fb6f					CMD_Z
.fb6f	a0 00 f0	ldy #$f000				LDY	#MSG_UNIMPLEMENTED
.fb72	20 93 fb	jsr $fb93				JSR	PUT_STR
.fb75	60		rts					RTS
.fb76	c9 20		cmp #$20	PUTCHARDOT		CMP	#SP
.fb78	b0 02		bcs $fb7c				BCS	PCDPRINT
.fb7a	a9 2e		lda #$2e				LDA	#'.'
.fb7c					PCDPRINT
.fb7c	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fb7f	60		rts					RTS
.fb80					PUTCHARTR
.fb80	c9 20		cmp #$20				CMP	#$20
.fb82	b0 0b		bcs $fb8f				BCS	PUTCHAR
.fb84	48		pha					PHA					; Display as hex value
.fb85	a9 5c		lda #$5c				LDA	#'\'
.fb87	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fb8a	68		pla					PLA
.fb8b	20 5c fd	jsr $fd5c				JSR	PUTHEXA
.fb8e					PUTCRX1
.fb8e	60		rts					RTS
.fb8f					PUTCHAR
.fb8f	20 13 f9	jsr $f913				JSR	PUT_FIFO
.fb92	60		rts					RTS
.fb93					PUT_STR
.fb93	b9 00 00	lda $0000,y				LDA	0,Y				; Y points directly to string
.fb96	f0 06		beq $fb9e				BEQ	PUTSX
.fb98	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fb9b	c8		iny					INY					; point to next character
.fb9c	80 f5		bra $fb93				BRA	PUT_STR
.fb9e					PUTSX
.fb9e	60		rts					RTS
.fb9f					PUT_STR_CTRL
.fb9f	b9 00 00	lda $0000,y				LDA	0,Y				; Y points directly to string
.fba2	f0 06		beq $fbaa				BEQ	PUTSRX
.fba4	20 80 fb	jsr $fb80				JSR	PUTCHARTR			; Show control characters, etc.
.fba7	c8		iny					INY					; point to next character
.fba8	80 f5		bra $fb9f				BRA	PUT_STR_CTRL
.fbaa					PUTSRX
.fbaa	60		rts					RTS
.fbab					GET_RAW
.fbab	82 6b fd	brl $f919				BRL	GET_FIFO
.fbae					GETCHAR
.fbae	a5 43		lda $43					LDA	TERMFLAGS		; relying on W265 SBC char in buffer (temporarily)
.fbb0	29 df		and #$df				AND	#%11011111		; Turn off ECHO
.fbb2	09 10		ora #$10				ORA	#%00010000		; Turn off hardware handshaking to 265 (not run)
.fbb4	85 43		sta $43					STA 	TERMFLAGS
.fbb6	20 ab fb	jsr $fbab				JSR	GET_RAW
.fbb9	20 08 f9	jsr $f908				JSR	TOPUPPER		; Make alphabetics Puppercase
.fbbc	60		rts					RTS
.fbbd					SREC_LOADER
.fbbd					SYNC
.fbbd	20 ae fb	jsr $fbae				JSR	GETCHAR			; Wait for "S" to start a new record
.fbc0	c9 53		cmp #$53				CMP	#'S'
.fbc2	d0 f9		bne $fbbd				BNE	SYNC
.fbc4	a9 40		lda #$40				LDA	#'@'
.fbc6	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fbc9	20 ae fb	jsr $fbae				JSR	GETCHAR
.fbcc	85 e0		sta $e0					STA	REC_TYPE
.fbce	20 0f fd	jsr $fd0f				JSR	GETHEX			; Get message length byte
.fbd1	85 ee		sta $ee					STA	DATA_CNT		; Save number of bytes in record
.fbd3	a5 e0		lda $e0					LDA	REC_TYPE		; Decode and dispatch
.fbd5	f0 23		beq $fbfa				BEQ	GETREMS			; read the comment block
.fbd7	c9 31		cmp #$31				CMP	#'1'
.fbd9	f0 3e		beq $fc19				BEQ	GET16ADDR
.fbdb	c9 32		cmp #$32				CMP	#'2'
.fbdd	f0 27		beq $fc06				BEQ	GET24ADDR
.fbdf	c9 35		cmp #$35				CMP	#'5'
.fbe1	d0 02		bne $fbe5				BNE	SLC4
.fbe3	80 64		bra $fc49				BRA	CNT16
.fbe5					SLC4
.fbe5	c9 36		cmp #$36				CMP	#'6'
.fbe7	d0 02		bne $fbeb				BNE	SLC2
.fbe9	80 67		bra $fc52				BRA	CNT24
.fbeb					SLC2
.fbeb	c9 38		cmp #$38				CMP	#'8'
.fbed	d0 03		bne $fbf2				BNE	SLC1
.fbef	82 85 00	brl $fc77				BRL	SA24			; Too far for relative branch
.fbf2					SLC1
.fbf2	c9 39		cmp #$39				CMP	#'9'
.fbf4	d0 02		bne $fbf8				BNE	SLC3
.fbf6	80 76		bra $fc6e				BRA	SA16
.fbf8					SLC3
.fbf8	80 c3		bra $fbbd				BRA	SYNC
.fbfa					GETREMS
.fbfa	a9 30		lda #$30				LDA	#'0'
.fbfc	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fbff	a9 23		lda #$23				LDA	#'#'
.fc01	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fc04	80 b7		bra $fbbd				BRA	SYNC
.fc06					GET24ADDR
.fc06	a9 32		lda #$32				LDA	#'2'
.fc08	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fc0b	a5 ee		lda $ee					LDA	DATA_CNT
.fc0d	38		sec					SEC
.fc0e	e9 04		sbc #$04				SBC	#4			; Data length -= 3 bytes address + 1 byte checksum
.fc10	85 ee		sta $ee					STA	DATA_CNT		; Adjust data count to include only payload data bytes
.fc12	20 0f fd	jsr $fd0f				JSR	GETHEX
.fc15	85 e4		sta $e4					STA	PTR_B
.fc17	80 0e		bra $fc27				BRA	GET1624
.fc19					GET16ADDR
.fc19	a9 31		lda #$31				LDA	#'1'
.fc1b	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fc1e	a5 ee		lda $ee					LDA	DATA_CNT
.fc20	38		sec					SEC
.fc21	e9 03		sbc #$03				SBC	#3			; Data length -= 2 bytes address + 1 byte checksum
.fc23	85 ee		sta $ee					STA	DATA_CNT		; Adjust data count to include only payload data bytes
.fc25	64 e4		stz $e4					STZ	PTR_B			; 16 bit records.  Default Bank to 0!  (0+! NOT 0!=1)
.fc27					GET1624
.fc27	20 0f fd	jsr $fd0f				JSR	GETHEX			; Got bank value (or set to 0). Now get high and low address
.fc2a	85 e3		sta $e3					STA	PTR_H
.fc2c	20 0f fd	jsr $fd0f				JSR	GETHEX
.fc2f	85 e2		sta $e2					STA	PTR_L
.fc31					SAVDAT:
.fc31	a5 ee		lda $ee					LDA	DATA_CNT		; A record can have 0 data bytes, theoretically. So check at top
.fc33	f0 0c		beq $fc41				BEQ	SAVDX1			; No more data to PARSELINE
.fc35					SAVDAT2
.fc35	20 0f fd	jsr $fd0f				JSR	GETHEX
.fc38	87 e2		sta [$e2]				STA	[PTR]			; 24 bit indirect save
.fc3a	20 98 fc	jsr $fc98				JSR	INC_PTR			; Point to next byte
.fc3d	c6 ee		dec $ee					DEC	DATA_CNT
.fc3f	d0 f4		bne $fc35				BNE	SAVDAT2
.fc41					SAVDX1
.fc41	a9 23		lda #$23				LDA	#'#'
.fc43	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fc46	82 74 ff	brl $fbbd				BRL	SYNC			; FIXME: parse the checksum and end of line
.fc49					CNT16
.fc49	a9 35		lda #$35				LDA	#'5'
.fc4b	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fc4e	64 e7		stz $e7					STZ	CTR_B
.fc50	80 0a		bra $fc5c				BRA	CN16C1
.fc52					CNT24:
.fc52	a9 36		lda #$36				LDA	#'6'
.fc54	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fc57	20 0f fd	jsr $fd0f				JSR	GETHEX
.fc5a	85 e7		sta $e7					STA	CTR_B
.fc5c					CN16C1
.fc5c	20 0f fd	jsr $fd0f				JSR	GETHEX			; bits 15-8
.fc5f	85 e6		sta $e6					STA	CTR_H
.fc61	20 0f fd	jsr $fd0f				JSR	GETHEX			; bits 7-0
.fc64	85 e5		sta $e5					STA	CTR_L
.fc66	a9 23		lda #$23				LDA	#'#'
.fc68	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fc6b	82 4f ff	brl $fbbd				BRL	SYNC			; FIXME: parse the rest of the record & end of line
.fc6e					SA16
.fc6e	a9 39		lda #$39				LDA	#'9'
.fc70	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fc73	64 ea		stz $ea					STZ	SA_B
.fc75	80 0a		bra $fc81				BRA	SA16C1
.fc77					SA24
.fc77	a9 38		lda #$38				LDA	#'8'
.fc79	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fc7c	20 0f fd	jsr $fd0f				JSR	GETHEX			; length byte
.fc7f	64 ea		stz $ea					STZ	SA_B
.fc81					SA16C1
.fc81	20 0f fd	jsr $fd0f				JSR	GETHEX			; bits 15-8
.fc84	85 e9		sta $e9					STA	SA_H
.fc86	20 0f fd	jsr $fd0f				JSR	GETHEX			; bits 7-0
.fc89	85 e8		sta $e8					STA	SA_L
.fc8b	a9 26		lda #$26				LDA	#'&'
.fc8d	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fc90					GOEOL
.fc90	20 ae fb	jsr $fbae				JSR	GETCHAR
.fc93	c9 0d		cmp #$0d				CMP	#CR
.fc95	d0 f9		bne $fc90				BNE	GOEOL
.fc97	60		rts					RTS
.fc98					INC_PTR
.fc98	e6 e2		inc $e2					INC	PTR_L			; point to the next byte to save to
.fc9a	d0 06		bne $fca2				BNE	INCPX1
.fc9c	e6 e3		inc $e3					INC	PTR_H
.fc9e	d0 02		bne $fca2				BNE	INCPX1
.fca0	e6 e4		inc $e4					INC	PTR_B
.fca2					INCPX1
.fca2	60		rts					RTS
.fca3					RDHEX8
.fca3	5a		phy					PHY
.fca4	ac 04 05	ldy $0504				LDY	PRM_SA			; Start at beginning of current parameter
.fca7					RDHX8L1
.fca7	b9 00 00	lda $0000,y				LDA	0,Y			; Get MSB from *(parameter)
.fcaa	c8		iny					INY				; advance to (hopefully) ASCII LSB
.fcab	c9 3a		cmp #$3a				CMP	#':'			; Kludgey special handling for ':'
.fcad	f0 f8		beq $fca7				BEQ	RDHX8L1
.fcaf					RDHX8C1
.fcaf	20 73 fd	jsr $fd73				JSR	MKNIBL
.fcb2	0a		asl a					ASL	A			; Note: MKNIBL ANDs off higher 4 bits, so no '1' sign extension can occur
.fcb3	0a		asl a					ASL	A
.fcb4	0a		asl a					ASL	A
.fcb5	0a		asl a					ASL	A			; shift left 4 because upper nibble
.fcb6	85 f1		sta $f1					STA	HEXASSY			; temporary storage.  Only used within this function. Can re-use in any foreground context.
.fcb8					RDHX8L2
.fcb8	b9 00 00	lda $0000,y				LDA	0,Y			; Get LSB *(parameter+1)
.fcbb	c8		iny					INY				; point to next ASCII hex byte (if any)
.fcbc	c9 3a		cmp #$3a				CMP	#':'
.fcbe	f0 f8		beq $fcb8				BEQ	RDHX8L2			; Anti-metamucel (ignore colons) Note pathological buffer with all ':' is possible.  We will tolerate.
.fcc0	8c 04 05	sty $0504				STY	PRM_SA			;	"
.fcc3	20 73 fd	jsr $fd73				JSR	MKNIBL
.fcc6	05 f1		ora $f1					ORA	HEXASSY			; Assemble the parts
.fcc8	7a		ply					PLY
.fcc9	60		rts					RTS				; return the byte in A
.fcca					CONVHEX
.fcca	9c 0b 05	stz $050b				STZ	HEXIO_B			; Only write bytes explicitly set in buffer parameter string, else 0
.fccd	9c 0a 05	stz $050a				STZ	HEXIO_H
.fcd0	9c 09 05	stz $0509				STZ	HEXIO_L
.fcd3	ad 06 05	lda $0506				LDA	PRM_SIZ			; 24 bit cases are "00:1234" or "001234", 16 bit is "1234", 8 bit is "2A"
.fcd6	c9 02		cmp #$02				CMP	#2			; See if not even 8 bits (must be two digits to qualify as a hex value by fiat)
.fcd8	90 34		bcc $fd0e				BCC	CVHKWIT			; Too short to be a valid hex parameter.  Must be 2 or more characters
.fcda	c9 03		cmp #$03				CMP	#3
.fcdc	b0 08		bcs $fce6				BCS	CHXCHK16
.fcde	20 a3 fc	jsr $fca3				JSR	RDHEX8
.fce1	8d 09 05	sta $0509				STA	HEXIO_L
.fce4	80 28		bra $fd0e				BRA	CVHKWIT
.fce6					CHXCHK16
.fce6	c9 05		cmp #$05				CMP	#5
.fce8	b0 0e		bcs $fcf8				BCS	CHXCHK24
.fcea	20 a3 fc	jsr $fca3				JSR	RDHEX8
.fced	8d 0a 05	sta $050a				STA	HEXIO_H
.fcf0	20 a3 fc	jsr $fca3				JSR	RDHEX8
.fcf3	8d 09 05	sta $0509				STA	HEXIO_L
.fcf6	80 16		bra $fd0e				BRA	CVHKWIT
.fcf8					CHXCHK24
.fcf8	c9 08		cmp #$08				CMP	#8
.fcfa	b0 12		bcs $fd0e				BCS	CVHKWIT			; Give up if >= 8 characters!
.fcfc	20 a3 fc	jsr $fca3				JSR	RDHEX8
.fcff	8d 0b 05	sta $050b				STA	HEXIO_B
.fd02	20 a3 fc	jsr $fca3				JSR	RDHEX8
.fd05	8d 0a 05	sta $050a				STA	HEXIO_H
.fd08	20 a3 fc	jsr $fca3				JSR	RDHEX8
.fd0b	8d 09 05	sta $0509				STA	HEXIO_L
.fd0e					CVHKWIT
.fd0e	60		rts					RTS
.fd0f					GETHEX
.fd0f	20 ae fb	jsr $fbae				JSR 	GETCHAR
.fd12	c9 03		cmp #$03				CMP	#CTRL_C
.fd14	d0 0b		bne $fd21				BNE	GHECC1
.fd16	a9 5e		lda #$5e				LDA	#'^'
.fd18	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fd1b	a9 43		lda #$43				LDA	#'C'
.fd1d	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fd20	60		rts		       		RTS				; bail
.fd21					GHECC1
.fd21	20 73 fd	jsr $fd73				JSR     MKNIBL  		; Convert to 0..F numeric
.fd24	0a		asl a					ASL     A
.fd25	0a		asl a					ASL     A
.fd26	0a		asl a					ASL     A
.fd27	0a		asl a					ASL     A       		; This is the upper nibble
.fd28	29 f0		and #$f0				AND     #$F0
.fd2a	85 f0		sta $f0					STA     SUBTEMP
.fd2c	20 ae fb	jsr $fbae				JSR     GETCHAR
.fd2f	c9 03		cmp #$03				CMP	#CTRL_C
.fd31	d0 0b		bne $fd3e				BNE	GHECC2
.fd33	a9 5e		lda #$5e				LDA	#'^'
.fd35	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fd38	a9 43		lda #$43				LDA	#'C'
.fd3a	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fd3d	60		rts					RTS				; bail
.fd3e					GHECC2
.fd3e	20 73 fd	jsr $fd73				JSR     MKNIBL
.fd41	05 f0		ora $f0		        		ORA    	SUBTEMP
.fd43	60		rts		        		RTS
.fd44					PUTHEX24:
.fd44	ad 0b 05	lda $050b				LDA	HEXIO_B
.fd47	20 5c fd	jsr $fd5c				JSR	PUTHEXA
.fd4a	a9 3a		lda #$3a				LDA	#':'
.fd4c	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fd4f					PUTHEX16:
.fd4f	ad 0a 05	lda $050a				LDA	HEXIO_H
.fd52	20 5c fd	jsr $fd5c				JSR	PUTHEXA
.fd55					PUTHEX8:
.fd55	ad 09 05	lda $0509				LDA	HEXIO_L
.fd58	20 5c fd	jsr $fd5c				JSR	PUTHEXA
.fd5b	60		rts					RTS
.fd5c					PUTHEXA
.fd5c	48		pha					PHA             	;
.fd5d	4a		lsr a		        		LSR 	A
.fd5e	4a		lsr a		        		LSR 	A
.fd5f	4a		lsr a					LSR 	A
.fd60	4a		lsr a					LSR 	A
.fd61	20 65 fd	jsr $fd65	        		JSR     PRNIBL
.fd64	68		pla		        		PLA
.fd65					PRNIBL
.fd65	29 0f		and #$0f				AND     #$0F    	; strip off the low nibble
.fd67	c9 0a		cmp #$0a	       		 	CMP     #$0A
.fd69	90 02		bcc $fd6d	       		 	BCC  	NOTHEX  	; if it's 0-9, add '0' else also add 7
.fd6b	69 06		adc #$06	       		 	ADC     #6      	; Add 7 (6+carry=1), result will be carry clear
.fd6d					NOTHEX
.fd6d	69 30		adc #$30				ADC     #'0'    	; If carry clear, we're 0-9
.fd6f					PUTCH
.fd6f	20 8f fb	jsr $fb8f				JSR	PUTCHAR
.fd72	60		rts					RTS
.fd73					MKNIBL
.fd73	c9 3a		cmp #$3a				CMP     #'9'+1  	; See if it's 0-9 or 'A'..'F' (no lowercase yet)
.fd75	90 02		bcc $fd79	 		    BCC     MKNNH   	; If we borrowed, we lost the carry so 0..9
.fd77	e9 08		sbc #$08	        		SBC     #7+1    	; Subtract off extra 7 (sbc subtracts off one less)
.fd79					MKNNH
.fd79	e9 2f		sbc #$2f				SBC     #'0'-1  	; subtract off '0' (if carry clear coming in)
.fd7b	29 0f		and #$0f	        		AND     #$0F    	; no upper nibble no matter what
.fd7d	60		rts		        		RTS             	; and return the nibble
=$1e					SCTL_V  = %00011110       ; 9600 baud, 8 bits, 1 stop bit, rxclock = txclock
=$0b					SCMD_V  = %00001011       ; No parity, no echo, no tx or rx IRQ (for now), DTR*
.fd7e					INIT_SER
.fd7e	a9 1e		lda #$1e				LDA     #SCTL_V 	; 9600,n,8,1.  rxclock = txclock
.fd80	8d 83 7f	sta $7f83				STA 	SCTL
.fd83	a9 0b		lda #$0b				LDA     #SCMD_V 	; No parity, no echo, no tx or rx IRQ (for now), DTR*
.fd85	8d 82 7f	sta $7f82				STA     SCMD
.fd88	60		rts					RTS
.fd89					GETSER
.fd89	ad 81 7f	lda $7f81				LDA	SSR
.fd8c	29 08		and #$08				AND	#RX_RDY
.fd8e	f0 f9		beq $fd89				BEQ	GETSER
.fd90	ad 80 7f	lda $7f80				LDA	SDR
.fd93	18		clc					CLC			; Temporary compatibility return value for blocking/non-blocking
.fd94	60		rts					RTS
.fd95					PUTSER
.fd95	48		pha					PHA
.fd96	8d 80 7f	sta $7f80				STA	SDR
.fd99	20 b6 f9	jsr $f9b6				JSR	TXCHDLY		; Awful kludge
.fd9c	68		pla					PLA
.fd9d	18		clc					CLC			; Temporary compatibility return value for integration for blocking/non-blocking
.fd9e	60		rts					RTS
.fd9f					MONTBL
>fd9f	6f fb							.word 	CMD_A		; Index 0 = "A"
>fda1	6f fb							.word	CMD_B
>fda3	6f fb							.word	CMD_C
>fda5	6f fb							.word	CMD_D
>fda7	6f fb							.word	CMD_E
>fda9	6f fb							.word	CMD_F
>fdab	23 fb							.word	CMD_GO
>fdad	6f fb							.word	CMD_H
>fdaf	6f fb							.word	CMD_I
>fdb1	23 fb							.word	CMD_GO
>fdb3	6f fb							.word	CMD_K
>fdb5	19 fb							.word	CMD_LOAD
>fdb7	6f fb							.word	CMD_M
>fdb9	6f fb							.word	CMD_N
>fdbb	6f fb							.word	CMD_O
>fdbd	6f fb							.word	CMD_P
>fdbf	6f fb							.word	CMD_Q
>fdc1	ea f9							.word	CMD_DUMPHEX
>fdc3	6f fb							.word	CMD_S
>fdc5	6f fb							.word	CMD_T
>fdc7	6f fb							.word	CMD_U
>fdc9	6f fb							.word	CMD_V
>fdcb	af fa							.word	CMD_WRITEBYTES
>fdcd	6f fb							.word	CMD_X
>fdcf	6f fb							.word	CMD_Y
>fdd1	6f fb							.word	CMD_Z
.f000					MSG_UNIMPLEMENTED
>f000	0d 55 6e 69 6d 70 6c 65				.text	CR,"Unimplemented instruction",CR
>f008	6d 65 6e 74 65 64 20 69 6e 73 74 72 75 63 74 69
>f018	6f 6e 0d
>f01b	00						.text	0
.f01c					MSG_6HEX
>f01c	0d 45 6e 74 65 72 20 36				.text	CR,"Enter 6 digit hex address:",0
>f024	20 64 69 67 69 74 20 68 65 78 20 61 64 64 72 65
>f034	73 73 3a 00
.f038					MSG_CONFIRM
>f038	0d 49 73 20 74 68 69 73				.text	CR,"Is this correct (Y/x)?:",0
>f040	20 63 6f 72 72 65 63 74 20 28 59 2f 78 29 3f 3a
>f050	00
.f051					QBFMSG
>f051	0d 0a 0d 0a					.text 		CR,LF,CR,LF
>f055	20 20 20 20 20 20 20 20				.text	"                  VCBmon v 1.00",CR,LF
>f05d	20 20 20 20 20 20 20 20 20 20 56 43 42 6d 6f 6e
>f06d	20 76 20 31 2e 30 30 0d 0a
>f076	20 20 20 20 20 20 20 20				.text 	"          ******************************",CR,LF
>f07e	20 20 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f08e	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f09e	0d 0a
>f0a0	20 20 20 20 20 20 20 20				.text 	"          *                            *",CR,LF
>f0a8	20 20 2a 20 20 20 20 20 20 20 20 20 20 20 20 20
>f0b8	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 2a
>f0c8	0d 0a
>f0ca	20 20 20 20 20 20 20 20				.text 	"          *    The Quick brown Dog     *",CR,LF
>f0d2	20 20 2a 20 20 20 20 54 68 65 20 51 75 69 63 6b
>f0e2	20 62 72 6f 77 6e 20 44 6f 67 20 20 20 20 20 2a
>f0f2	0d 0a
>f0f4	20 20 20 20 20 20 20 20				.text 	"          *  Jumps over the Lazy Fox!  *",CR,LF
>f0fc	20 20 2a 20 20 4a 75 6d 70 73 20 6f 76 65 72 20
>f10c	74 68 65 20 4c 61 7a 79 20 46 6f 78 21 20 20 2a
>f11c	0d 0a
>f11e	20 20 20 20 20 20 20 20				.text 	"          *                            *",CR,LF
>f126	20 20 2a 20 20 20 20 20 20 20 20 20 20 20 20 20
>f136	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 2a
>f146	0d 0a
>f148	20 20 20 20 20 20 20 20				.text 	"          ******************************",CR,LF
>f150	20 20 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f160	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f170	0d 0a
.f172					PROMPT
>f172	0d 0a						.text	CR,LF
>f174	20 20 20 20 20 20 20 20				.text	"        _,-=._              /|_/|",CR,LF
>f17c	5f 2c 2d 3d 2e 5f 20 20 20 20 20 20 20 20 20 20
>f18c	20 20 20 20 2f 7c 5f 2f 7c 0d 0a
>f197	20 20 20 20 20 20 20 2a		 		.text	"       *-.}   `=._,.-=-._.,  @ @._,",CR,LF
>f19f	2d 2e 7d 20 20 20 60 3d 2e 5f 2c 2e 2d 3d 2d 2e
>f1af	5f 2e 2c 20 20 40 20 40 2e 5f 2c 0d 0a
>f1bc	20 20 20 20 20 20 20 20		 		.text   "          `._ _,-.   )      _,.-'",CR,LF
>f1c4	20 20 60 2e 5f 20 5f 2c 2d 2e 20 20 20 29 20 20
>f1d4	20 20 20 20 5f 2c 2e 2d 27 0d 0a
>f1df	20 20 20 20 20 20 20 20				 .text   "             `    G.m-'^m'm'",CR,CR,LF
>f1e7	20 20 20 20 20 60 20 20 20 20 47 2e 6d 2d 27 5e
>f1f7	6d 27 6d 27 0d 0d 0a
>f1fe	00				   		 .text	0
.f1ff					ANYKEY
>f1ff	0d 0a 0d 0a					.text	CR,LF,CR,LF
>f203	50 72 65 73 73 20 74 68				.text 	"Press the ANY key (CTRL-C) to return to monitor",CR
>f20b	65 20 41 4e 59 20 6b 65 79 20 28 43 54 52 4c 2d
>f21b	43 29 20 74 6f 20 72 65 74 75 72 6e 20 74 6f 20
>f22b	6d 6f 6e 69 74 6f 72 0d
>f233	65 6c 73 65 20 63 6f 6e				.text   "else continue foxing:"
>f23b	74 69 6e 75 65 20 66 6f 78 69 6e 67 3a
>f248	00						.text	0
.f249					MSG_LOAD
>f249	0d 53 45 4e 44 20 53 31				.text 	CR,"SEND S19 or S28 S-RECORD file:",CR,LF
>f251	39 20 6f 72 20 53 32 38 20 53 2d 52 45 43 4f 52
>f261	44 20 66 69 6c 65 3a 0d 0a
>f26a	00						.text 	0
.f26b					MSG_JUMP
>f26b	0d 4a 75 6d 70 69 6e 67				.text 	CR,"Jumping to address: $"
>f273	20 74 6f 20 61 64 64 72 65 73 73 3a 20 24
>f281	00						.text 	0
.ffe4					NCOP
>ffe4	00 f8						.word	START		; COP exception in native mode
.ffe6					NBRK
>ffe6	00 f8						.word	START		; BRK in native mode
.ffe8					NABORT
>ffe8	00 f8						.word	START
.ffea					NNMI
>ffea	00 f8						.word	START		; NMI interrupt in native mode
.ffee					NIRQ
>ffee	00 f8						.word	START
.fff4					ECOP
>fff4	00 f8						.word	START		; COP exception in 65c02 emulation mode
.fff8					EABORT
>fff8	00 f8						.word	START
.fffa					ENMI
>fffa	00 f8						.word	START		; NMI interrupt in 65c02 emulation mode
.fffc					ERESET
>fffc	00 f8						.word	START		; RESET exception in all modes
.fffe					EIRQ
>fffe	00 f8						.word	START

;******  End of listing
