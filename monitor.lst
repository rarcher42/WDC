
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -L monitor.lst --s-record -o monitor.hex monitor.asm
; Wed Jul 17 18:51:08 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: monitor.asm


;******  Processing file: via_symbols.inc

=$7fe0					SYS_VIA_BASE	    = 	$7FE0
=32736					SYSTEM_VIA_IORB     =  	SYS_VIA_BASE+0	; Port B IO register
=32737					SYSTEM_VIA_IORA     =	SYS_VIA_BASE+1 	; Port A IO register
=32738					SYSTEM_VIA_DDRB     = 	SYS_VIA_BASE+2	; Port B data direction register
=32739					SYSTEM_VIA_DDRA     = 	SYS_VIA_BASE+3	; Port A data direction register
=32740					SYSTEM_VIA_T1C_L    =	SYS_VIA_BASE+4 	; Timer 1 counter/latches, low-order
=32741					SYSTEM_VIA_T1C_H    = 	SYS_VIA_BASE+5	; Timer 1 high-order counter
=32742					SYSTEM_VIA_T1L_L    = 	SYS_VIA_BASE+6	; Timer 1 low-order latches
=32743					SYSTEM_VIA_T1L_H    = 	SYS_VIA_BASE+7	; Timer 1 high-order latches
=32744					SYSTEM_VIA_T2C_L    = 	SYS_VIA_BASE+8	; Timer 2 counter/latches, lower-order
=32745					SYSTEM_VIA_T2C_H    = 	SYS_VIA_BASE+9	; Timer 2 high-order counter
=32746					SYSTEM_VIA_SR       = 	SYS_VIA_BASE+10	; Shift register
=32747					SYSTEM_VIA_ACR      = 	SYS_VIA_BASE+11	; Auxilliary control register
=32748					SYSTEM_VIA_PCR      =	SYS_VIA_BASE+12	; Peripheral control register
=32749					SYSTEM_VIA_IFR	    =	SYS_VIA_BASE+13 ; Interrupt flag register
=32750					SYSTEM_VIA_IER      = 	SYS_VIA_BASE+14	; Interrupt enable register
=32751					SYSTEM_VIA_ORA_IRA  =	SYS_VIA_BASE+15	; Port A IO register, but no handshake
=$7fc0					DEBUG_VIA_BASE	    = 	$7FC0
=32704					DEBUG_VIA_IORB     =  	DEBUG_VIA_BASE+0	; Port B IO register
=32705					DEBUG_VIA_IORA     =	DEBUG_VIA_BASE+1 	; Port A IO register
=32706					DEBUG_VIA_DDRB     = 	DEBUG_VIA_BASE+2	; Port B data direction register
=32707					DEBUG_VIA_DDRA     = 	DEBUG_VIA_BASE+3	; Port A data direction register
=32708					DEBUG_VIA_T1C_L    =	DEBUG_VIA_BASE+4 	; Timer 1 counter/latches, low-order
=32709					DEBUG_VIA_T1C_H    = 	DEBUG_VIA_BASE+5	; Timer 1 high-order counter
=32710					DEBUG_VIA_T1L_L    = 	DEBUG_VIA_BASE+6	; Timer 1 low-order latches
=32711					DEBUG_VIA_T1L_H    = 	DEBUG_VIA_BASE+7	; Timer 1 high-order latches
=32712					DEBUG_VIA_T2C_L    = 	DEBUG_VIA_BASE+8	; Timer 2 counter/latches, lower-order
=32713					DEBUG_VIA_T2C_H    = 	DEBUG_VIA_BASE+9	; Timer 2 high-order counter
=32714					DEBUG_VIA_SR       = 	DEBUG_VIA_BASE+10	; Shift register
=32715					DEBUG_VIA_ACR      = 	DEBUG_VIA_BASE+11	; Auxilliary control register
=32716					DEBUG_VIA_PCR      =	DEBUG_VIA_BASE+12	; Peripheral control register
=32717					DEBUG_VIA_IFR	    =	DEBUG_VIA_BASE+13 ; Interrupt flag register
=32718					DEBUG_VIA_IER      = 	DEBUG_VIA_BASE+14	; Interrupt enable register
=32719					DEBUG_VIA_ORA_IRA  =	DEBUG_VIA_BASE+15	; Port A IO register, but no handshake
=$01					PB0 = MASK0
=$02					PB1 = MASK1
=$04					PB2 = MASK2
=$08					PB3 = MASK3
=$10					PB4 = MASK4
=$20					PB5 = MASK5
=$40					PB6 = MASK6
=$80					PB7 = MASK7
=$01					PA0 = MASK0
=$02					PA1 = MASK1
=$04					PA2 = MASK2
=$08					PA3 = MASK3
=$10					PA4 = MASK4
=$20					PA5 = MASK5
=$40					PA6 = MASK6
=$80					PA7 = MASK7

;******  Return to file: monitor.asm


;******  Processing file: acia_symbols.inc

=$7f80					ACIA_BASE = $7F80		; This is where the 6551 ACIA starts
=$7f80					ACIA_SDR = ACIA_BASE       		; RX'ed bytes read, TX bytes written, here
=32641					ACIA_SSR = ACIA_BASE+1     		; Serial data status register
=32642					ACIA_SCMD = ACIA_BASE+2     		; Serial command reg. ()
=32643					ACIA_SCTL = ACIA_BASE+3     		; Serial control reg. ()
=$10					TX_RDY = MASK4
=$08					RX_RDY = MASK3

;******  Return to file: monitor.asm

=$03					CTRL_C		= $03
=$08					BS		= $08
=$0a					LF		= $0A
=$0d					CR		= $0D
=$20					SP		= $20
=$7f					DEL    		 = $7F
=$01					MASK0		= %00000001
=$02					MASK1		= %00000010
=$04					MASK2		= %00000100
=$08					MASK3		= %00001000
=$10					MASK4		= %00010000
=$20					MASK5		= %00100000
=$40					MASK6 		= %01000000
=$80					MASK7		= %10000000
=$80					N_FLAG		= MASK7
=$40					V_FLAG		= MASK6
=$20					M_FLAG		= MASK5
=$10					X_FLAG		= MASK4
=$08					D_FLAG		= MASK3
=$04					I_FLAG		= MASK2
=$02					Z_FLAG		= MASK1
=$01					C_FLAG		= MASK0
>00e0					REC_TYPE	.byte 	?
>00e1					PTR_L		.byte	?	; Generic pointer
>00e2					PTR_H		.byte	?
>00e3					PTR_B		.byte	?
=$e1					PTR			=		PTR_L
>00e4					CTR_L		.byte	?	; Counter
>00e5					CTR_H		.byte	?
>00e6					CTR_B		.byte	?
=$e4					CTR			= 		CTR_L
>00e7					SA_L		.byte 	?	; Starting address storage for various commands & loader
>00e8					SA_H		.byte 	?
>00e9					SA_B		.byte	?
=$e7					SA			=		SA_L
>00ea					EA_L		.byte 	?	; Starting address storage for various commands
>00eb					EA_H		.byte 	?
>00ec					EA_B		.byte	?
=$ea					EA			=		EA_L
>00ed					DATA_CNT	.byte 	?	; Count of record's actual storable data bytes
>00ee					FIFO_PIT	.byte	?
>00ef					SUBTEMP 	.byte	?	; Any subroutine that doesn't call others can use as local scratchpad space
>00f0					HEXASSY		.byte	?
>00f1					SRC		.byte	?	; Where did the last character come from?
>0400					CMDBUF 		.fill	256	; can be smaller than 256 but must not cross 8 bit page boundary
>0500					CB_RDPTR	.word	?	; Use LDA/STA 0,X typically
>0502					CB_WRPTR	.word 	?	; Use LAD/STA 0,Y typically
>0504					PRM_SA	.word	?		; Parameter start address
>0506					PRM_SIZ	.byte	?		; Size of current parameter
>0507					EOLFLAG	.byte	?		; 0 = EOL not found, !0 = EOL has been encountered
>0508					BYTECNT	.byte 	?
>0509					HEXIO_L	.byte	?
>050a					HEXIO_H	.byte	?
>050b					HEXIO_B	.byte	?
=$0509					HEXIO		=	HEXIO_L				; 24 bit HEX value to print
=$7eff					STACKTOP	=	$7EFF				; Top of RAM = $07EFF (I/O is $7F00-$7FFF)
.f800					START
.f800	78		sei					SEI
.f801	18		clc					CLC
.f802	fb		xce					XCE
.f803	c2 18		rep #$18				REP	#(X_FLAG | D_FLAG)
.f805	e2 20		sep #$20				SEP	#M_FLAG
.f807	a2 ff 7e	ldx #$7eff				LDX	#STACKTOP
.f80a	9a		txs					TXS
.f80b	20 f0 f9	jsr $f9f0				JSR	INIT_FIFO
.f80e	20 75 f9	jsr $f975				JSR	INIT_SER
.f811	64 f1		stz $f1					STZ	SRC			; First send to FIFO
.f813	a0 51 f0	ldy #$f051				LDY	#QBFMSG			; Start of monitor loop
.f816	20 6e f8	jsr $f86e				JSR	PUT_STR
.f819	a9 01		lda #$01				LDA	#1
.f81b	85 f1		sta $f1					STA	SRC
.f81d	a0 51 f0	ldy #$f051				LDY	#QBFMSG
.f820	20 6e f8	jsr $f86e				JSR	PUT_STR			; Send out serial port too
.f823					MONGETL
.f823	20 11 fc	jsr $fc11				JSR	CRLF			; FIXME: send command prompt to both ports
.f826	a9 3e		lda #$3e				LDA	#'>'			; Should have flag for "both ports", probably.
.f828	20 4f f8	jsr $f84f				JSR	PUTCHAR			; But as RS232 is so very slow, let's not force too much down this narrow pipe
.f82b	64 f1		stz $f1					STZ	SRC
.f82d	20 11 fc	jsr $fc11				JSR	CRLF
.f830	a9 3e		lda #$3e				LDA	#'>'
.f832	20 4f f8	jsr $f84f				JSR	PUTCHAR
.f835	20 15 f9	jsr $f915				JSR	GETLINE
.f838	20 a0 f8	jsr $f8a0				JSR	PARSELINE
.f83b	80 e6		bra $f823				BRA	MONGETL			; End of monitor loop
.f83d					GETCHAR
.f83d	64 f1		stz $f1					STZ	SRC			; Assume SRC=FIFO
.f83f					GETCH_C1
.f83f	20 42 fa	jsr $fa42				JSR 	GET_FRAW		; Check FIFO.  Anything waiting?
.f842	90 07		bcc $f84b				BCC	GETC_X1			; Yes, return it
.f844	20 a6 f9	jsr $f9a6				JSR	GETSER_RAW
.f847	b0 f6		bcs $f83f				BCS	GETCH_C1
.f849	e6 f1		inc $f1					INC	SRC			; SRC = 1 means async serial
.f84b	20 6a f9	jsr $f96a	GETC_X1			JSR	TOPUPPER		; Make alphabetics Puppercase
.f84e	60		rts					RTS
.f84f					PUTCHAR
.f84f	48		pha					PHA
.f850	a5 f1		lda $f1					LDA	SRC
.f852	d0 06		bne $f85a				BNE	PUTCHAR_C2
.f854	68		pla					PLA
.f855	20 c0 f9	jsr $f9c0				JSR	PUT_FIFO
.f858	80 04		bra $f85e				BRA	PUTCHAR_X1
.f85a					PUTCHAR_C2
.f85a	68		pla					PLA
.f85b	20 9a f9	jsr $f99a				JSR	PUT_SER
.f85e					PUTCHAR_X1
.f85e	60		rts					RTS
.f85f					PUTCHARTR
.f85f	c9 20		cmp #$20				CMP	#$20
.f861	b0 ec		bcs $f84f				BCS	PUTCHAR
.f863	48		pha					PHA					; Display as hex value
.f864	a9 5c		lda #$5c				LDA	#'\'
.f866	20 4f f8	jsr $f84f				JSR	PUTCHAR
.f869	68		pla					PLA
.f86a	20 cc fd	jsr $fdcc				JSR	PUTHEXA
.f86d					PUTCRX1
.f86d	60		rts					RTS
.f86e					PUT_STR
.f86e	b9 00 00	lda $0000,y				LDA	0,Y				; Y points directly to string
.f871	f0 06		beq $f879				BEQ	PUTSX
.f873	20 4f f8	jsr $f84f				JSR	PUTCHAR
.f876	c8		iny					INY					; point to next character
.f877	80 f5		bra $f86e				BRA	PUT_STR
.f879					PUTSX
.f879	60		rts					RTS
.f87a					PUT_STR_CTRL
.f87a	b9 00 00	lda $0000,y				LDA	0,Y				; Y points directly to string
.f87d	f0 06		beq $f885				BEQ	PUTSRX
.f87f	20 5f f8	jsr $f85f				JSR	PUTCHARTR			; Show control characters, etc.
.f882	c8		iny					INY					; point to next character
.f883	80 f5		bra $f87a				BRA	PUT_STR_CTRL
.f885					PUTSRX
.f885	60		rts					RTS
.f886					INITPARS
.f886	9c 06 05	stz $0506				STZ	PRM_SIZ			; No known parameter size
.f889	9c 07 05	stz $0507				STZ	EOLFLAG			; No EOL found yet
.f88c	a2 00 04	ldx #$0400				LDX	#CMDBUF
.f88f	8e 00 05	stx $0500				STX	CB_RDPTR		; Start read pointer at start of command buffer
.f892	8e 04 05	stx $0504				STX	PRM_SA			; First parameter starts at command buffer[0]
.f895	60		rts					RTS
.f896					CLRCMD
.f896	a2 00 04	ldx #$0400				LDX	#CMDBUF			; Point CB_WRPTR to start of command buffer
.f899	8e 02 05	stx $0502				STX	CB_WRPTR
.f89c	9c 00 04	stz $0400				STZ	CMDBUF			; Null terminate the empty buffer
.f89f	60		rts					RTS
.f8a0					PARSELINE
.f8a0	20 86 f8	jsr $f886				JSR	INITPARS
.f8a3					FINDCMD
.f8a3	20 cc f8	jsr $f8cc				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.f8a6	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.f8a9	d0 20		bne $f8cb				BNE	PLIX2			; We hit an EOL before an actionable character, so quit
.f8ab	a9 00		lda #$00				LDA	#0
.f8ad	eb		xba					XBA				; Make B zero so when TAX times comes, MSB of X will be 0! (0 emphasis not 0 factorial)
.f8ae	ae 00 05	ldx $0500				LDX	CB_RDPTR		; point to command byte
.f8b1	b5 00		lda $00,x				LDA	0,X			; Get command byte
.f8b3	e8		inx					INX				; Point past the command byte to save each subroutine from doing this
.f8b4	8e 00 05	stx $0500				STX	CB_RDPTR		; "
.f8b7	c9 41		cmp #$41				CMP	#'A'
.f8b9	90 0d		bcc $f8c8				BCC	PLERRXIT		; < 'A', so not a command
.f8bb	c9 5b		cmp #$5b				CMP	#'Z'+1
.f8bd	b0 09		bcs $f8c8				BCS	PLERRXIT		; > 'Z', so not a command
.f8bf	e9 40		sbc #$40				SBC	#'A'-1			; Carry clear, so subtract one less to account for borrow
.f8c1	0a		asl a					ASL	A			; Two bytes per JSR table entry
.f8c2	aa		tax					TAX						; X now holds offset in MONTABLE
.f8c3	fc ee fd	jsr ($fdee,x)				JSR	(MONTBL,X)		; No JSR indirect indexed.  Each table entry MUST end in RTS not RTL!
.f8c6	80 03		bra $f8cb				BRA	PLIX2			; We're done dispatching.
.f8c8					PLERRXIT:
.f8c8	20 00 fc	jsr $fc00				JSR	LOLWUT			; Print non-understood buffer plus ?[CR][LF]
.f8cb					PLIX2
.f8cb	60		rts					RTS
.f8cc					FINDSTART
.f8cc	ac 00 05	ldy $0500				LDY	CB_RDPTR
.f8cf					FSN1
.f8cf	b9 00 00	lda $0000,y				LDA	0,Y			; Get next character
.f8d2	f0 0f		beq $f8e3				BEQ	FSEOL			; Null --> End of line encountered.  We are done
.f8d4	c9 0d		cmp #$0d				CMP	#CR
.f8d6	f0 0b		beq $f8e3				BEQ	FSEOL			; CR = end of line also
.f8d8	c9 03		cmp #$03				CMP	#CTRL_C
.f8da	f0 07		beq $f8e3				BEQ	FSEOL			; CTRL-C = end of line
.f8dc	c9 21		cmp #$21				CMP	#SP+1			; if space or less, and not CR or CTRL-C, skip over
.f8de	b0 08		bcs $f8e8				BCS	FSDUN			; A non-whitespace character.  We're done looking
.f8e0	c8		iny					INY				; Keep looking for a valid parameter byte
.f8e1	80 ec		bra $f8cf				BRA	FSN1			; Next character
.f8e3					FSEOL
.f8e3	a9 01		lda #$01				LDA	#1
.f8e5	8d 07 05	sta $0507				STA	EOLFLAG
.f8e8					FSDUN
.f8e8	8c 00 05	sty $0500				STY	CB_RDPTR		; Save pointers by current value of Y
.f8eb	8c 04 05	sty $0504				STY	PRM_SA			; Save pointers by current value of Y
.f8ee	60		rts					RTS
.f8ef					FINDEND
.f8ef	9c 06 05	stz $0506				STZ	PRM_SIZ			; No known parameter bytes yet
.f8f2	ac 00 05	ldy $0500				LDY	CB_RDPTR
.f8f5					FEN1
.f8f5	b9 00 00	lda $0000,y				LDA	0,Y			; Get next character
.f8f8	f0 12		beq $f90c				BEQ	FEEOL			; Null --> End of line encountered.  We are done
.f8fa	c9 0d		cmp #$0d				CMP	#CR
.f8fc	f0 0e		beq $f90c				BEQ	FEEOL			; CR = end of line also
.f8fe	c9 03		cmp #$03				CMP	#CTRL_C
.f900	f0 0a		beq $f90c				BEQ	FEEOL			; CTRL-C = end of line
.f902	c9 21		cmp #$21				CMP	#SP+1			; if space or less, and not CR or CTRL-C,
.f904	90 0b		bcc $f911				BCC	FEDUN1			; A whitespace character.  We're done looking
.f906	c8		iny					INY
.f907	ee 06 05	inc $0506				INC	PRM_SIZ			; add one more to size of parameter
.f90a	80 e9		bra $f8f5				BRA	FEN1
.f90c					FEEOL
.f90c	a9 01		lda #$01				LDA	#1
.f90e	8d 07 05	sta $0507				STA	EOLFLAG
.f911					FEDUN1
.f911	8c 00 05	sty $0500				STY	CB_RDPTR		; Save pointers by current value of read pointer (don't update PRM_SA)
.f914	60		rts					RTS
.f915					GETLINE
.f915	20 96 f8	jsr $f896				JSR	CLRCMD
.f918					GLLP1
.f918	20 3d f8	jsr $f83d				JSR	GETCHAR				; Do not echo
.f91b	c9 0d		cmp #$0d				CMP	#CR
.f91d	d0 05		bne $f924				BNE	GLNC0
.f91f	20 4f f8	jsr $f84f				JSR	PUTCHAR
.f922	80 43		bra $f967				BRA	GLXIT1				; end of message
.f924					GLNC0
.f924	c9 03		cmp #$03				CMP	#CTRL_C
.f926	d0 14		bne $f93c				BNE	GLNC1
.f928	a9 5e		lda #$5e				LDA	#'^'
.f92a	20 4f f8	jsr $f84f				JSR	PUTCHAR
.f92d	a9 43		lda #$43				LDA	#'C'
.f92f	20 4f f8	jsr $f84f				JSR	PUTCHAR
.f932	a9 0d		lda #$0d				LDA	#CR
.f934	20 4f f8	jsr $f84f				JSR	PUTCHAR
.f937	20 96 f8	jsr $f896				JSR	CLRCMD				; zotch out any command in buffer
.f93a	80 2b		bra $f967				BRA	GLXIT1
.f93c					GLNC1
.f93c	c9 0a		cmp #$0a				CMP	#LF
.f93e	d0 02		bne $f942				BNE	GLNC2
.f940	80 d6		bra $f918				BRA	GLLP1
.f942					GLNC2
.f942	c9 08		cmp #$08				CMP	#BS				; We will not tolerate BS here
.f944	d0 16		bne $f95c				BNE	GLNC9
.f946	c9 7f		cmp #$7f				CMP	#DEL
.f948	d0 12		bne $f95c				BNE	GLNC9
.f94a	74 00		stz $00,x				STZ	0,X
.f94c	e0 00 04	cpx #$0400				CPX	#CMDBUF
.f94f	f0 c7		beq $f918				BEQ	GLLP1				; Already backed over the first character. No index to decrement
.f951	20 4f f8	jsr $f84f				JSR	PUTCHAR
.f954	ca		dex					DEX					; change buffer pointer
.f955	8e 02 05	stx $0502				STX	CB_WRPTR
.f958	74 00		stz $00,x				STZ	0,X				; Character we backed over is now end of string
.f95a	80 bc		bra $f918				BRA	GLLP1
.f95c					GLNC9
.f95c	95 00		sta $00,x				STA	0,X				; store it
.f95e	20 4f f8	jsr $f84f				JSR	PUTCHAR
.f961	e8		inx					INX
.f962	8e 02 05	stx $0502				STX	CB_WRPTR
.f965	80 b1		bra $f918				BRA	GLLP1
.f967					GLXIT1
.f967	74 00		stz $00,x				STZ	0,X				; null-terminate the line
.f969	60		rts					RTS
.f96a					TOPUPPER
.f96a	c9 61		cmp #$61				CMP	#'a'				; Make character PupperCase
.f96c	90 06		bcc $f974				BCC	PUPX1				; A < 'a' so can't be lowercase char
.f96e	c9 7b		cmp #$7b				CMP	#'z'+1
.f970	b0 02		bcs $f974				BCS	PUPX1				; A > 'z', so can't be lowercase char
.f972	e9 1f		sbc #$1f				SBC	#'a'-'A'-1			; Adjust upper case to lower case
.f974					PUPX1
.f974	60		rts					RTS
=9167					INTER_CHAR_DLY = 9167	; 8E6 cycles/sec * 11 bits/byte * 1 sec/ 9600 bits = 9167 cycles/byte
=$1e					SCTL_V  = %00011110       	; 9600 baud, 8 bits, 1 stop bit, rxclock = txclock
=$0b					SCMD_V  = %00001011       	; No parity, no echo, no tx or rx IRQ (for now), DTR*
.f975					INIT_SER
.f975	a9 1e		lda #$1e				LDA     #SCTL_V 		; 9600,n,8,1.  rxclock = txclock
.f977	8d 83 7f	sta $7f83				STA 	ACIA_SCTL
.f97a	a9 0b		lda #$0b				LDA     #SCMD_V 		; No parity, no echo, no tx or rx IRQ (for now), DTR*
.f97c	8d 82 7f	sta $7f82				STA     ACIA_SCMD
.f97f	a9 80		lda #$80				LDA     #$80			; Disable all VIA interrupts (not that CPU cares as yet if IRQB=0)
.f981	8d ee 7f	sta $7fee	                	STA     SYSTEM_VIA_IER
.f984	a9 20		lda #$20				LDA	#%00100000		; Put TIMER2 in timed mode
.f986	1c eb 7f	trb $7feb				TRB	SYSTEM_VIA_ACR
.f989	20 8d f9	jsr $f98d	               		JSR	SET_SERTMR          	; Delay initial char output one character time in case TX not empty
.f98c	60		rts					RTS
.f98d					SET_SERTMR
.f98d	48		pha					PHA
.f98e	a9 cf		lda #$cf				LDA     #<INTER_CHAR_DLY	; Load VIA T2 counter with
.f990	8d e8 7f	sta $7fe8	                	STA     SYSTEM_VIA_T2C_L        ; one byte output time
.f993	a9 23		lda #$23				LDA     #>INTER_CHAR_DLY
.f995	8d e9 7f	sta $7fe9	                	STA     SYSTEM_VIA_T2C_H
.f998	68		pla					PLA
.f999	60		rts					RTS
.f99a					PUT_SER
.f99a	20 b3 f9	jsr $f9b3				JSR	PUTSER_RAW
.f99d	b0 fb		bcs $f99a				BCS	PUT_SER
.f99f	60		rts					RTS
.f9a0					GET_SER
.f9a0	20 a6 f9	jsr $f9a6				JSR	GETSER_RAW
.f9a3	b0 fb		bcs $f9a0				BCS	GET_SER
.f9a5	60		rts					RTS
.f9a6					GETSER_RAW
.f9a6	ad 81 7f	lda $7f81				LDA	ACIA_SSR
.f9a9	29 08		and #$08				AND	#RX_RDY
.f9ab	38		sec					SEC
.f9ac	f0 04		beq $f9b2				BEQ	GETSER_X1
.f9ae	ad 80 7f	lda $7f80				LDA	ACIA_SDR
.f9b1	18		clc					CLC			; C=0 means A holds new received character
.f9b2					GETSER_X1
.f9b2	60		rts					RTS
.f9b3					PUTSER_RAW
.f9b3	48		pha					PHA
.f9b4	20 63 fa	jsr $fa63				JSR	TXCHDLY
.f9b7	68		pla					PLA
.f9b8	8d 80 7f	sta $7f80				STA	ACIA_SDR
.f9bb	18		clc					CLC					; C=0 means output was successful
.f9bc	80 01		bra $f9bf				BRA	PSR_X2				; and return it
.f9be					PSR_X1
.f9be	68		pla					PLA			; retore
.f9bf					PSR_X2
.f9bf	60		rts					RTS
=$01					FIFO_TXE = PB0
=$02					FIFO_RXF = PB1
=$04					FIFO_WR = PB2
=$08					FIFO_RD = PB3
=$20					FIFO_PWREN = PB5
=$80					FIFO_DEBUG = PB7		; Handy debug toggle output free for any use
.f9c0					PUT_FIFO
.f9c0	20 18 fa	jsr $fa18				JSR	PUT_FRAW
.f9c3	b0 fb		bcs $f9c0				BCS	PUT_FIFO
.f9c5	60		rts					RTS
.f9c6					GET_FIFO
.f9c6	20 42 fa	jsr $fa42				JSR 	GET_FRAW
.f9c9	b0 fb		bcs $f9c6				BCS	GET_FIFO
.f9cb	60		rts					RTS
.f9cc					SEL_BANK3
.f9cc	a9 ff		lda #$ff				LDA	#%11111111
.f9ce	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f9d1	60		rts					RTS
.f9d2					SEL_BANK2
.f9d2	a9 fd		lda #$fd				LDA	#%11111101
.f9d4	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f9d7	60		rts					RTS
.f9d8					SEL_BANK1
.f9d8	a9 df		lda #$df				LDA	#%11011111
.f9da	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f9dd	60		rts					RTS
.f9de					SEL_BANK0
.f9de	a9 dd		lda #$dd				LDA	#%11011101
.f9e0	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f9e3	60		rts					RTS
.f9e4					INIT_SYSVIA
.f9e4	a9 ff		lda #$ff				LDA	#$FF
.f9e6	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f9e9	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA
.f9ec	9c e2 7f	stz $7fe2				STZ	SYSTEM_VIA_DDRB
.f9ef	60		rts					RTS
.f9f0					INIT_FIFO
.f9f0	a9 ff		lda #$ff				LDA	#$FF
.f9f2	8d ec 7f	sta $7fec				STA 	SYSTEM_VIA_PCR			; CB2=FAMS=flash A16=1;  CA2=FA15=A15=1; Select flash Bank #3
.f9f5	9c eb 7f	stz $7feb				STZ 	SYSTEM_VIA_ACR			; Disable PB7, shift register, timer T1 interrupt.  Not absolutely required while interrupts are disabled FIXME: set up timer
.f9f8	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Set PA0-PA7 to all inputs
.f9fb	9c e2 7f	stz $7fe2				STZ	SYSTEM_VIA_DDRB			; In case we're not coming off a reset, make PORT B an input and change output register when it's NOT outputting
.f9fe	a9 08		lda #$08				LDA	#FIFO_RD				;
.fa00	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Avoid possible glitch by writing to output latch while Port B is still an input (after reset)
.fa03	a9 0c		lda #$0c				LDA	#(FIFO_RD + FIFO_WR)		; Make FIFO RD & WR pins outputs so we can strobe data in and out of the FIFO
.fa05	8d e2 7f	sta $7fe2				STA	SYSTEM_VIA_DDRB			; Port B: PB2 and PB3 are outputs; rest are inputs from earlier IORB write
.fa08	20 63 fa	jsr $fa63				JSR	TXCHDLY				; Should wait (with timeout!) on PWERENB signal going low on power up or after.
.fa0b	20 63 fa	jsr $fa63				JSR	TXCHDLY				; Timeout is essential in case board is powered off RS232 port,
.fa0e	20 63 fa	jsr $fa63				JSR	TXCHDLY				; in which case the FIFO will not get power and this pin will never be (active) low.
.fa11	20 63 fa	jsr $fa63				JSR	TXCHDLY
.fa14	20 63 fa	jsr $fa63				JSR	TXCHDLY
.fa17	60		rts					RTS
.fa18					PUT_FRAW
.fa18	85 ee		sta $ee					STA	FIFO_PIT
.fa1a	ad e0 7f	lda $7fe0				LDA	SYSTEM_VIA_IORB			; Read in FIFO status Port for FIFO
.fa1d	29 01		and #$01				AND	#FIFO_TXE				; If TXE is low, we can accept data into FIFO.  If high, return immmediately
.fa1f	38		sec					SEC							; FIFO is full, so don't try to queue it!
.fa20	d0 1d		bne $fa3f				BNE	OFX1					; 0 = OK to write to FIFO; 1 = Wait, FIFO full!
.fa22					OFCONT
.fa22	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; (Defensive) Start with Port A input/floating
.fa25	a9 0c		lda #$0c				LDA	#(FIFO_RD + FIFO_WR)	; RD=1 WR=1 (WR must go 1->0 for FIFO write)
.fa27	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Make sure write is high (and read too!)
.fa2a	a5 ee		lda $ee					LDA 	FIFO_PIT			; Restore the data to send
.fa2c	8d e1 7f	sta $7fe1				STA	SYSTEM_VIA_IORA			; Set up output value in advance in Port A (still input so doesn't go out yet)
.fa2f	a9 ff		lda #$ff				LDA	#$FF				; make Port A all outputs with stable output value already set in prior lines
.fa31	8d e3 7f	sta $7fe3				STA	SYSTEM_VIA_DDRA			; Save data to output latches
.fa34	ea		nop					NOP					; Some settling time of data output just to be safe
.fa35	a9 08		lda #$08				LDA	#(FIFO_RD)			; RD=1 WR=0 (WR1->0 transition triggers FIFO transfer!)
.fa37	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Low-going WR pulse should latch data
.fa3a	ea		nop					NOP							; Hold time following write strobe, to ensure value is latched OK
.fa3b	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Make port A an input again
.fa3e	18		clc					CLC					; signal success of write to caller
.fa3f					OFX1
.fa3f	a5 ee		lda $ee					LDA	FIFO_PIT
.fa41	60		rts					RTS
.fa42					GET_FRAW
.fa42	ad e0 7f	lda $7fe0				LDA	SYSTEM_VIA_IORB			; Check RXF flag
.fa45	29 02		and #$02				AND	#FIFO_RXF			; If clear, we're OK to read.  If set, there's no data waiting
.fa47	38		sec					SEC
.fa48	d0 18		bne $fa62				BNE 	INFXIT				; If RXF is 1, then no character is waiting!
.fa4a	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Make Port A inputs
.fa4d	a9 08		lda #$08				LDA	#FIFO_RD
.fa4f	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; RD=1 WR=0 (RD must go to 0 to read
.fa52	ea		nop					NOP
.fa53	9c e0 7f	stz $7fe0				STZ	SYSTEM_VIA_IORB			; RD=0 WR=0	- FIFO presents data to port A
.fa56	ea		nop					NOP
.fa57	ad e1 7f	lda $7fe1				LDA	SYSTEM_VIA_IORA			; read data in
.fa5a	48		pha					PHA
.fa5b	a9 08		lda #$08				LDA	#FIFO_RD			; Restore back to inactive signals RD=1 and WR=0
.fa5d	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB
.fa60	68		pla					PLA
.fa61	18		clc					CLC					; we got a byte!
.fa62					INFXIT
.fa62	60		rts					RTS
=$0940					TX_DLY_CYCLES = $0940						; Not tuned.  As it's temporary, optimum settings are unimportant.
.fa63					TXCHDLY
.fa63	5a		phy					PHY
.fa64	a0 40 09	ldy #$0940				LDY	#TX_DLY_CYCLES		; FIXME: Very bad work-around until timers are up
.fa67					DLY_Y
.fa67	88		dey					DEY
.fa68	ea		nop					NOP
.fa69	ea		nop					NOP
.fa6a	ea		nop					NOP
.fa6b	d0 fa		bne $fa67				BNE	DLY_Y
.fa6d	7a		ply					PLY
.fa6e	60		rts					RTS
.fa6f					INC_SA24
.fa6f	18		clc					CLC
.fa70	a5 e1		lda $e1					LDA	PTR_L
.fa72	69 01		adc #$01				ADC	#1
.fa74	85 e1		sta $e1					STA	PTR_L
.fa76	a5 e2		lda $e2					LDA	PTR_H
.fa78	69 00		adc #$00				ADC	#0
.fa7a	85 e2		sta $e2					STA	PTR_H
.fa7c	a5 e3		lda $e3					LDA	PTR_B
.fa7e	69 00		adc #$00				ADC	#0
.fa80	85 e3		sta $e3					STA	PTR_B
.fa82	60		rts					RTS
.fa83					DEC_CTR24
.fa83	38		sec					SEC
.fa84	a5 e4		lda $e4					LDA	CTR_L			; one less byte to print out
.fa86	e9 01		sbc #$01				SBC	#1
.fa88	85 e4		sta $e4					STA	CTR_L
.fa8a	a5 e5		lda $e5					LDA	CTR_H
.fa8c	e9 00		sbc #$00				SBC	#0
.fa8e	85 e5		sta $e5					STA	CTR_H
.fa90	a5 e6		lda $e6					LDA	CTR_B
.fa92	e9 00		sbc #$00				SBC	#0
.fa94	85 e6		sta $e6					STA	CTR_B
.fa96	60		rts					RTS
.fa97					CMD_DUMPHEX
.fa97	20 11 fc	jsr $fc11				JSR	CRLF			; Give some space
.fa9a	20 cc f8	jsr $f8cc				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.fa9d	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.faa0	f0 03		beq $faa5				BEQ	CDH_NOTEOL		; Not EOL, so start dumping data
.faa2	82 b6 00	brl $fb5b				BRL	DHEXX1			; We hit an EOL before an actionable character, so quit
.faa5					CDH_NOTEOL
.faa5	9c 08 05	stz $0508				STZ	BYTECNT			; First line and every 16 bytes will show current address
.faa8	20 ef f8	jsr $f8ef				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.faab	20 3a fd	jsr $fd3a				JSR	CONVHEX			; Get starting address in HEXIO
.faae	ad 0b 05	lda $050b				LDA	HEXIO_B			; Put starting address in PTR
.fab1	85 e3		sta $e3					STA	PTR_B
.fab3	ad 0a 05	lda $050a				LDA	HEXIO_H
.fab6	85 e2		sta $e2					STA	PTR_H
.fab8	ad 09 05	lda $0509				LDA	HEXIO_L
.fabb	85 e1		sta $e1					STA	PTR_L
.fabd	20 cc f8	jsr $f8cc				JSR	FINDSTART		;Get next parameter
.fac0	ad 07 05	lda $0507				LDA	EOLFLAG			; is there one?
.fac3	f0 0b		beq $fad0				BEQ	DHSAVEA			; save end address if not EOL after start address read
.fac5	64 e6		stz $e6					STZ	CTR_B
.fac7	64 e5		stz $e5					STZ	CTR_H
.fac9	a9 01		lda #$01				LDA	#1
.facb	85 e4		sta $e4					STA	CTR_L
.facd	82 3b 00	brl $fb0b				BRL	DUMPITNOW
.fad0					DHSAVEA
.fad0	20 ef f8	jsr $f8ef				JSR	FINDEND
.fad3	20 3a fd	jsr $fd3a				JSR	CONVHEX			; get 8 to 24 bit end address
.fad6	ad 0b 05	lda $050b				LDA	HEXIO_B
.fad9	85 ec		sta $ec					STA	EA_B
.fadb	ad 0a 05	lda $050a				LDA	HEXIO_H
.fade	85 eb		sta $eb					STA	EA_H
.fae0	ad 09 05	lda $0509				LDA	HEXIO_L
.fae3	85 ea		sta $ea					STA	EA_L
.fae5	38		sec					SEC
.fae6	a5 ea		lda $ea					LDA	EA_L
.fae8	e5 e1		sbc $e1					SBC	PTR_L
.faea	85 e4		sta $e4					STA	CTR_L
.faec	a5 eb		lda $eb					LDA	EA_H
.faee	e5 e2		sbc $e2					SBC	PTR_H
.faf0	85 e5		sta $e5					STA	CTR_H
.faf2	a5 ec		lda $ec					LDA	EA_B
.faf4	e5 e3		sbc $e3					SBC	PTR_B			; Just to be thorough, should we support > 64K dump someday
.faf6	85 e6		sta $e6					STA	CTR_B
.faf8	18		clc					CLC				; Probably can make this more efficient
.faf9	a5 e4		lda $e4					LDA	CTR_L			; Calculate byte count of dump in CTR
.fafb	69 01		adc #$01				ADC	#1
.fafd	85 e4		sta $e4					STA	CTR_L
.faff	a5 e5		lda $e5					LDA	CTR_H
.fb01	69 00		adc #$00				ADC	#0
.fb03	85 e5		sta $e5					STA	CTR_H
.fb05	a5 e6		lda $e6					LDA	CTR_B
.fb07	69 00		adc #$00				ADC	#0
.fb09	85 e6		sta $e6					STA	CTR_B
.fb0b					DUMPITNOW
.fb0b	a5 e4		lda $e4					LDA	CTR_L			; Check for done
.fb0d	05 e5		ora $e5					ORA	CTR_H
.fb0f	05 e6		ora $e6					ORA	CTR_B
.fb11	f0 48		beq $fb5b				BEQ 	DHEXX1			; We're done
.fb13	ad 08 05	lda $0508				LDA	BYTECNT
.fb16	d0 24		bne $fb3c				BNE	DUMPITN1		;
.fb18					DHEXC6
.fb18	20 11 fc	jsr $fc11				JSR	CRLF
.fb1b	a5 e3		lda $e3					LDA	PTR_B
.fb1d	8d 0b 05	sta $050b				STA	HEXIO_B
.fb20	a5 e2		lda $e2					LDA	PTR_H
.fb22	8d 0a 05	sta $050a				STA	HEXIO_H
.fb25	a5 e1		lda $e1					LDA	PTR_L
.fb27	8d 09 05	sta $0509				STA	HEXIO_L
.fb2a	20 b4 fd	jsr $fdb4				JSR	PUTHEX24		; Print the address
.fb2d	a9 3a		lda #$3a				LDA	#':'
.fb2f	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fb32	a9 20		lda #$20				LDA	#SP
.fb34	20 4f f8	jsr $f84f				JSR	PUTCHAR			;
.fb37	a9 20		lda #$20				LDA	#SP
.fb39	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fb3c					DUMPITN1
.fb3c	a7 e1		lda [$e1]				LDA	[PTR]			; Dump CTR bytes starting at [PTR]
.fb3e	20 cc fd	jsr $fdcc				JSR	PUTHEXA
.fb41	a9 20		lda #$20				LDA	#' '
.fb43	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fb46	20 6f fa	jsr $fa6f				JSR	INC_SA24		; Next source address
.fb49					DHEXC3
.fb49	20 83 fa	jsr $fa83				JSR	DEC_CTR24
.fb4c	ee 08 05	inc $0508				INC 	BYTECNT
.fb4f	ad 08 05	lda $0508				LDA	BYTECNT
.fb52	c9 10		cmp #$10				CMP	#16
.fb54	d0 b5		bne $fb0b				BNE	DUMPITNOW
.fb56	9c 08 05	stz $0508				STZ	BYTECNT
.fb59	80 b0		bra $fb0b				BRA	DUMPITNOW		; Print the address at start of new line
.fb5b					DHEXX1
.fb5b	60		rts					RTS
.fb5c					CMD_WRITEBYTES
.fb5c	20 11 fc	jsr $fc11				JSR	CRLF			; Give some space
.fb5f	20 cc f8	jsr $f8cc				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.fb62	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.fb65	d0 5e		bne $fbc5				BNE	CWBXX2			; We hit an EOL before an actionable character, so quit
.fb67	20 ef f8	jsr $f8ef				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.fb6a	20 3a fd	jsr $fd3a				JSR	CONVHEX			; Get starting address in HEXIO
.fb6d	ad 0b 05	lda $050b				LDA	HEXIO_B			; Transfer starting address from HEXIO to PTR
.fb70	85 e3		sta $e3					STA	PTR_B
.fb72	ad 0a 05	lda $050a				LDA	HEXIO_H
.fb75	85 e2		sta $e2					STA	PTR_H
.fb77	ad 09 05	lda $0509				LDA	HEXIO_L
.fb7a	85 e1		sta $e1					STA	PTR_L
.fb7c					CWLOOP1
.fb7c	20 cc f8	jsr $f8cc				JSR	FINDSTART		; Get next byte
.fb7f	ad 07 05	lda $0507				LDA	EOLFLAG
.fb82	d0 41		bne $fbc5				BNE	CWBXX2
.fb84	20 ef f8	jsr $f8ef				JSR	FINDEND			; Find end of Parameter
.fb87	20 13 fd	jsr $fd13				JSR	RDHEX8
.fb8a	87 e1		sta [$e1]				STA	[PTR]			; Attempt to store.  If ROM, output will show failure to write
.fb8c	a5 e3		lda $e3					LDA	PTR_B
.fb8e	8d 0b 05	sta $050b				STA	HEXIO_B
.fb91	a5 e2		lda $e2					LDA	PTR_H
.fb93	8d 0a 05	sta $050a				STA	HEXIO_H
.fb96	a5 e1		lda $e1					LDA	PTR_L
.fb98	8d 09 05	sta $0509				STA	HEXIO_L
.fb9b	20 b4 fd	jsr $fdb4				JSR	PUTHEX24
.fb9e	a9 3c		lda #$3c				LDA	#'<'
.fba0	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fba3	a9 2d		lda #$2d				LDA	#'-'
.fba5	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fba8	a7 e1		lda [$e1]				LDA	[PTR]			; Read the actual byte (if ROM, won't match input)
.fbaa	20 cc fd	jsr $fdcc				JSR	PUTHEXA
.fbad	20 11 fc	jsr $fc11				JSR	CRLF
.fbb0	18		clc					CLC
.fbb1	a5 e1		lda $e1					LDA	PTR_L
.fbb3	69 01		adc #$01				ADC	#1
.fbb5	85 e1		sta $e1					STA	PTR_L
.fbb7	a5 e2		lda $e2					LDA	PTR_H
.fbb9	69 00		adc #$00				ADC	#0
.fbbb	85 e2		sta $e2					STA	PTR_H
.fbbd	a5 e3		lda $e3					LDA	PTR_B
.fbbf	69 00		adc #$00				ADC	#0
.fbc1	85 e3		sta $e3					STA	PTR_B
.fbc3	80 b7		bra $fb7c				BRA	CWLOOP1
.fbc5					CWBXX2
.fbc5	60		rts					RTS
.fbc6					CMD_LOAD
.fbc6	a0 49 f2	ldy #$f249				LDY	#MSG_LOAD
.fbc9	20 6e f8	jsr $f86e				JSR	PUT_STR
.fbcc	20 2d fc	jsr $fc2d				JSR	SREC_LOADER
.fbcf	60		rts					RTS
.fbd0					CMD_GO
.fbd0	20 11 fc	jsr $fc11				JSR	CRLF			; Give some space
.fbd3	20 cc f8	jsr $f8cc				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.fbd6	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.fbd9	d0 24		bne $fbff				BNE	CGXIT1			; We hit an EOL before an actionable character, so quit
.fbdb	20 ef f8	jsr $f8ef				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.fbde	20 3a fd	jsr $fd3a				JSR	CONVHEX			; Get starting address in HEXIO
.fbe1	ad 0b 05	lda $050b				LDA	HEXIO_B			; Transfer starting address from HEXIO to PTR
.fbe4	85 e3		sta $e3					STA	PTR_B
.fbe6	ad 0a 05	lda $050a				LDA	HEXIO_H
.fbe9	85 e2		sta $e2					STA	PTR_H
.fbeb	ad 09 05	lda $0509				LDA	HEXIO_L
.fbee	85 e1		sta $e1					STA	PTR_L
.fbf0	a0 6b f2	ldy #$f26b				LDY	#MSG_JUMP
.fbf3	20 6e f8	jsr $f86e				JSR	PUT_STR
.fbf6	20 b4 fd	jsr $fdb4				JSR	PUTHEX24
.fbf9	20 11 fc	jsr $fc11				JSR	CRLF			; get rid of return address since we're not returing!
.fbfc	dc e1 00	jmp [$00e1]				JML	[PTR]			; There's really no exit
.fbff					CGXIT1
.fbff	60		rts					RTS						; Might return if no valid jump address
.fc00					LOLWUT
.fc00	20 11 fc	jsr $fc11				JSR	CRLF
.fc03	a0 00 04	ldy #$0400				LDY	#CMDBUF
.fc06	20 7a f8	jsr $f87a				JSR	PUT_STR_CTRL		; Display buffer contents not understood; show non-printing too!
.fc09	20 11 fc	jsr $fc11				JSR	CRLF
.fc0c	a9 3f		lda #$3f				LDA	#'?'
.fc0e	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fc11					CRLF
.fc11	a9 0a		lda #$0a				LDA	#LF
.fc13	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fc16					JUSTCR
.fc16	a9 0d		lda #$0d				LDA	#CR
.fc18	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fc1b	60		rts					RTS
.fc1c					CMD_A
.fc1c					CMD_B
.fc1c					CMD_C
.fc1c					CMD_D
.fc1c					CMD_E
.fc1c					CMD_F
.fc1c					CMD_H
.fc1c					CMD_I
.fc1c					CMD_J
.fc1c					CMD_K
.fc1c					CMD_M
.fc1c					CMD_N
.fc1c					CMD_O
.fc1c					CMD_P
.fc1c					CMD_Q
.fc1c					CMD_R
.fc1c					CMD_S
.fc1c					CMD_T
.fc1c					CMD_U
.fc1c					CMD_V
.fc1c					CMD_X
.fc1c					CMD_Y
.fc1c					CMD_Z
.fc1c	a0 00 f0	ldy #$f000				LDY	#MSG_UNIMPLEMENTED
.fc1f	20 6e f8	jsr $f86e				JSR	PUT_STR
.fc22	60		rts					RTS
.fc23	c9 20		cmp #$20	PUTCHARDOT		CMP	#SP
.fc25	b0 02		bcs $fc29				BCS	PCDPRINT
.fc27	a9 2e		lda #$2e				LDA	#'.'
.fc29					PCDPRINT
.fc29	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fc2c	60		rts					RTS
.fc2d					SREC_LOADER
.fc2d					SYNC
.fc2d	20 3d f8	jsr $f83d				JSR	GETCHAR			; Wait for "S" to start a new record
.fc30	c9 53		cmp #$53				CMP	#'S'
.fc32	d0 f9		bne $fc2d				BNE	SYNC
.fc34	a9 40		lda #$40				LDA	#'@'
.fc36	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fc39	20 3d f8	jsr $f83d				JSR	GETCHAR
.fc3c	85 e0		sta $e0					STA	REC_TYPE
.fc3e	20 7f fd	jsr $fd7f				JSR	GETHEX			; Get message length byte
.fc41	85 ed		sta $ed					STA	DATA_CNT		; Save number of bytes in record
.fc43	a5 e0		lda $e0					LDA	REC_TYPE		; Decode and dispatch
.fc45	f0 23		beq $fc6a				BEQ	GETREMS			; read the comment block
.fc47	c9 31		cmp #$31				CMP	#'1'
.fc49	f0 3e		beq $fc89				BEQ	GET16ADDR
.fc4b	c9 32		cmp #$32				CMP	#'2'
.fc4d	f0 27		beq $fc76				BEQ	GET24ADDR
.fc4f	c9 35		cmp #$35				CMP	#'5'
.fc51	d0 02		bne $fc55				BNE	SLC4
.fc53	80 64		bra $fcb9				BRA	CNT16
.fc55					SLC4
.fc55	c9 36		cmp #$36				CMP	#'6'
.fc57	d0 02		bne $fc5b				BNE	SLC2
.fc59	80 67		bra $fcc2				BRA	CNT24
.fc5b					SLC2
.fc5b	c9 38		cmp #$38				CMP	#'8'
.fc5d	d0 03		bne $fc62				BNE	SLC1
.fc5f	82 85 00	brl $fce7				BRL	SA24			; Too far for relative branch
.fc62					SLC1
.fc62	c9 39		cmp #$39				CMP	#'9'
.fc64	d0 02		bne $fc68				BNE	SLC3
.fc66	80 76		bra $fcde				BRA	SA16
.fc68					SLC3
.fc68	80 c3		bra $fc2d				BRA	SYNC
.fc6a					GETREMS
.fc6a	a9 30		lda #$30				LDA	#'0'
.fc6c	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fc6f	a9 23		lda #$23				LDA	#'#'
.fc71	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fc74	80 b7		bra $fc2d				BRA	SYNC
.fc76					GET24ADDR
.fc76	a9 32		lda #$32				LDA	#'2'
.fc78	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fc7b	a5 ed		lda $ed					LDA	DATA_CNT
.fc7d	38		sec					SEC
.fc7e	e9 04		sbc #$04				SBC	#4			; Data length -= 3 bytes address + 1 byte checksum
.fc80	85 ed		sta $ed					STA	DATA_CNT		; Adjust data count to include only payload data bytes
.fc82	20 7f fd	jsr $fd7f				JSR	GETHEX
.fc85	85 e3		sta $e3					STA	PTR_B
.fc87	80 0e		bra $fc97				BRA	GET1624
.fc89					GET16ADDR
.fc89	a9 31		lda #$31				LDA	#'1'
.fc8b	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fc8e	a5 ed		lda $ed					LDA	DATA_CNT
.fc90	38		sec					SEC
.fc91	e9 03		sbc #$03				SBC	#3			; Data length -= 2 bytes address + 1 byte checksum
.fc93	85 ed		sta $ed					STA	DATA_CNT		; Adjust data count to include only payload data bytes
.fc95	64 e3		stz $e3					STZ	PTR_B			; 16 bit records.  Default Bank to 0!  (0+! NOT 0!=1)
.fc97					GET1624
.fc97	20 7f fd	jsr $fd7f				JSR	GETHEX			; Got bank value (or set to 0). Now get high and low address
.fc9a	85 e2		sta $e2					STA	PTR_H
.fc9c	20 7f fd	jsr $fd7f				JSR	GETHEX
.fc9f	85 e1		sta $e1					STA	PTR_L
.fca1					SAVDAT:
.fca1	a5 ed		lda $ed					LDA	DATA_CNT		; A record can have 0 data bytes, theoretically. So check at top
.fca3	f0 0c		beq $fcb1				BEQ	SAVDX1			; No more data to PARSELINE
.fca5					SAVDAT2
.fca5	20 7f fd	jsr $fd7f				JSR	GETHEX
.fca8	87 e1		sta [$e1]				STA	[PTR]			; 24 bit indirect save
.fcaa	20 08 fd	jsr $fd08				JSR	INC_PTR			; Point to next byte
.fcad	c6 ed		dec $ed					DEC	DATA_CNT
.fcaf	d0 f4		bne $fca5				BNE	SAVDAT2
.fcb1					SAVDX1
.fcb1	a9 23		lda #$23				LDA	#'#'
.fcb3	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fcb6	82 74 ff	brl $fc2d				BRL	SYNC			; FIXME: parse the checksum and end of line
.fcb9					CNT16
.fcb9	a9 35		lda #$35				LDA	#'5'
.fcbb	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fcbe	64 e6		stz $e6					STZ	CTR_B
.fcc0	80 0a		bra $fccc				BRA	CN16C1
.fcc2					CNT24:
.fcc2	a9 36		lda #$36				LDA	#'6'
.fcc4	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fcc7	20 7f fd	jsr $fd7f				JSR	GETHEX
.fcca	85 e6		sta $e6					STA	CTR_B
.fccc					CN16C1
.fccc	20 7f fd	jsr $fd7f				JSR	GETHEX			; bits 15-8
.fccf	85 e5		sta $e5					STA	CTR_H
.fcd1	20 7f fd	jsr $fd7f				JSR	GETHEX			; bits 7-0
.fcd4	85 e4		sta $e4					STA	CTR_L
.fcd6	a9 23		lda #$23				LDA	#'#'
.fcd8	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fcdb	82 4f ff	brl $fc2d				BRL	SYNC			; FIXME: parse the rest of the record & end of line
.fcde					SA16
.fcde	a9 39		lda #$39				LDA	#'9'
.fce0	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fce3	64 e9		stz $e9					STZ	SA_B
.fce5	80 0a		bra $fcf1				BRA	SA16C1
.fce7					SA24
.fce7	a9 38		lda #$38				LDA	#'8'
.fce9	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fcec	20 7f fd	jsr $fd7f				JSR	GETHEX			; length byte
.fcef	64 e9		stz $e9					STZ	SA_B
.fcf1					SA16C1
.fcf1	20 7f fd	jsr $fd7f				JSR	GETHEX			; bits 15-8
.fcf4	85 e8		sta $e8					STA	SA_H
.fcf6	20 7f fd	jsr $fd7f				JSR	GETHEX			; bits 7-0
.fcf9	85 e7		sta $e7					STA	SA_L
.fcfb	a9 26		lda #$26				LDA	#'&'
.fcfd	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fd00					GOEOL
.fd00	20 3d f8	jsr $f83d				JSR	GETCHAR
.fd03	c9 0d		cmp #$0d				CMP	#CR
.fd05	d0 f9		bne $fd00				BNE	GOEOL
.fd07	60		rts					RTS
.fd08					INC_PTR
.fd08	e6 e1		inc $e1					INC	PTR_L			; point to the next byte to save to
.fd0a	d0 06		bne $fd12				BNE	INCPX1
.fd0c	e6 e2		inc $e2					INC	PTR_H
.fd0e	d0 02		bne $fd12				BNE	INCPX1
.fd10	e6 e3		inc $e3					INC	PTR_B
.fd12					INCPX1
.fd12	60		rts					RTS
.fd13					RDHEX8
.fd13	5a		phy					PHY
.fd14	ac 04 05	ldy $0504				LDY	PRM_SA			; Start at beginning of current parameter
.fd17					RDHX8L1
.fd17	b9 00 00	lda $0000,y				LDA	0,Y			; Get MSB from *(parameter)
.fd1a	c8		iny					INY				; advance to (hopefully) ASCII LSB
.fd1b	c9 3a		cmp #$3a				CMP	#':'			; Kludgey special handling for ':'
.fd1d	f0 f8		beq $fd17				BEQ	RDHX8L1
.fd1f					RDHX8C1
.fd1f	20 e3 fd	jsr $fde3				JSR	MKNIBL
.fd22	0a		asl a					ASL	A			; Note: MKNIBL ANDs off higher 4 bits, so no '1' sign extension can occur
.fd23	0a		asl a					ASL	A
.fd24	0a		asl a					ASL	A
.fd25	0a		asl a					ASL	A			; shift left 4 because upper nibble
.fd26	85 f0		sta $f0					STA	HEXASSY			; temporary storage.  Only used within this function. Can re-use in any foreground context.
.fd28					RDHX8L2
.fd28	b9 00 00	lda $0000,y				LDA	0,Y			; Get LSB *(parameter+1)
.fd2b	c8		iny					INY				; point to next ASCII hex byte (if any)
.fd2c	c9 3a		cmp #$3a				CMP	#':'
.fd2e	f0 f8		beq $fd28				BEQ	RDHX8L2			; Anti-metamucel (ignore colons) Note pathological buffer with all ':' is possible.  We will tolerate.
.fd30	8c 04 05	sty $0504				STY	PRM_SA			;	"
.fd33	20 e3 fd	jsr $fde3				JSR	MKNIBL
.fd36	05 f0		ora $f0					ORA	HEXASSY			; Assemble the parts
.fd38	7a		ply					PLY
.fd39	60		rts					RTS				; return the byte in A
.fd3a					CONVHEX
.fd3a	9c 0b 05	stz $050b				STZ	HEXIO_B			; Only write bytes explicitly set in buffer parameter string, else 0
.fd3d	9c 0a 05	stz $050a				STZ	HEXIO_H
.fd40	9c 09 05	stz $0509				STZ	HEXIO_L
.fd43	ad 06 05	lda $0506				LDA	PRM_SIZ			; 24 bit cases are "00:1234" or "001234", 16 bit is "1234", 8 bit is "2A"
.fd46	c9 02		cmp #$02				CMP	#2			; See if not even 8 bits (must be two digits to qualify as a hex value by fiat)
.fd48	90 34		bcc $fd7e				BCC	CVHKWIT			; Too short to be a valid hex parameter.  Must be 2 or more characters
.fd4a	c9 03		cmp #$03				CMP	#3
.fd4c	b0 08		bcs $fd56				BCS	CHXCHK16
.fd4e	20 13 fd	jsr $fd13				JSR	RDHEX8
.fd51	8d 09 05	sta $0509				STA	HEXIO_L
.fd54	80 28		bra $fd7e				BRA	CVHKWIT
.fd56					CHXCHK16
.fd56	c9 05		cmp #$05				CMP	#5
.fd58	b0 0e		bcs $fd68				BCS	CHXCHK24
.fd5a	20 13 fd	jsr $fd13				JSR	RDHEX8
.fd5d	8d 0a 05	sta $050a				STA	HEXIO_H
.fd60	20 13 fd	jsr $fd13				JSR	RDHEX8
.fd63	8d 09 05	sta $0509				STA	HEXIO_L
.fd66	80 16		bra $fd7e				BRA	CVHKWIT
.fd68					CHXCHK24
.fd68	c9 08		cmp #$08				CMP	#8
.fd6a	b0 12		bcs $fd7e				BCS	CVHKWIT			; Give up if >= 8 characters!
.fd6c	20 13 fd	jsr $fd13				JSR	RDHEX8
.fd6f	8d 0b 05	sta $050b				STA	HEXIO_B
.fd72	20 13 fd	jsr $fd13				JSR	RDHEX8
.fd75	8d 0a 05	sta $050a				STA	HEXIO_H
.fd78	20 13 fd	jsr $fd13				JSR	RDHEX8
.fd7b	8d 09 05	sta $0509				STA	HEXIO_L
.fd7e					CVHKWIT
.fd7e	60		rts					RTS
.fd7f					GETHEX
.fd7f	20 3d f8	jsr $f83d				JSR 	GETCHAR
.fd82	c9 03		cmp #$03				CMP	#CTRL_C
.fd84	d0 0b		bne $fd91				BNE	GHECC1
.fd86	a9 5e		lda #$5e				LDA	#'^'
.fd88	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fd8b	a9 43		lda #$43				LDA	#'C'
.fd8d	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fd90	60		rts		       		RTS				; bail
.fd91					GHECC1
.fd91	20 e3 fd	jsr $fde3				JSR     MKNIBL  		; Convert to 0..F numeric
.fd94	0a		asl a					ASL     A
.fd95	0a		asl a					ASL     A
.fd96	0a		asl a					ASL     A
.fd97	0a		asl a					ASL     A       		; This is the upper nibble
.fd98	29 f0		and #$f0				AND     #$F0
.fd9a	85 ef		sta $ef					STA     SUBTEMP
.fd9c	20 3d f8	jsr $f83d				JSR     GETCHAR
.fd9f	c9 03		cmp #$03				CMP	#CTRL_C
.fda1	d0 0b		bne $fdae				BNE	GHECC2
.fda3	a9 5e		lda #$5e				LDA	#'^'
.fda5	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fda8	a9 43		lda #$43				LDA	#'C'
.fdaa	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fdad	60		rts					RTS				; bail
.fdae					GHECC2
.fdae	20 e3 fd	jsr $fde3				JSR     MKNIBL
.fdb1	05 ef		ora $ef		        		ORA    	SUBTEMP
.fdb3	60		rts		        		RTS
.fdb4					PUTHEX24:
.fdb4	ad 0b 05	lda $050b				LDA	HEXIO_B
.fdb7	20 cc fd	jsr $fdcc				JSR	PUTHEXA
.fdba	a9 3a		lda #$3a				LDA	#':'
.fdbc	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fdbf					PUTHEX16:
.fdbf	ad 0a 05	lda $050a				LDA	HEXIO_H
.fdc2	20 cc fd	jsr $fdcc				JSR	PUTHEXA
.fdc5					PUTHEX8:
.fdc5	ad 09 05	lda $0509				LDA	HEXIO_L
.fdc8	20 cc fd	jsr $fdcc				JSR	PUTHEXA
.fdcb	60		rts					RTS
.fdcc					PUTHEXA
.fdcc	48		pha					PHA             	;
.fdcd	4a		lsr a		        		LSR 	A
.fdce	4a		lsr a		        		LSR 	A
.fdcf	4a		lsr a					LSR 	A
.fdd0	4a		lsr a					LSR 	A
.fdd1	20 d5 fd	jsr $fdd5	        		JSR     PRNIBL
.fdd4	68		pla		        		PLA
.fdd5					PRNIBL
.fdd5	29 0f		and #$0f				AND     #$0F    	; strip off the low nibble
.fdd7	c9 0a		cmp #$0a	       		 	CMP     #$0A
.fdd9	90 02		bcc $fddd	       		 	BCC  	NOTHEX  	; if it's 0-9, add '0' else also add 7
.fddb	69 06		adc #$06	       		 	ADC     #6      	; Add 7 (6+carry=1), result will be carry clear
.fddd					NOTHEX
.fddd	69 30		adc #$30				ADC     #'0'    	; If carry clear, we're 0-9
.fddf					PUTCH
.fddf	20 4f f8	jsr $f84f				JSR	PUTCHAR
.fde2	60		rts					RTS
.fde3					MKNIBL
.fde3	c9 3a		cmp #$3a				CMP     #'9'+1  	; See if it's 0-9 or 'A'..'F' (no lowercase yet)
.fde5	90 02		bcc $fde9	 		    BCC     MKNNH   	; If we borrowed, we lost the carry so 0..9
.fde7	e9 08		sbc #$08	        		SBC     #7+1    	; Subtract off extra 7 (sbc subtracts off one less)
.fde9					MKNNH
.fde9	e9 2f		sbc #$2f				SBC     #'0'-1  	; subtract off '0' (if carry clear coming in)
.fdeb	29 0f		and #$0f	        		AND     #$0F    	; no upper nibble no matter what
.fded	60		rts		        		RTS             	; and return the nibble
.fdee					MONTBL
>fdee	1c fc							.word 	CMD_A		; Index 0 = "A"
>fdf0	1c fc							.word	CMD_B
>fdf2	1c fc							.word	CMD_C
>fdf4	1c fc							.word	CMD_D
>fdf6	1c fc							.word	CMD_E
>fdf8	1c fc							.word	CMD_F
>fdfa	d0 fb							.word	CMD_GO
>fdfc	1c fc							.word	CMD_H
>fdfe	1c fc							.word	CMD_I
>fe00	d0 fb							.word	CMD_GO
>fe02	1c fc							.word	CMD_K
>fe04	c6 fb							.word	CMD_LOAD
>fe06	1c fc							.word	CMD_M
>fe08	1c fc							.word	CMD_N
>fe0a	1c fc							.word	CMD_O
>fe0c	1c fc							.word	CMD_P
>fe0e	1c fc							.word	CMD_Q
>fe10	97 fa							.word	CMD_DUMPHEX
>fe12	1c fc							.word	CMD_S
>fe14	1c fc							.word	CMD_T
>fe16	1c fc							.word	CMD_U
>fe18	1c fc							.word	CMD_V
>fe1a	5c fb							.word	CMD_WRITEBYTES
>fe1c	1c fc							.word	CMD_X
>fe1e	1c fc							.word	CMD_Y
>fe20	1c fc							.word	CMD_Z
.f000					MSG_UNIMPLEMENTED
>f000	0d 55 6e 69 6d 70 6c 65				.text	CR,"Unimplemented instruction",CR
>f008	6d 65 6e 74 65 64 20 69 6e 73 74 72 75 63 74 69
>f018	6f 6e 0d
>f01b	00						.text	0
.f01c					MSG_6HEX
>f01c	0d 45 6e 74 65 72 20 36				.text	CR,"Enter 6 digit hex address:",0
>f024	20 64 69 67 69 74 20 68 65 78 20 61 64 64 72 65
>f034	73 73 3a 00
.f038					MSG_CONFIRM
>f038	0d 49 73 20 74 68 69 73				.text	CR,"Is this correct (Y/x)?:",0
>f040	20 63 6f 72 72 65 63 74 20 28 59 2f 78 29 3f 3a
>f050	00
.f051					QBFMSG
>f051	0d 0a 0d 0a					.text 		CR,LF,CR,LF
>f055	20 20 20 20 20 20 20 20				.text	"                  VCBmon v 1.00",CR,LF
>f05d	20 20 20 20 20 20 20 20 20 20 56 43 42 6d 6f 6e
>f06d	20 76 20 31 2e 30 30 0d 0a
>f076	20 20 20 20 20 20 20 20				.text 	"          ******************************",CR,LF
>f07e	20 20 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f08e	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f09e	0d 0a
>f0a0	20 20 20 20 20 20 20 20				.text 	"          *                            *",CR,LF
>f0a8	20 20 2a 20 20 20 20 20 20 20 20 20 20 20 20 20
>f0b8	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 2a
>f0c8	0d 0a
>f0ca	20 20 20 20 20 20 20 20				.text 	"          *    The Quick brown Dog     *",CR,LF
>f0d2	20 20 2a 20 20 20 20 54 68 65 20 51 75 69 63 6b
>f0e2	20 62 72 6f 77 6e 20 44 6f 67 20 20 20 20 20 2a
>f0f2	0d 0a
>f0f4	20 20 20 20 20 20 20 20				.text 	"          *  Jumps over the Lazy Fox!  *",CR,LF
>f0fc	20 20 2a 20 20 4a 75 6d 70 73 20 6f 76 65 72 20
>f10c	74 68 65 20 4c 61 7a 79 20 46 6f 78 21 20 20 2a
>f11c	0d 0a
>f11e	20 20 20 20 20 20 20 20				.text 	"          *                            *",CR,LF
>f126	20 20 2a 20 20 20 20 20 20 20 20 20 20 20 20 20
>f136	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 2a
>f146	0d 0a
>f148	20 20 20 20 20 20 20 20				.text 	"          ******************************",CR,LF
>f150	20 20 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f160	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f170	0d 0a
.f172					PROMPT
>f172	0d 0a						.text	CR,LF
>f174	20 20 20 20 20 20 20 20				.text	"        _,-=._              /|_/|",CR,LF
>f17c	5f 2c 2d 3d 2e 5f 20 20 20 20 20 20 20 20 20 20
>f18c	20 20 20 20 2f 7c 5f 2f 7c 0d 0a
>f197	20 20 20 20 20 20 20 2a		 		.text	"       *-.}   `=._,.-=-._.,  @ @._,",CR,LF
>f19f	2d 2e 7d 20 20 20 60 3d 2e 5f 2c 2e 2d 3d 2d 2e
>f1af	5f 2e 2c 20 20 40 20 40 2e 5f 2c 0d 0a
>f1bc	20 20 20 20 20 20 20 20		 		.text   "          `._ _,-.   )      _,.-'",CR,LF
>f1c4	20 20 60 2e 5f 20 5f 2c 2d 2e 20 20 20 29 20 20
>f1d4	20 20 20 20 5f 2c 2e 2d 27 0d 0a
>f1df	20 20 20 20 20 20 20 20				 .text   "             `    G.m-'^m'm'",CR,CR,LF
>f1e7	20 20 20 20 20 60 20 20 20 20 47 2e 6d 2d 27 5e
>f1f7	6d 27 6d 27 0d 0d 0a
>f1fe	00				   		 .text	0
.f1ff					ANYKEY
>f1ff	0d 0a 0d 0a					.text	CR,LF,CR,LF
>f203	50 72 65 73 73 20 74 68				.text 	"Press the ANY key (CTRL-C) to return to monitor",CR
>f20b	65 20 41 4e 59 20 6b 65 79 20 28 43 54 52 4c 2d
>f21b	43 29 20 74 6f 20 72 65 74 75 72 6e 20 74 6f 20
>f22b	6d 6f 6e 69 74 6f 72 0d
>f233	65 6c 73 65 20 63 6f 6e				.text   "else continue foxing:"
>f23b	74 69 6e 75 65 20 66 6f 78 69 6e 67 3a
>f248	00						.text	0
.f249					MSG_LOAD
>f249	0d 53 45 4e 44 20 53 31				.text 	CR,"SEND S19 or S28 S-RECORD file:",CR,LF
>f251	39 20 6f 72 20 53 32 38 20 53 2d 52 45 43 4f 52
>f261	44 20 66 69 6c 65 3a 0d 0a
>f26a	00						.text 	0
.f26b					MSG_JUMP
>f26b	0d 4a 75 6d 70 69 6e 67				.text 	CR,"Jumping to address: $"
>f273	20 74 6f 20 61 64 64 72 65 73 73 3a 20 24
>f281	00						.text 	0
.ffe4					NCOP
>ffe4	00 f8						.word	START		; COP exception in native mode
.ffe6					NBRK
>ffe6	00 f8						.word	START		; BRK in native mode
.ffe8					NABORT
>ffe8	00 f8						.word	START
.ffea					NNMI
>ffea	00 f8						.word	START		; NMI interrupt in native mode
.ffee					NIRQ
>ffee	00 f8						.word	START
.fff4					ECOP
>fff4	00 f8						.word	START		; COP exception in 65c02 emulation mode
.fff8					EABORT
>fff8	00 f8						.word	START
.fffa					ENMI
>fffa	00 f8						.word	START		; NMI interrupt in 65c02 emulation mode
.fffc					ERESET
>fffc	00 f8						.word	START		; RESET exception in all modes
.fffe					EIRQ
>fffe	00 f8						.word	START

;******  End of listing
