
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -L monitor.lst --s-record -o monitor.hex monitor.asm
; Fri Jul 12 14:14:49 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: monitor.asm


;******  Processing file: via_symbols.inc

=$7fe0					SYS_VIA_BASE	    = 	$7FE0
=32736					SYSTEM_VIA_IORB     =  	SYS_VIA_BASE+0	; Port B IO register
=32737					SYSTEM_VIA_IORA     =	SYS_VIA_BASE+1 	; Port A IO register
=32738					SYSTEM_VIA_DDRB     = 	SYS_VIA_BASE+2	; Port B data direction register
=32739					SYSTEM_VIA_DDRA     = 	SYS_VIA_BASE+3	; Port A data direction register
=32740					SYSTEM_VIA_T1C_L    =	SYS_VIA_BASE+4 	; Timer 1 counter/latches, low-order
=32741					SYSTEM_VIA_T1C_H    = 	SYS_VIA_BASE+5	; Timer 1 high-order counter
=32742					SYSTEM_VIA_T1L_L    = 	SYS_VIA_BASE+6	; Timer 1 low-order latches
=32743					SYSTEM_VIA_T1L_H    = 	SYS_VIA_BASE+7	; Timer 1 high-order latches
=32744					SYSTEM_VIA_T2C_L    = 	SYS_VIA_BASE+8	; Timer 2 counter/latches, lower-order
=32745					SYSTEM_VIA_T2C_H    = 	SYS_VIA_BASE+9	; Timer 2 high-order counter
=32746					SYSTEM_VIA_SR       = 	SYS_VIA_BASE+10	; Shift register
=32747					SYSTEM_VIA_ACR      = 	SYS_VIA_BASE+11	; Auxilliary control register
=32748					SYSTEM_VIA_PCR      =	SYS_VIA_BASE+12	; Peripheral control register
=32749					SYSTEM_VIA_IFR	    =	SYS_VIA_BASE+13 ; Interrupt flag register
=32750					SYSTEM_VIA_IER      = 	SYS_VIA_BASE+14	; Interrupt enable register
=32751					SYSTEM_VIA_ORA_IRA  =	SYS_VIA_BASE+15	; Port A IO register, but no handshake
=$7fc0					DEBUG_VIA_BASE	    = 	$7FC0
=32704					DEBUG_VIA_IORB     =  	DEBUG_VIA_BASE+0	; Port B IO register
=32705					DEBUG_VIA_IORA     =	DEBUG_VIA_BASE+1 	; Port A IO register
=32706					DEBUG_VIA_DDRB     = 	DEBUG_VIA_BASE+2	; Port B data direction register
=32707					DEBUG_VIA_DDRA     = 	DEBUG_VIA_BASE+3	; Port A data direction register
=32708					DEBUG_VIA_T1C_L    =	DEBUG_VIA_BASE+4 	; Timer 1 counter/latches, low-order
=32709					DEBUG_VIA_T1C_H    = 	DEBUG_VIA_BASE+5	; Timer 1 high-order counter
=32710					DEBUG_VIA_T1L_L    = 	DEBUG_VIA_BASE+6	; Timer 1 low-order latches
=32711					DEBUG_VIA_T1L_H    = 	DEBUG_VIA_BASE+7	; Timer 1 high-order latches
=32712					DEBUG_VIA_T2C_L    = 	DEBUG_VIA_BASE+8	; Timer 2 counter/latches, lower-order
=32713					DEBUG_VIA_T2C_H    = 	DEBUG_VIA_BASE+9	; Timer 2 high-order counter
=32714					DEBUG_VIA_SR       = 	DEBUG_VIA_BASE+10	; Shift register
=32715					DEBUG_VIA_ACR      = 	DEBUG_VIA_BASE+11	; Auxilliary control register
=32716					DEBUG_VIA_PCR      =	DEBUG_VIA_BASE+12	; Peripheral control register
=32717					DEBUG_VIA_IFR	    =	DEBUG_VIA_BASE+13 ; Interrupt flag register
=32718					DEBUG_VIA_IER      = 	DEBUG_VIA_BASE+14	; Interrupt enable register
=32719					DEBUG_VIA_ORA_IRA  =	DEBUG_VIA_BASE+15	; Port A IO register, but no handshake
=$01					PB0 = MASK0
=$02					PB1 = MASK1
=$04					PB2 = MASK2
=$08					PB3 = MASK3
=$10					PB4 = MASK4
=$20					PB5 = MASK5
=$40					PB6 = MASK6
=$80					PB7 = MASK7
=$01					PA0 = MASK0
=$02					PA1 = MASK1
=$04					PA2 = MASK2
=$08					PA3 = MASK3
=$10					PA4 = MASK4
=$20					PA5 = MASK5
=$40					PA6 = MASK6
=$80					PA7 = MASK7

;******  Return to file: monitor.asm


;******  Processing file: acia_symbols.inc

=$7f80					ACIA_BASE = $7F80		; This is where the 6551 ACIA starts
=$7f80					SDR = ACIA_BASE       		; RX'ed bytes read, TX bytes written, here
=32641					SSR = ACIA_BASE+1     		; Serial data status register
=32642					SCMD = ACIA_BASE+2     		; Serial command reg. ()
=32643					SCTL = ACIA_BASE+3     		; Serial control reg. ()
=$10					TX_RDY = MASK4
=$08					RX_RDY = MASK3
=$00					ALL_INPUTS = $00
=$ff					ALL_OUTPUTS = $FF

;******  Return to file: monitor.asm

=$e036					RAW_GETC	=	$E036
=$e04b					RAW_PUTC	= 	$E04B
=$03					CTRL_C	= $03
=$08					BS		= $08
=$0a					LF		= $0A
=$0d					CR		= $0D
=$20					SP		= $20
=$7f					DEL     = $7F
=$01					MASK0		= %00000001
=$02					MASK1		= %00000010
=$04					MASK2		= %00000100
=$08					MASK3		= %00001000
=$10					MASK4		= %00010000
=$20					MASK5		= %00100000
=$40					MASK6 		= %01000000
=$80					MASK7		= %10000000
=$80					N_FLAG		= MASK7
=$40					V_FLAG		= MASK6
=$20					M_FLAG		= MASK5
=$10					X_FLAG		= MASK4
=$08					D_FLAG		= MASK3
=$04					I_FLAG		= MASK2
=$02					Z_FLAG		= MASK1
=$01					C_FLAG		= MASK0
=$43					TERMFLAGS = $43
=$01					RDRDY	= $01				; 1 = character waiting
=$04					XONXOFF = $04				; 0 = hardware handshake 1= XON/XOFF
=$20					ECHOOFF = $20
>00e0					REC_TYPE	.byte 	?
>00e1					DP_START	.byte	?
>00e2					PTR_L		.byte	?	; Generic pointer
>00e3					PTR_H		.byte	?
>00e4					PTR_B		.byte	?
=$e2					PTR			=		PTR_L
>00e5					CTR_L		.byte	?	; Counter
>00e6					CTR_H		.byte	?
>00e7					CTR_B		.byte	?
=$e5					CTR			= 		CTR_L
>00e8					SA_L		.byte 	?	; Starting address storage for various commands & loader
>00e9					SA_H		.byte 	?
>00ea					SA_B		.byte	?
=$e8					SA			=		SA_L
>00eb					EA_L		.byte 	?	; Starting address storage for various commands
>00ec					EA_H		.byte 	?
>00ed					EA_B		.byte	?
=$eb					EA			=		EA_L
>00ee					DATA_CNT	.byte 	?	; Count of record's actual storable data bytes
>00ef					TEMP		.byte 	?
>00f0					EXTRA		.byte	? 	; Used inside loader.  Please don't use elsewhere
>00f1					TEMP2		.byte	?
>00f2					SUBTEMP 	.byte	?	; Any subroutine that doesn't call others can use as local scratchpad space
>00f3					CHART		.byte	?
>00f4					DEBUG		.byte 	?
>00f5					HEXASSY		.byte	?
>0400					CMDBUF 		.fill	256		; can be smaller than 256 but must not cross 8 bit page boundary
>0500					CB_RDPTR	.word	?		; Use LDA/STA 0,X typically
>0502					CB_WRPTR	.word 	?		; Use LAD/STA 0,Y typically
>0504					PRM_SA	.word	?		; Parameter start address
>0506					PRM_SIZ	.byte	?		; Size of current parameter
>0507					EOLFLAG	.byte	?		; 0 = EOL not found, !0 = EOL has been encountered
>0508					BYTECNT	.byte 	?
>0509					HEXIO_L	.byte	?
>050a					HEXIO_H	.byte	?
>050b					HEXIO_B	.byte	?
=$0509					HEXIO		=	HEXIO_L		; 	24 bit HEX value to print
>050c					HEXVAL1L	.byte	?
>050d					HEXVAL1H	.byte	?
>050e					HEXVAL1B	.byte	?
=$050c					HEXVAL1		=	HEXVAL1L	; 24 bit HEXVAL1
>050f					HEXVAL2L	.byte	?
>0510					HEXVAL2H	.byte	?
>0511					HEXVAL2B	.byte	?
=$050f					HEXVAL2		=	HEXVAL2L	; 24 bit HEXVAL2
>0512					HEXVAL3L	.byte	?
>0513					HEXVAL3H	.byte	?
>0514					HEXVAL3B	.byte	?
=$0512					HEXVAL3		=	HEXVAL3L	; 24 bit HEXVAL3
=$7eff					STACKTOP	=	$7EFF	; Top of RAM = $07EFF (I/O is $7F00-$7FFF)
.2000					START
.2000	a0 49 26	ldy #$2649				LDY	#QBFMSG				; Start of monitor loop
.2003	20 e3 22	jsr $22e3				JSR	PUT_STR
.2006					MONGETL
.2006	20 a4 20	jsr $20a4				JSR	GETLINE
.2009	20 2f 20	jsr $202f				JSR	PARSELINE
.200c	80 f8		bra $2006				BRA	MONGETL			; End of monitor loop
.200e					INITPARS
.200e	9c 06 05	stz $0506				STZ	PRM_SIZ			; No known parameter size
.2011	9c 07 05	stz $0507				STZ	EOLFLAG			; No EOL found yet
.2014	a9 04		lda #$04				LDA	#>CMDBUF		; Initialize the read pointers
.2016	8d 01 05	sta $0501				STA	CB_RDPTR+1		; High address byte to high pointer byte
.2019	8d 05 05	sta $0505				STA	PRM_SA+1
.201c	a9 00		lda #$00				LDA	#<CMDBUF		; Low address byte to low pointer byte
.201e	8d 00 05	sta $0500				STA	CB_RDPTR
.2021	8d 04 05	sta $0504				STA	PRM_SA			; CB_WRPTR, PRMSA are pointers into CMDBUF e.g. LDA 0,Y/x
.2024	60		rts					RTS
.2025					CLRCMD
.2025	a2 00 04	ldx #$0400				LDX	#CMDBUF		; Point CB_WRPTR to start of command buffer
.2028	8e 02 05	stx $0502				STX	CB_WRPTR
.202b	9c 00 04	stz $0400				STZ	CMDBUF			; Null terminate the empty buffer
.202e	60		rts					RTS
.202f					PARSELINE
.202f	20 0e 20	jsr $200e				JSR	INITPARS
.2032					FINDCMD
.2032	20 5b 20	jsr $205b				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.2035	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.2038	d0 20		bne $205a				BNE	PLIX2			; We hit an EOL before an actionable character, so quit
.203a	a9 00		lda #$00				LDA	#0
.203c	eb		xba					XBA						; Make B zero so when TAX times comes, MSB of X will be 0! (0 emphasis not 0 factorial)
.203d	ae 00 05	ldx $0500				LDX	CB_RDPTR		; point to command byte
.2040	b5 00		lda $00,x				LDA	0,X				; Get command byte
.2042	e8		inx					INX						; Point past the command byte to save each subroutine from doing this
.2043	8e 00 05	stx $0500				STX	CB_RDPTR		; "
.2046	c9 41		cmp #$41				CMP	#'A'
.2048	90 0d		bcc $2057				BCC	PLERRXIT		; < 'A', so not a command
.204a	c9 5b		cmp #$5b				CMP	#'Z'+1
.204c	b0 09		bcs $2057				BCS	PLERRXIT		; > 'Z', so not a command
.204e	e9 40		sbc #$40				SBC	#'A'-1			; Carry clear, so subtract one less to account for borrow
.2050	0a		asl a					ASL	A				; Two bytes per JSR table entry
.2051	aa		tax					TAX						; X now holds offset in MONTABLE
.2052	fc 9b 25	jsr ($259b,x)				JSR	(MONTBL,X)		; No JSR indirect indexed.  Each table entry MUST end in RTS not RTL!
.2055	80 03		bra $205a				BRA	PLIX2			; We're done dispatching.
.2057					PLERRXIT:
.2057	20 92 22	jsr $2292				JSR	LOLWUT			; Print non-understood buffer plus ?[CR][LF]
.205a					PLIX2
.205a	60		rts					RTS
.205b					FINDSTART
.205b	ac 00 05	ldy $0500				LDY	CB_RDPTR
.205e					FSN1
.205e	b9 00 00	lda $0000,y				LDA	0,Y				; Get next character
.2061	f0 0f		beq $2072				BEQ	FSEOL			; Null --> End of line encountered.  We are done
.2063	c9 0d		cmp #$0d				CMP	#CR
.2065	f0 0b		beq $2072				BEQ	FSEOL			; CR = end of line also
.2067	c9 03		cmp #$03				CMP	#CTRL_C
.2069	f0 07		beq $2072				BEQ	FSEOL			; CTRL-C = end of line
.206b	c9 21		cmp #$21				CMP	#SP+1			; if space or less, and not CR or CTRL-C, skip over
.206d	b0 08		bcs $2077				BCS	FSDUN			; A non-whitespace character.  We're done looking
.206f	c8		iny					INY				; Keep looking for a valid parameter byte
.2070	80 ec		bra $205e				BRA	FSN1			; Next character
.2072					FSEOL
.2072	a9 01		lda #$01				LDA	#1
.2074	8d 07 05	sta $0507				STA	EOLFLAG
.2077					FSDUN
.2077	8c 00 05	sty $0500				STY	CB_RDPTR		; Save pointers by current value of Y
.207a	8c 04 05	sty $0504				STY	PRM_SA			; Save pointers by current value of Y
.207d	60		rts					RTS
.207e					FINDEND
.207e	9c 06 05	stz $0506				STZ	PRM_SIZ			; No known parameter bytes yet
.2081	ac 00 05	ldy $0500				LDY	CB_RDPTR
.2084					FEN1
.2084	b9 00 00	lda $0000,y				LDA	0,Y			; Get next character
.2087	f0 12		beq $209b				BEQ	FEEOL			; Null --> End of line encountered.  We are done
.2089	c9 0d		cmp #$0d				CMP	#CR
.208b	f0 0e		beq $209b				BEQ	FEEOL			; CR = end of line also
.208d	c9 03		cmp #$03				CMP	#CTRL_C
.208f	f0 0a		beq $209b				BEQ	FEEOL			; CTRL-C = end of line
.2091	c9 21		cmp #$21				CMP	#SP+1			; if space or less, and not CR or CTRL-C,
.2093	90 0b		bcc $20a0				BCC	FEDUN1			; A whitespace character.  We're done looking
.2095	c8		iny					INY
.2096	ee 06 05	inc $0506				INC	PRM_SIZ			; add one more to size of parameter
.2099	80 e9		bra $2084				BRA	FEN1
.209b					FEEOL
.209b	a9 01		lda #$01				LDA	#1
.209d	8d 07 05	sta $0507				STA	EOLFLAG
.20a0					FEDUN1
.20a0	8c 00 05	sty $0500				STY	CB_RDPTR		; Save pointers by current value of read pointer (don't update PRM_SA)
.20a3	60		rts					RTS
.20a4					GETLINE
.20a4	20 a3 22	jsr $22a3				JSR	CRLF
.20a7	a9 3e		lda #$3e				LDA	#'>'
.20a9	20 de 22	jsr $22de				JSR	PUTCHAR
.20ac	20 25 20	jsr $2025				JSR	CLRCMD
.20af					GLLP1
.20af	20 00 23	jsr $2300				JSR	GETCHAR				; Do not echo
.20b2	c9 0d		cmp #$0d				CMP	#CR
.20b4	d0 05		bne $20bb				BNE	GLNC0
.20b6	20 de 22	jsr $22de				JSR	PUTCHAR
.20b9	80 43		bra $20fe				BRA	GLXIT1				; end of message
.20bb					GLNC0
.20bb	c9 03		cmp #$03				CMP	#CTRL_C
.20bd	d0 14		bne $20d3				BNE	GLNC1
.20bf	a9 5e		lda #$5e				LDA	#'^'
.20c1	20 de 22	jsr $22de				JSR	PUTCHAR
.20c4	a9 43		lda #$43				LDA	#'C'
.20c6	20 de 22	jsr $22de				JSR	PUTCHAR
.20c9	a9 0d		lda #$0d				LDA	#CR
.20cb	20 de 22	jsr $22de				JSR	PUTCHAR
.20ce	20 25 20	jsr $2025				JSR	CLRCMD				; zotch out any command in buffer
.20d1	80 2b		bra $20fe				BRA	GLXIT1
.20d3					GLNC1
.20d3	c9 0a		cmp #$0a				CMP	#LF
.20d5	d0 02		bne $20d9				BNE	GLNC2
.20d7	80 d6		bra $20af				BRA	GLLP1
.20d9					GLNC2
.20d9	c9 08		cmp #$08				CMP	#BS					; We will not tolerate BS here
.20db	d0 16		bne $20f3				BNE	GLNC9
.20dd	c9 7f		cmp #$7f				CMP	#DEL
.20df	d0 12		bne $20f3				BNE	GLNC9
.20e1	74 00		stz $00,x				STZ	0,X
.20e3	e0 00 04	cpx #$0400				CPX	#CMDBUF
.20e6	f0 c7		beq $20af				BEQ	GLLP1				; Already backed over the first character. No index to decrement
.20e8	20 de 22	jsr $22de				JSR	PUTCHAR
.20eb	ca		dex					DEX							; change buffer pointer
.20ec	8e 02 05	stx $0502				STX	CB_WRPTR
.20ef	74 00		stz $00,x				STZ	0,X					; Character we backed over is now end of string
.20f1	80 bc		bra $20af				BRA	GLLP1
.20f3					GLNC9
.20f3	95 00		sta $00,x				STA	0,X					; store it
.20f5	20 de 22	jsr $22de				JSR	PUTCHAR
.20f8	e8		inx					INX
.20f9	8e 02 05	stx $0502				STX	CB_WRPTR
.20fc	80 b1		bra $20af				BRA	GLLP1
.20fe					GLXIT1
.20fe	74 00		stz $00,x				STZ	0,X					; null-terminate the line
.2100	60		rts					RTS
.2101					TOPUPPER
.2101	c9 61		cmp #$61				CMP	#'a'				; Make character PupperCase
.2103	90 06		bcc $210b				BCC	PUPX1				; A < 'a' so can't be lowercase char
.2105	c9 7b		cmp #$7b				CMP	#'z'+1
.2107	b0 02		bcs $210b				BCS	PUPX1				; A > 'z', so can't be lowercase char
.2109	e9 1f		sbc #$1f				SBC	#'a'-'A'-1			; Adjust upper case to lower case
.210b					PUPX1
.210b	60		rts					RTS
.210c					CMD_DUMPHEX
.210c	20 a8 22	jsr $22a8				JSR	JUSTCR				; Give some space
.210f	20 5b 20	jsr $205b				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.2112	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.2115	f0 03		beq $211a				BEQ	CDH_NOTEOL		; Not EOL, so start dumping data
.2117	82 d6 00	brl $21f0				BRL	DHEXX2			; We hit an EOL before an actionable character, so quit
.211a					CDH_NOTEOL
.211a	9c 08 05	stz $0508				STZ	BYTECNT			; First line and every 16 bytes will show current address
.211d	20 7e 20	jsr $207e				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.2120	20 1c 24	jsr $241c				JSR	CONVHEX			; Get starting address in HEXIO
.2123	ad 0b 05	lda $050b				LDA	HEXIO_B			; Put starting address in PTR
.2126	85 e4		sta $e4					STA	PTR_B
.2128	ad 0a 05	lda $050a				LDA	HEXIO_H
.212b	85 e3		sta $e3					STA	PTR_H
.212d	ad 09 05	lda $0509				LDA	HEXIO_L
.2130	85 e2		sta $e2					STA	PTR_L
.2132	20 5b 20	jsr $205b				JSR	FINDSTART		;Get next parameter
.2135	ad 07 05	lda $0507				LDA	EOLFLAG			; is there one?
.2138	f0 0b		beq $2145				BEQ	DHSAVEA			; save end address if not EOL after start address read
.213a	64 e7		stz $e7					STZ	CTR_B
.213c	64 e6		stz $e6					STZ	CTR_H
.213e	a9 01		lda #$01				LDA	#1
.2140	85 e5		sta $e5					STA	CTR_L
.2142	82 3b 00	brl $2180				BRL	DUMPITNOW
.2145					DHSAVEA
.2145	20 7e 20	jsr $207e				JSR	FINDEND
.2148	20 1c 24	jsr $241c				JSR	CONVHEX			; get 8 to 24 bit end address
.214b	ad 0b 05	lda $050b				LDA	HEXIO_B
.214e	85 ed		sta $ed					STA	EA_B
.2150	ad 0a 05	lda $050a				LDA	HEXIO_H
.2153	85 ec		sta $ec					STA	EA_H
.2155	ad 09 05	lda $0509				LDA	HEXIO_L
.2158	85 eb		sta $eb					STA	EA_L
.215a	38		sec					SEC
.215b	a5 eb		lda $eb					LDA	EA_L
.215d	e5 e2		sbc $e2					SBC	PTR_L
.215f	85 e5		sta $e5					STA	CTR_L
.2161	a5 ec		lda $ec					LDA	EA_H
.2163	e5 e3		sbc $e3					SBC	PTR_H
.2165	85 e6		sta $e6					STA	CTR_H
.2167	a5 ed		lda $ed					LDA	EA_B
.2169	e5 e4		sbc $e4					SBC	PTR_B			; Just to be thorough, should we support > 64K dump someday
.216b	85 e7		sta $e7					STA	CTR_B
.216d	18		clc					CLC						; Probably can make this more efficient
.216e	a5 e5		lda $e5					LDA	CTR_L			; Calculate byte count of dump in CTR
.2170	69 01		adc #$01				ADC	#1
.2172	85 e5		sta $e5					STA	CTR_L
.2174	a5 e6		lda $e6					LDA	CTR_H
.2176	69 00		adc #$00				ADC	#0
.2178	85 e6		sta $e6					STA	CTR_H
.217a	a5 e7		lda $e7					LDA	CTR_B
.217c	69 00		adc #$00				ADC	#0
.217e	85 e7		sta $e7					STA	CTR_B
.2180					DUMPITNOW
.2180	a5 e5		lda $e5					LDA	CTR_L			; Check for done
.2182	05 e6		ora $e6					ORA	CTR_H
.2184	05 e7		ora $e7					ORA	CTR_B
.2186	f0 68		beq $21f0				BEQ 	DHEXX1			; We're done
.2188	ad 08 05	lda $0508				LDA	BYTECNT
.218b	d0 24		bne $21b1				BNE	DUMPITN1		;
.218d					DHEXC6
.218d	20 a8 22	jsr $22a8				JSR	JUSTCR
.2190	a5 e4		lda $e4					LDA	PTR_B
.2192	8d 0b 05	sta $050b				STA	HEXIO_B
.2195	a5 e3		lda $e3					LDA	PTR_H
.2197	8d 0a 05	sta $050a				STA	HEXIO_H
.219a	a5 e2		lda $e2					LDA	PTR_L
.219c	8d 09 05	sta $0509				STA	HEXIO_L
.219f	20 40 25	jsr $2540				JSR	PUTHEX24		; Print the address
.21a2	a9 3a		lda #$3a				LDA	#':'
.21a4	20 de 22	jsr $22de				JSR	PUTCHAR
.21a7	a9 20		lda #$20				LDA	#SP
.21a9	20 de 22	jsr $22de				JSR	PUTCHAR			;
.21ac	a9 20		lda #$20				LDA	#SP
.21ae	20 de 22	jsr $22de				JSR	PUTCHAR
.21b1					DUMPITN1
.21b1	a7 e2		lda [$e2]				LDA	[PTR]			; Dump CTR bytes starting at [PTR]
.21b3	20 58 25	jsr $2558				JSR	PUTHEXA
.21b6	a9 20		lda #$20				LDA	#' '
.21b8	20 de 22	jsr $22de				JSR	PUTCHAR
.21bb	18		clc					CLC
.21bc	a5 e2		lda $e2					LDA	PTR_L
.21be	69 01		adc #$01				ADC	#1
.21c0	85 e2		sta $e2					STA	PTR_L
.21c2	a5 e3		lda $e3					LDA	PTR_H
.21c4	69 00		adc #$00				ADC	#0
.21c6	85 e3		sta $e3					STA	PTR_H
.21c8	a5 e4		lda $e4					LDA	PTR_B
.21ca	69 00		adc #$00				ADC	#0
.21cc	85 e4		sta $e4					STA	PTR_B
.21ce					DHEXC3
.21ce	38		sec					SEC
.21cf	a5 e5		lda $e5					LDA	CTR_L			; one less byte to print out
.21d1	e9 01		sbc #$01				SBC	#1
.21d3	85 e5		sta $e5					STA	CTR_L
.21d5	a5 e6		lda $e6					LDA	CTR_H
.21d7	e9 00		sbc #$00				SBC	#0
.21d9	85 e6		sta $e6					STA	CTR_H
.21db	a5 e7		lda $e7					LDA	CTR_B
.21dd	e9 00		sbc #$00				SBC	#0
.21df	85 e7		sta $e7					STA	CTR_B
.21e1	ee 08 05	inc $0508				INC 	BYTECNT
.21e4	ad 08 05	lda $0508				LDA	BYTECNT
.21e7	c9 10		cmp #$10				CMP	#16
.21e9	d0 95		bne $2180				BNE	DUMPITNOW
.21eb	9c 08 05	stz $0508				STZ	BYTECNT
.21ee	80 90		bra $2180				BRA	DUMPITNOW		; Print the address at start of new line
.21f0					DHEXX1
.21f0					DHEXX2
.21f0	60		rts					RTS
.21f1					CMD_WRITEBYTES
.21f1	20 a8 22	jsr $22a8				JSR	JUSTCR			; Give some space
.21f4	20 5b 20	jsr $205b				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.21f7	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.21fa	d0 5e		bne $225a				BNE	CWBXX2			; We hit an EOL before an actionable character, so quit
.21fc	20 7e 20	jsr $207e				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.21ff	20 1c 24	jsr $241c				JSR	CONVHEX			; Get starting address in HEXIO
.2202	ad 0b 05	lda $050b				LDA	HEXIO_B			; Transfer starting address from HEXIO to PTR
.2205	85 e4		sta $e4					STA	PTR_B
.2207	ad 0a 05	lda $050a				LDA	HEXIO_H
.220a	85 e3		sta $e3					STA	PTR_H
.220c	ad 09 05	lda $0509				LDA	HEXIO_L
.220f	85 e2		sta $e2					STA	PTR_L
.2211					CWLOOP1
.2211	20 5b 20	jsr $205b				JSR	FINDSTART		; Get next byte
.2214	ad 07 05	lda $0507				LDA	EOLFLAG
.2217	d0 41		bne $225a				BNE	CWBXX2
.2219	20 7e 20	jsr $207e				JSR	FINDEND			; Find end of Parameter
.221c	20 f5 23	jsr $23f5				JSR	RDHEX8
.221f	87 e2		sta [$e2]				STA	[PTR]			; Attempt to store.  If ROM, output will show failure to write
.2221	a5 e4		lda $e4					LDA	PTR_B
.2223	8d 0b 05	sta $050b				STA	HEXIO_B
.2226	a5 e3		lda $e3					LDA	PTR_H
.2228	8d 0a 05	sta $050a				STA	HEXIO_H
.222b	a5 e2		lda $e2					LDA	PTR_L
.222d	8d 09 05	sta $0509				STA	HEXIO_L
.2230	20 40 25	jsr $2540				JSR	PUTHEX24
.2233	a9 3c		lda #$3c				LDA	#'<'
.2235	20 de 22	jsr $22de				JSR	PUTCHAR
.2238	a9 2d		lda #$2d				LDA	#'-'
.223a	20 de 22	jsr $22de				JSR	PUTCHAR
.223d	a7 e2		lda [$e2]				LDA	[PTR]			; Read the actual byte (if ROM, won't match input)
.223f	20 58 25	jsr $2558				JSR	PUTHEXA
.2242	20 a8 22	jsr $22a8				JSR	JUSTCR
.2245	18		clc					CLC
.2246	a5 e2		lda $e2					LDA	PTR_L
.2248	69 01		adc #$01				ADC	#1
.224a	85 e2		sta $e2					STA	PTR_L
.224c	a5 e3		lda $e3					LDA	PTR_H
.224e	69 00		adc #$00				ADC	#0
.2250	85 e3		sta $e3					STA	PTR_H
.2252	a5 e4		lda $e4					LDA	PTR_B
.2254	69 00		adc #$00				ADC	#0
.2256	85 e4		sta $e4					STA	PTR_B
.2258	80 b7		bra $2211				BRA	CWLOOP1
.225a					CWBXX2
.225a	60		rts					RTS
.225b					CMD_LOAD
.225b	a0 31 28	ldy #$2831				LDY	#MSG_LOAD
.225e	20 e3 22	jsr $22e3				JSR	PUT_STR
.2261	20 0f 23	jsr $230f				JSR	SREC_LOADER
.2264	60		rts					RTS
.2265					CMD_GO
.2265	20 a8 22	jsr $22a8				JSR	JUSTCR			; Give some space
.2268	20 5b 20	jsr $205b				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.226b	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.226e	d0 21		bne $2291				BNE	CGXIT1			; We hit an EOL before an actionable character, so quit
.2270	20 7e 20	jsr $207e				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.2273	20 1c 24	jsr $241c				JSR	CONVHEX			; Get starting address in HEXIO
.2276	ad 0b 05	lda $050b				LDA	HEXIO_B			; Transfer starting address from HEXIO to PTR
.2279	85 e4		sta $e4					STA	PTR_B
.227b	ad 0a 05	lda $050a				LDA	HEXIO_H
.227e	85 e3		sta $e3					STA	PTR_H
.2280	ad 09 05	lda $0509				LDA	HEXIO_L
.2283	85 e2		sta $e2					STA	PTR_L
.2285	a0 52 28	ldy #$2852				LDY	#MSG_JUMP
.2288	20 e3 22	jsr $22e3				JSR	PUT_STR
.228b	20 40 25	jsr $2540				JSR	PUTHEX24
.228e	20 a3 22	jsr $22a3				JSR	CRLF			; get rid of return address since we're not returing!
.2291					CGXIT1
.2291	60		rts					RTS						; Might return if no valid jump address
.2292					LOLWUT
.2292	20 a3 22	jsr $22a3				JSR	CRLF
.2295	a0 00 04	ldy #$0400				LDY	#CMDBUF
.2298	20 ef 22	jsr $22ef				JSR	PUT_STR_CTRL	; Display buffer contents not understood; show non-printing too!
.229b	20 a3 22	jsr $22a3				JSR	CRLF
.229e	a9 3f		lda #$3f				LDA	#'?'
.22a0	20 de 22	jsr $22de				JSR	PUTCHAR
.22a3					CRLF
.22a3	a9 0a		lda #$0a				LDA	#LF
.22a5	20 de 22	jsr $22de				JSR	PUTCHAR
.22a8					JUSTCR
.22a8	a9 0d		lda #$0d				LDA	#CR
.22aa	20 de 22	jsr $22de				JSR	PUTCHAR
.22ad	60		rts					RTS
.22ae					CMD_A
.22ae					CMD_B
.22ae					CMD_C
.22ae					CMD_D
.22ae					CMD_E
.22ae					CMD_F
.22ae					CMD_H
.22ae					CMD_I
.22ae					CMD_J
.22ae					CMD_K
.22ae					CMD_M
.22ae					CMD_N
.22ae					CMD_O
.22ae					CMD_P
.22ae					CMD_Q
.22ae					CMD_R
.22ae					CMD_S
.22ae					CMD_T
.22ae					CMD_U
.22ae					CMD_V
.22ae					CMD_X
.22ae					CMD_Y
.22ae					CMD_Z
.22ae	a0 cf 25	ldy #$25cf				LDY	#MSG_UNIMPLEMENTED
.22b1	20 e3 22	jsr $22e3				JSR	PUT_STR
.22b4	60		rts					RTS
.22b5					JUMPNOW
.22b5	a9 0d		lda #$0d				LDA	#CR
.22b7	20 de 22	jsr $22de				JSR	PUTCHAR
.22ba	dc ea 00	jmp [$00ea]				JML	[SA_B]
.22bd					ECHO
.22bd	20 10 25	jsr $2510				JSR	GETCHF
.22c0	80 fb		bra $22bd				BRA	ECHO
.22c2					BLABBER
.22c2	20 34 25	jsr $2534				JSR	TXCHDLY
.22c5	a9 2a		lda #$2a				LDA	#'*'
.22c7	8d 80 7f	sta $7f80				STA	SDR
.22ca	20 dc 24	jsr $24dc				JSR	PUTCHF
.22cd	80 f3		bra $22c2				BRA	BLABBER
.22cf					PUTCHARTR
.22cf	c9 20		cmp #$20				CMP	#$20
.22d1	b0 0b		bcs $22de				BCS	PUT_RAW
.22d3	48		pha					PHA					; Display as hex value
.22d4	a9 5c		lda #$5c				LDA	#'\'
.22d6	20 de 22	jsr $22de				JSR	PUT_RAW
.22d9	68		pla					PLA
.22da	20 58 25	jsr $2558				JSR	PUTHEXA
.22dd					PUTCRX1
.22dd	60		rts					RTS
.22de					PUTCHAR
.22de					PUT_RAW
.22de	22 4b e0 00	jsl $00e04b				JSL	RAW_PUTC
.22e2	60		rts					RTS
.22e3					PUT_STR
.22e3	b9 00 00	lda $0000,y				LDA	0,Y				; Y points directly to string
.22e6	f0 06		beq $22ee				BEQ	PUTSX
.22e8	20 de 22	jsr $22de				JSR	PUT_RAW
.22eb	c8		iny					INY						; point to next character
.22ec	80 f5		bra $22e3				BRA	PUT_STR
.22ee					PUTSX
.22ee	60		rts					RTS
.22ef					PUT_STR_CTRL
.22ef	b9 00 00	lda $0000,y				LDA	0,Y				; Y points directly to string
.22f2	f0 06		beq $22fa				BEQ	PUTSRX
.22f4	20 cf 22	jsr $22cf				JSR	PUTCHARTR		; Show control characters, etc.
.22f7	c8		iny					INY						; point to next character
.22f8	80 f5		bra $22ef				BRA	PUT_STR_CTRL
.22fa					PUTSRX
.22fa	60		rts					RTS
.22fb					GET_RAW
.22fb	22 36 e0 00	jsl $00e036				JSL	RAW_GETC
.22ff					GRXIT1
.22ff	60		rts					RTS
.2300					GETCHAR
.2300	a5 43		lda $43					LDA	TERMFLAGS		; relying on W265 SBC char in buffer (temporarily)
.2302	29 df		and #$df				AND	#%11011111		; Turn off ECHO
.2304	09 10		ora #$10				ORA	#%00010000		; Turn off hardware handshaking to 265 (not run)
.2306	85 43		sta $43					STA 	TERMFLAGS
.2308	20 fb 22	jsr $22fb				JSR	GET_RAW
.230b	20 01 21	jsr $2101				JSR	TOPUPPER		; Make alphabetics Puppercase
.230e	60		rts					RTS
.230f					SREC_LOADER
.230f					SYNC
.230f	20 00 23	jsr $2300				JSR	GETCHAR				; Wait for "S" to start a new record
.2312	c9 53		cmp #$53				CMP	#'S'
.2314	d0 f9		bne $230f				BNE	SYNC
.2316	a9 40		lda #$40				LDA	#'@'
.2318	20 de 22	jsr $22de				JSR	PUTCHAR
.231b	20 00 23	jsr $2300				JSR	GETCHAR
.231e	85 e0		sta $e0					STA	REC_TYPE
.2320	20 61 24	jsr $2461				JSR	GETHEX				; Get message length byte
.2323	85 ee		sta $ee					STA	DATA_CNT			; Save number of bytes in record
.2325	a5 e0		lda $e0					LDA	REC_TYPE			; Decode and dispatch
.2327	f0 23		beq $234c				BEQ	GETREMS				; read the comment block
.2329	c9 31		cmp #$31				CMP	#'1'
.232b	f0 3e		beq $236b				BEQ	GET16ADDR
.232d	c9 32		cmp #$32				CMP	#'2'
.232f	f0 27		beq $2358				BEQ	GET24ADDR
.2331	c9 35		cmp #$35				CMP	#'5'
.2333	d0 02		bne $2337				BNE	SLC4
.2335	80 64		bra $239b				BRA	CNT16
.2337					SLC4
.2337	c9 36		cmp #$36				CMP	#'6'
.2339	d0 02		bne $233d				BNE	SLC2
.233b	80 67		bra $23a4				BRA	CNT24
.233d					SLC2
.233d	c9 38		cmp #$38				CMP	#'8'
.233f	d0 03		bne $2344				BNE	SLC1
.2341	82 85 00	brl $23c9				BRL	SA24		; Too far for relative branch
.2344					SLC1
.2344	c9 39		cmp #$39				CMP	#'9'
.2346	d0 02		bne $234a				BNE	SLC3
.2348	80 76		bra $23c0				BRA	SA16
.234a					SLC3
.234a	80 c3		bra $230f				BRA	SYNC
.234c					GETREMS
.234c	a9 30		lda #$30				LDA	#'0'
.234e	20 de 22	jsr $22de				JSR	PUTCHAR
.2351	a9 23		lda #$23				LDA	#'#'
.2353	20 de 22	jsr $22de				JSR	PUTCHAR
.2356	80 b7		bra $230f				BRA	SYNC
.2358					GET24ADDR
.2358	a9 32		lda #$32				LDA	#'2'
.235a	20 de 22	jsr $22de				JSR	PUTCHAR
.235d	a5 ee		lda $ee					LDA	DATA_CNT
.235f	38		sec					SEC
.2360	e9 04		sbc #$04				SBC	#4			; Data length -= 3 bytes address + 1 byte checksum
.2362	85 ee		sta $ee					STA	DATA_CNT	; Adjust data count to include only payload data bytes
.2364	20 61 24	jsr $2461				JSR	GETHEX
.2367	85 e4		sta $e4					STA	PTR_B
.2369	80 0e		bra $2379				BRA	GET1624
.236b					GET16ADDR
.236b	a9 31		lda #$31				LDA	#'1'
.236d	20 de 22	jsr $22de				JSR	PUTCHAR
.2370	a5 ee		lda $ee					LDA	DATA_CNT
.2372	38		sec					SEC
.2373	e9 03		sbc #$03				SBC	#3			; Data length -= 2 bytes address + 1 byte checksum
.2375	85 ee		sta $ee					STA	DATA_CNT	; Adjust data count to include only payload data bytes
.2377	64 e4		stz $e4					STZ	PTR_B		; 16 bit records.  Default Bank to 0!  (0+! NOT 0!=1)
.2379					GET1624
.2379	20 61 24	jsr $2461				JSR	GETHEX		; Got bank value (or set to 0). Now get high and low address
.237c	85 e3		sta $e3					STA	PTR_H
.237e	20 61 24	jsr $2461				JSR	GETHEX
.2381	85 e2		sta $e2					STA	PTR_L
.2383					SAVDAT:
.2383	a5 ee		lda $ee					LDA	DATA_CNT	; A record can have 0 data bytes, theoretically. So check at top
.2385	f0 0c		beq $2393				BEQ	SAVDX1		; No more data to PARSELINE
.2387					SAVDAT2
.2387	20 61 24	jsr $2461				JSR	GETHEX
.238a	87 e2		sta [$e2]				STA	[PTR]		; 24 bit indirect save
.238c	20 ea 23	jsr $23ea				JSR	INC_PTR		; Point to next byte
.238f	c6 ee		dec $ee					DEC	DATA_CNT
.2391	d0 f4		bne $2387				BNE	SAVDAT2
.2393					SAVDX1
.2393	a9 23		lda #$23				LDA	#'#'
.2395	20 de 22	jsr $22de				JSR	PUTCHAR
.2398	82 74 ff	brl $230f				BRL	SYNC		; FIXME: parse the checksum and end of line
.239b					CNT16
.239b	a9 35		lda #$35				LDA	#'5'
.239d	20 de 22	jsr $22de				JSR	PUTCHAR
.23a0	64 e7		stz $e7					STZ	CTR_B
.23a2	80 0a		bra $23ae				BRA	CN16C1
.23a4					CNT24:
.23a4	a9 36		lda #$36				LDA	#'6'
.23a6	20 de 22	jsr $22de				JSR	PUTCHAR
.23a9	20 61 24	jsr $2461				JSR	GETHEX
.23ac	85 e7		sta $e7					STA	CTR_B
.23ae					CN16C1
.23ae	20 61 24	jsr $2461				JSR	GETHEX		; bits 15-8
.23b1	85 e6		sta $e6					STA	CTR_H
.23b3	20 61 24	jsr $2461				JSR	GETHEX		; bits 7-0
.23b6	85 e5		sta $e5					STA	CTR_L
.23b8	a9 23		lda #$23				LDA	#'#'
.23ba	20 de 22	jsr $22de				JSR	PUTCHAR
.23bd	82 4f ff	brl $230f				BRL	SYNC		; FIXME: parse the rest of the record & end of line
.23c0					SA16
.23c0	a9 39		lda #$39				LDA	#'9'
.23c2	20 de 22	jsr $22de				JSR	PUTCHAR
.23c5	64 ea		stz $ea					STZ	SA_B
.23c7	80 0a		bra $23d3				BRA	SA16C1
.23c9					SA24
.23c9	a9 38		lda #$38				LDA	#'8'
.23cb	20 de 22	jsr $22de				JSR	PUTCHAR
.23ce	20 61 24	jsr $2461				JSR	GETHEX		; length byte
.23d1	64 ea		stz $ea					STZ	SA_B
.23d3					SA16C1
.23d3	20 61 24	jsr $2461				JSR	GETHEX		; bits 15-8
.23d6	85 e9		sta $e9					STA	SA_H
.23d8	20 61 24	jsr $2461				JSR	GETHEX		; bits 7-0
.23db	85 e8		sta $e8					STA	SA_L
.23dd	a9 26		lda #$26				LDA	#'&'
.23df	20 de 22	jsr $22de				JSR	PUTCHAR
.23e2					GOEOL
.23e2	20 00 23	jsr $2300				JSR	GETCHAR
.23e5	c9 0d		cmp #$0d				CMP	#CR
.23e7	d0 f9		bne $23e2				BNE	GOEOL
.23e9	60		rts					RTS
.23ea					INC_PTR
.23ea	e6 e2		inc $e2					INC	PTR_L		; point to the next byte to save to
.23ec	d0 06		bne $23f4				BNE	INCPX1
.23ee	e6 e3		inc $e3					INC	PTR_H
.23f0	d0 02		bne $23f4				BNE	INCPX1
.23f2	e6 e4		inc $e4					INC	PTR_B
.23f4					INCPX1
.23f4	60		rts					RTS
.23f5					RDHEX8
.23f5	5a		phy					PHY
.23f6	ac 04 05	ldy $0504				LDY	PRM_SA			; Start at beginning of current parameter
.23f9					RDHX8L1
.23f9	b9 00 00	lda $0000,y				LDA	0,Y				; Get MSB from *(parameter)
.23fc	c8		iny					INY						; advance to (hopefully) ASCII LSB
.23fd	c9 3a		cmp #$3a				CMP	#':'			; Kludgey special handling for ':'
.23ff	f0 f8		beq $23f9				BEQ	RDHX8L1
.2401					RDHX8C1
.2401	20 6f 25	jsr $256f				JSR	MKNIBL
.2404	0a		asl a					ASL	A				; Note: MKNIBL ANDs off higher 4 bits, so no '1' sign extension can occur
.2405	0a		asl a					ASL	A
.2406	0a		asl a					ASL	A
.2407	0a		asl a					ASL	A				; shift left 4 because upper nibble
.2408	85 f5		sta $f5					STA	HEXASSY			; temporary storage.  Only used within this function. Can re-use in any foreground context.
.240a					RDHX8L2
.240a	b9 00 00	lda $0000,y				LDA	0,Y				; Get LSB *(parameter+1)
.240d	c8		iny					INY					; point to next ASCII hex byte (if any)
.240e	c9 3a		cmp #$3a				CMP	#':'
.2410	f0 f8		beq $240a				BEQ	RDHX8L2			; Anti-metamucel (ignore colons) Note pathological buffer with all ':' is possible.  We will tolerate.
.2412	8c 04 05	sty $0504				STY	PRM_SA			;	"
.2415	20 6f 25	jsr $256f				JSR	MKNIBL
.2418	05 f5		ora $f5					ORA	HEXASSY			; Assemble the parts
.241a	7a		ply					PLY
.241b	60		rts					RTS						; return the byte in A
.241c					CONVHEX
.241c	9c 0b 05	stz $050b				STZ	HEXIO_B			; Only write bytes explicitly set in buffer parameter string, else 0
.241f	9c 0a 05	stz $050a				STZ	HEXIO_H
.2422	9c 09 05	stz $0509				STZ	HEXIO_L
.2425	ad 06 05	lda $0506				LDA	PRM_SIZ			; 24 bit cases are "00:1234" or "001234", 16 bit is "1234", 8 bit is "2A"
.2428	c9 02		cmp #$02				CMP	#2				; See if not even 8 bits (must be two digits to qualify as a hex value by fiat)
.242a	90 34		bcc $2460				BCC	CVHKWIT			; Too short to be a valid hex parameter.  Must be 2 or more characters
.242c	c9 03		cmp #$03				CMP	#3
.242e	b0 08		bcs $2438				BCS	CHXCHK16
.2430	20 f5 23	jsr $23f5				JSR	RDHEX8
.2433	8d 09 05	sta $0509				STA	HEXIO_L
.2436	80 28		bra $2460				BRA	CVHKWIT
.2438					CHXCHK16
.2438	c9 05		cmp #$05				CMP	#5
.243a	b0 0e		bcs $244a				BCS	CHXCHK24
.243c	20 f5 23	jsr $23f5				JSR	RDHEX8
.243f	8d 0a 05	sta $050a				STA	HEXIO_H
.2442	20 f5 23	jsr $23f5				JSR	RDHEX8
.2445	8d 09 05	sta $0509				STA	HEXIO_L
.2448	80 16		bra $2460				BRA	CVHKWIT
.244a					CHXCHK24
.244a	c9 08		cmp #$08				CMP	#8
.244c	b0 12		bcs $2460				BCS	CVHKWIT			; Give up if >= 8 characters!
.244e	20 f5 23	jsr $23f5				JSR	RDHEX8
.2451	8d 0b 05	sta $050b				STA	HEXIO_B
.2454	20 f5 23	jsr $23f5				JSR	RDHEX8
.2457	8d 0a 05	sta $050a				STA	HEXIO_H
.245a	20 f5 23	jsr $23f5				JSR	RDHEX8
.245d	8d 09 05	sta $0509				STA	HEXIO_L
.2460					CVHKWIT
.2460	60		rts					RTS
.2461					GETHEX
.2461	20 00 23	jsr $2300				JSR 	GETCHAR
.2464	c9 03		cmp #$03				CMP	#CTRL_C
.2466	d0 0b		bne $2473				BNE	GHECC1
.2468	a9 5e		lda #$5e				LDA	#'^'
.246a	20 de 22	jsr $22de				JSR	PUTCHAR
.246d	a9 43		lda #$43				LDA	#'C'
.246f	20 de 22	jsr $22de				JSR	PUTCHAR
.2472	60		rts		       		 	RTS					; bail
.2473					GHECC1
.2473	20 6f 25	jsr $256f				JSR     MKNIBL  	; Convert to 0..F numeric
.2476	0a		asl a			       	 	ASL     A
.2477	0a		asl a		       		 	ASL     A
.2478	0a		asl a			        	ASL     A
.2479	0a		asl a			       	 	ASL     A       	; This is the upper nibble
.247a	29 f0		and #$f0	  	     	 	AND     #$F0
.247c	85 f2		sta $f2		       		 	STA     SUBTEMP
.247e	20 00 23	jsr $2300		        	JSR     GETCHAR
.2481	c9 03		cmp #$03				CMP	#CTRL_C
.2483	d0 0b		bne $2490				BNE	GHECC2
.2485	a9 5e		lda #$5e				LDA	#'^'
.2487	20 de 22	jsr $22de				JSR	PUTCHAR
.248a	a9 43		lda #$43				LDA	#'C'
.248c	20 de 22	jsr $22de				JSR	PUTCHAR
.248f	60		rts					RTS					; bail
.2490					GHECC2
.2490	20 6f 25	jsr $256f				JSR     MKNIBL
.2493	05 f2		ora $f2		        		ORA    	SUBTEMP
.2495	60		rts		        		RTS
=$01					FIFO_TXE = PB0
=$02					FIFO_RXF = PB1
=$04					FIFO_WR = PB2
=$08					FIFO_RD = PB3
=$20					FIFO_PWREN = PB5
=$80					FIFO_DEBUG = PB7		; Handy debug toggle output free for any use
.2496					SEL_BANK3
.2496	a9 ff		lda #$ff				LDA	#%11111111
.2498	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.249b	60		rts					RTS
.249c					SEL_BANK2
.249c	a9 fd		lda #$fd				LDA	#%11111101
.249e	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.24a1	60		rts					RTS
.24a2					SEL_BANK1
.24a2	a9 df		lda #$df				LDA	#%11011111
.24a4	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.24a7	60		rts					RTS
.24a8					SEL_BANK0
.24a8	a9 dd		lda #$dd				LDA	#%11011101
.24aa	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.24ad	60		rts					RTS
.24ae					INIT_SYSVIA
.24ae	a9 ff		lda #$ff				LDA	#%11111111
.24b0	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.24b3	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA
.24b6	9c e2 7f	stz $7fe2				STZ	SYSTEM_VIA_DDRB
.24b9	60		rts					RTS
.24ba					INIT_FIFO
.24ba	a9 ff		lda #$ff				LDA	#$FF
.24bc	8d ec 7f	sta $7fec				STA     SYSTEM_VIA_PCR			; CB2=FAMS=flash A16=1;  CA2=FA15=A15=1; Select flash Bank #3
.24bf	9c eb 7f	stz $7feb				STZ 	SYSTEM_VIA_ACR			; Disable PB7, shift register, timer T1 interrupt.  Not absolutely required while interrupts are disabled FIXME: set up timer
.24c2	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Set PA0-PA7 to all inputs
.24c5	9c e2 7f	stz $7fe2				STZ	SYSTEM_VIA_DDRB			; In case we're not coming off a reset, make PORT B an input and change output register when it's NOT outputting
.24c8	a9 08		lda #$08				LDA	#FIFO_RD				;
.24ca	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Avoid possible glitch by writing to output latch while Port B is still an input (after reset)
.24cd	a9 8c		lda #$8c				LDA	#(FIFO_RD + FIFO_WR + FIFO_DEBUG)	; Make FIFO RD & WR pins outputs so we can strobe data in and out of the FIFO
.24cf	8d e2 7f	sta $7fe2				STA	SYSTEM_VIA_DDRB			; Port B: PB2 and PB3 are outputs; rest are inputs from earlier IORB write
.24d2	60		rts					RTS								; FUBAR - don't wait on the FIFO which stupidly may not even have power if not USB powered
.24d3					FIFOPWR
.24d3	ea		nop					NOP								; FIXME: Defensive and possibly unnecessary
.24d4	ad e0 7f	lda $7fe0				LDA	SYSTEM_VIA_IORB
.24d7	29 20		and #$20				AND	#FIFO_PWREN				; PB5 = PWRENB. 0=enabled 1=disabled
.24d9	d0 f8		bne $24d3				BNE	FIFOPWR
.24db	60		rts					RTS
.24dc					PUTCHF
.24dc	85 f1		sta $f1					STA	TEMP2
.24de	ad e0 7f	lda $7fe0				LDA	SYSTEM_VIA_IORB			; Read in FIFO status Port for FIFO
.24e1	29 01		and #$01				AND	#FIFO_TXE				; If TXE is low, we can accept data into FIFO.  If high, return immmediately
.24e3	38		sec					SEC								; FIFO is full, so don't try to queue it!
.24e4	d0 27		bne $250d				BNE	OFX1					; 0 = OK to write to FIFO; 1 = Wait, FIFO full!
.24e6					OFCONT
.24e6	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; (Defensive) Start with Port A input/floating
.24e9	a9 8c		lda #$8c				LDA	#(FIFO_RD + FIFO_WR + FIFO_DEBUG)	; RD=1 WR=1 (WR must go 1->0 for FIFO write)
.24eb	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Make sure write is high (and read too!)
.24ee	a5 f1		lda $f1					LDA	TEMP2					; Restore the data to send
.24f0	8d e1 7f	sta $7fe1				STA	SYSTEM_VIA_IORA			; Set up output value in advance in Port A (still input so doesn't go out yet)
.24f3	a9 ff		lda #$ff				LDA	#$FF					; make Port A all outputs with stable output value already set in prior lines
.24f5	8d e3 7f	sta $7fe3				STA	SYSTEM_VIA_DDRA			; Save data to output latches
.24f8	ea		nop					NOP								; Some settling time of data output just to be safe
.24f9	ea		nop					NOP
.24fa	ea		nop					NOP
.24fb	ea		nop					NOP
.24fc	ea		nop					NOP
.24fd	ea		nop					NOP
.24fe	a9 08		lda #$08				LDA	#(FIFO_RD)			; RD=1 WR=0 (WR1->0 transition triggers FIFO transfer!)
.2500	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB		; Low-going WR pulse should latch data
.2503	ea		nop					NOP	; Hold time following write strobe, to ensure value is latched OK
.2504	ea		nop					NOP
.2505	ea		nop					NOP
.2506	ea		nop					NOP
.2507	ea		nop					NOP
.2508	ea		nop					NOP
.2509	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA		; Make port A an input again
.250c	18		clc					CLC				; signal success of write to caller
.250d					OFX1
.250d	a5 f1		lda $f1					LDA	TEMP2
.250f	60		rts					RTS
.2510					GETCHF
.2510	ad e0 7f	lda $7fe0				LDA	SYSTEM_VIA_IORB		; Check RXF flag
.2513	29 02		and #$02				AND	#FIFO_RXF			; If clear, we're OK to read.  If set, there's no data waiting
.2515	38		sec					SEC
.2516	d0 1b		bne $2533				BNE 	INFXIT				; If RXF is 1, then no character is waiting!
.2518	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA		; Make Port A inputs
.251b	a9 08		lda #$08				LDA	#FIFO_RD
.251d	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB		; RD=1 WR=0 (RD must go to 0 to read
.2520	ea		nop					NOP
.2521	9c e0 7f	stz $7fe0				STZ	SYSTEM_VIA_IORB		; RD=0 WR=0	- FIFO presents data to port A
.2524	ea		nop					NOP
.2525	ea		nop					NOP
.2526	ea		nop					NOP
.2527	ea		nop					NOP
.2528	ad e1 7f	lda $7fe1				LDA	SYSTEM_VIA_IORA		; read data in
.252b	48		pha					PHA
.252c	a9 08		lda #$08				LDA	#FIFO_RD		; Restore back to inactive signals RD=1 and WR=0
.252e	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB
.2531	68		pla					PLA
.2532	18		clc					CLC				; we got a byte!
.2533					INFXIT
.2533	60		rts					RTS
=$0940					TX_DLY_CYCLES = $0940			; Not tuned.  As it's temporary, optimum settings are unimportant.
.2534					TXCHDLY
.2534	5a		phy					PHY
.2535	a0 40 09	ldy #$0940				LDY	#TX_DLY_CYCLES		; FIXME: Very bad work-around until timers are up
.2538					DLY_Y
.2538	88		dey					DEY
.2539	ea		nop					NOP
.253a	ea		nop					NOP
.253b	ea		nop					NOP
.253c	d0 fa		bne $2538				BNE	DLY_Y
.253e	7a		ply					PLY
.253f	60		rts					RTS
.2540					PUTHEX24:
.2540	ad 0b 05	lda $050b				LDA	HEXIO_B
.2543	20 58 25	jsr $2558				JSR	PUTHEXA
.2546	a9 3a		lda #$3a				LDA	#':'
.2548	20 de 22	jsr $22de				JSR	PUTCHAR
.254b					PUTHEX16:
.254b	ad 0a 05	lda $050a				LDA	HEXIO_H
.254e	20 58 25	jsr $2558				JSR	PUTHEXA
.2551					PUTHEX8:
.2551	ad 09 05	lda $0509				LDA	HEXIO_L
.2554	20 58 25	jsr $2558				JSR	PUTHEXA
.2557	60		rts					RTS
.2558					PUTHEXA
.2558	48		pha					PHA             	;
.2559	4a		lsr a		        		LSR 	A
.255a	4a		lsr a		        		LSR 	A
.255b	4a		lsr a					LSR 	A
.255c	4a		lsr a					LSR 	A
.255d	20 61 25	jsr $2561	        		JSR     PRNIBL
.2560	68		pla		        		PLA
.2561					PRNIBL
.2561	29 0f		and #$0f				AND     #$0F    	; strip off the low nibble
.2563	c9 0a		cmp #$0a	       		 	CMP     #$0A
.2565	90 02		bcc $2569	       		 	BCC  	NOTHEX  	; if it's 0-9, add '0' else also add 7
.2567	69 06		adc #$06	       		 	ADC     #6      	; Add 7 (6+carry=1), result will be carry clear
.2569					NOTHEX
.2569	69 30		adc #$30				ADC     #'0'    	; If carry clear, we're 0-9
.256b					PUTCH
.256b	20 de 22	jsr $22de				JSR	PUTCHAR
.256e	60		rts					RTS
.256f					MKNIBL
.256f	c9 3a		cmp #$3a				CMP     #'9'+1  	; See if it's 0-9 or 'A'..'F' (no lowercase yet)
.2571	90 02		bcc $2575	 		       	BCC     MKNNH   	; If we borrowed, we lost the carry so 0..9
.2573	e9 08		sbc #$08	        		SBC     #7+1    	; Subtract off extra 7 (sbc subtracts off one less)
.2575					MKNNH
.2575	e9 2f		sbc #$2f				SBC     #'0'-1  	; subtract off '0' (if carry clear coming in)
.2577	29 0f		and #$0f	        		AND     #$0F    	; no upper nibble no matter what
.2579	60		rts		        		RTS             	; and return the nibble
=$1e					SCTL_V  = %00011110       ; 9600 baud, 8 bits, 1 stop bit, rxclock = txclock
=$0b					SCMD_V  = %00001011       ; No parity, no echo, no tx or rx IRQ (for now), DTR*
.257a					INIT_SER
.257a	a9 1e		lda #$1e				LDA     #SCTL_V 	; 9600,n,8,1.  rxclock = txclock
.257c	8d 83 7f	sta $7f83				STA 	SCTL
.257f	a9 0b		lda #$0b				LDA     #SCMD_V 	; No parity, no echo, no tx or rx IRQ (for now), DTR*
.2581	8d 82 7f	sta $7f82				STA     SCMD
.2584	60		rts					RTS
.2585					GETSER
.2585	ad 81 7f	lda $7f81				LDA	SSR
.2588	29 08		and #$08				AND	#RX_RDY
.258a	f0 f9		beq $2585				BEQ	GETSER
.258c	ad 80 7f	lda $7f80				LDA	SDR
.258f	18		clc					CLC					; Temporary compatibility return value for blocking/non-blocking
.2590	60		rts					RTS
.2591					PUTSER
.2591	48		pha					PHA
.2592	8d 80 7f	sta $7f80				STA	SDR
.2595	20 34 25	jsr $2534				JSR	TXCHDLY		; Awful kludge
.2598	68		pla					PLA
.2599	18		clc					CLC					; Temporary compatibility return value for integration for blocking/non-blocking
.259a	60		rts					RTS
.259b					MONTBL
>259b	ae 22							.word 	CMD_A			; Index 0 = "A"
>259d	ae 22							.word	CMD_B
>259f	ae 22							.word	CMD_C
>25a1	ae 22							.word	CMD_D
>25a3	ae 22							.word	CMD_E
>25a5	ae 22							.word	CMD_F
>25a7	65 22							.word	CMD_GO
>25a9	ae 22							.word	CMD_H
>25ab	ae 22							.word	CMD_I
>25ad	65 22							.word	CMD_GO
>25af	ae 22							.word	CMD_K
>25b1	5b 22							.word	CMD_LOAD
>25b3	ae 22							.word	CMD_M
>25b5	ae 22							.word	CMD_N
>25b7	ae 22							.word	CMD_O
>25b9	ae 22							.word	CMD_P
>25bb	ae 22							.word	CMD_Q
>25bd	0c 21							.word	CMD_DUMPHEX
>25bf	ae 22							.word	CMD_S
>25c1	ae 22							.word	CMD_T
>25c3	ae 22							.word	CMD_U
>25c5	ae 22							.word	CMD_V
>25c7	f1 21							.word	CMD_WRITEBYTES
>25c9	ae 22							.word	CMD_X
>25cb	ae 22							.word	CMD_Y
>25cd	ae 22							.word	CMD_Z
.25cf					MSG_UNIMPLEMENTED
>25cf	0d 55 6e 69 6d 70 6c 65				.text	CR,"Unimplemented instruction",CR
>25d7	6d 65 6e 74 65 64 20 69 6e 73 74 72 75 63 74 69
>25e7	6f 6e 0d
>25ea	00						.text	0
.25eb					MSG_JUMPING
>25eb	0d 4a 75 6d 70 69 6e 67				.text	CR,"Jumping to address: $"
>25f3	20 74 6f 20 61 64 64 72 65 73 73 3a 20 24
>2601	00						.text	0
.2602					MSG_LOADER
>2602	0d 4c 6f 61 64 65 72 20				.text	CR,"Loader started!",CR
>260a	73 74 61 72 74 65 64 21 0d
>2613	00						.text 	0
.2614					MSG_6HEX
>2614	0d 45 6e 74 65 72 20 36				.text	CR,"Enter 6 digit hex address:",0
>261c	20 64 69 67 69 74 20 68 65 78 20 61 64 64 72 65
>262c	73 73 3a 00
.2630					MSG_CONFIRM
>2630	0d 49 73 20 74 68 69 73				.text	CR,"Is this correct (Y/x)?:",0
>2638	20 63 6f 72 72 65 63 74 20 28 59 2f 78 29 3f 3a
>2648	00
.2649					QBFMSG
>2649	0d 0d						.text 		CR,CR
>264b	20 20 20 20 20 20 20 20				.text	"                  VCBmon v 1.00",CR
>2653	20 20 20 20 20 20 20 20 20 20 56 43 42 6d 6f 6e
>2663	20 76 20 31 2e 30 30 0d
>266b	20 20 20 20 20 20 20 20				.text 	"          ******************************",CR
>2673	20 20 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>2683	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>2693	0d
>2694	20 20 20 20 20 20 20 20				.text 	"          *                            *",CR
>269c	20 20 2a 20 20 20 20 20 20 20 20 20 20 20 20 20
>26ac	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 2a
>26bc	0d
>26bd	20 20 20 20 20 20 20 20				.text 	"          *    The Quick brown Dog     *",CR
>26c5	20 20 2a 20 20 20 20 54 68 65 20 51 75 69 63 6b
>26d5	20 62 72 6f 77 6e 20 44 6f 67 20 20 20 20 20 2a
>26e5	0d
>26e6	20 20 20 20 20 20 20 20				.text 	"          *  Jumps over the Lazy Fox!  *",CR
>26ee	20 20 2a 20 20 4a 75 6d 70 73 20 6f 76 65 72 20
>26fe	74 68 65 20 4c 61 7a 79 20 46 6f 78 21 20 20 2a
>270e	0d
>270f	20 20 20 20 20 20 20 20				.text 	"          *                            *",CR
>2717	20 20 2a 20 20 20 20 20 20 20 20 20 20 20 20 20
>2727	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 2a
>2737	0d
>2738	20 20 20 20 20 20 20 20				.text 	"          ******************************",CR
>2740	20 20 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>2750	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>2760	0d
.2761					PROMPT
>2761	0d						.text	CR
>2762	20 20 20 20 20 20 20 20				.text	"        _,-=._              /|_/|",CR
>276a	5f 2c 2d 3d 2e 5f 20 20 20 20 20 20 20 20 20 20
>277a	20 20 20 20 2f 7c 5f 2f 7c 0d
>2784	20 20 20 20 20 20 20 2a		 		.text	"       *-.}   `=._,.-=-._.,  @ @._,",CR
>278c	2d 2e 7d 20 20 20 60 3d 2e 5f 2c 2e 2d 3d 2d 2e
>279c	5f 2e 2c 20 20 40 20 40 2e 5f 2c 0d
>27a8	20 20 20 20 20 20 20 20		 		.text   "          `._ _,-.   )      _,.-'",CR
>27b0	20 20 60 2e 5f 20 5f 2c 2d 2e 20 20 20 29 20 20
>27c0	20 20 20 20 5f 2c 2e 2d 27 0d
>27ca	20 20 20 20 20 20 20 20				 .text   "             `    G.m-'^m'm'",CR,CR
>27d2	20 20 20 20 20 60 20 20 20 20 47 2e 6d 2d 27 5e
>27e2	6d 27 6d 27 0d 0d
>27e8	00				   		 .text	0
.27e9					ANYKEY
>27e9	0a 0a						.text	LF,LF
>27eb	50 72 65 73 73 20 74 68				.text 	"Press the ANY key (CTRL-C) to return to monitor",CR
>27f3	65 20 41 4e 59 20 6b 65 79 20 28 43 54 52 4c 2d
>2803	43 29 20 74 6f 20 72 65 74 75 72 6e 20 74 6f 20
>2813	6d 6f 6e 69 74 6f 72 0d
>281b	65 6c 73 65 20 63 6f 6e				.text   "else continue foxing:"
>2823	74 69 6e 75 65 20 66 6f 78 69 6e 67 3a
>2830	00						.text	0
.2831					MSG_LOAD
>2831	0d 53 45 4e 44 20 53 31				.text 	CR,"SEND S19 or S28 S-RECORD file:",CR
>2839	39 20 6f 72 20 53 32 38 20 53 2d 52 45 43 4f 52
>2849	44 20 66 69 6c 65 3a 0d
>2851	00						.text 	0
.2852					MSG_JUMP
>2852	0d 4a 75 6d 70 69 6e 67				.text 	CR,"Jumping to address: $"
>285a	20 74 6f 20 61 64 64 72 65 73 73 3a 20 24
>2868	00						.text 	0
.ffe4					NCOP
>ffe4	00 20						.word	START		; COP exception in native mode
.ffe6					NBRK
>ffe6	00 20						.word	START		; BRK in native mode
.ffe8					NABORT
>ffe8	00 20						.word	START
.ffea					NNMI
>ffea	00 20						.word	START		; NMI interrupt in native mode
.ffee					NIRQ
>ffee	00 20						.word	START
.fff4					ECOP
>fff4	00 20						.word	START		; COP exception in 65c02 emulation mode
.fff8					EABORT
>fff8	00 20						.word	START
.fffa					ENMI
>fffa	00 20						.word	START		; NMI interrupt in 65c02 emulation mode
.fffc					ERESET
>fffc	00 20						.word	START		; RESET exception in all modes
.fffe					EIRQ
>fffe	00 20						.word	START

;******  End of listing
