
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -L monitor.lst --intel-hex -o monitor.hex monitor.asm
; Tue Jul 16 08:26:44 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: monitor.asm


;******  Processing file: via_symbols.inc

=$7fe0					SYS_VIA_BASE	    = 	$7FE0
=32736					SYSTEM_VIA_IORB     =  	SYS_VIA_BASE+0	; Port B IO register
=32737					SYSTEM_VIA_IORA     =	SYS_VIA_BASE+1 	; Port A IO register
=32738					SYSTEM_VIA_DDRB     = 	SYS_VIA_BASE+2	; Port B data direction register
=32739					SYSTEM_VIA_DDRA     = 	SYS_VIA_BASE+3	; Port A data direction register
=32740					SYSTEM_VIA_T1C_L    =	SYS_VIA_BASE+4 	; Timer 1 counter/latches, low-order
=32741					SYSTEM_VIA_T1C_H    = 	SYS_VIA_BASE+5	; Timer 1 high-order counter
=32742					SYSTEM_VIA_T1L_L    = 	SYS_VIA_BASE+6	; Timer 1 low-order latches
=32743					SYSTEM_VIA_T1L_H    = 	SYS_VIA_BASE+7	; Timer 1 high-order latches
=32744					SYSTEM_VIA_T2C_L    = 	SYS_VIA_BASE+8	; Timer 2 counter/latches, lower-order
=32745					SYSTEM_VIA_T2C_H    = 	SYS_VIA_BASE+9	; Timer 2 high-order counter
=32746					SYSTEM_VIA_SR       = 	SYS_VIA_BASE+10	; Shift register
=32747					SYSTEM_VIA_ACR      = 	SYS_VIA_BASE+11	; Auxilliary control register
=32748					SYSTEM_VIA_PCR      =	SYS_VIA_BASE+12	; Peripheral control register
=32749					SYSTEM_VIA_IFR	    =	SYS_VIA_BASE+13 ; Interrupt flag register
=32750					SYSTEM_VIA_IER      = 	SYS_VIA_BASE+14	; Interrupt enable register
=32751					SYSTEM_VIA_ORA_IRA  =	SYS_VIA_BASE+15	; Port A IO register, but no handshake
=$7fc0					DEBUG_VIA_BASE	    = 	$7FC0
=32704					DEBUG_VIA_IORB     =  	DEBUG_VIA_BASE+0	; Port B IO register
=32705					DEBUG_VIA_IORA     =	DEBUG_VIA_BASE+1 	; Port A IO register
=32706					DEBUG_VIA_DDRB     = 	DEBUG_VIA_BASE+2	; Port B data direction register
=32707					DEBUG_VIA_DDRA     = 	DEBUG_VIA_BASE+3	; Port A data direction register
=32708					DEBUG_VIA_T1C_L    =	DEBUG_VIA_BASE+4 	; Timer 1 counter/latches, low-order
=32709					DEBUG_VIA_T1C_H    = 	DEBUG_VIA_BASE+5	; Timer 1 high-order counter
=32710					DEBUG_VIA_T1L_L    = 	DEBUG_VIA_BASE+6	; Timer 1 low-order latches
=32711					DEBUG_VIA_T1L_H    = 	DEBUG_VIA_BASE+7	; Timer 1 high-order latches
=32712					DEBUG_VIA_T2C_L    = 	DEBUG_VIA_BASE+8	; Timer 2 counter/latches, lower-order
=32713					DEBUG_VIA_T2C_H    = 	DEBUG_VIA_BASE+9	; Timer 2 high-order counter
=32714					DEBUG_VIA_SR       = 	DEBUG_VIA_BASE+10	; Shift register
=32715					DEBUG_VIA_ACR      = 	DEBUG_VIA_BASE+11	; Auxilliary control register
=32716					DEBUG_VIA_PCR      =	DEBUG_VIA_BASE+12	; Peripheral control register
=32717					DEBUG_VIA_IFR	    =	DEBUG_VIA_BASE+13 ; Interrupt flag register
=32718					DEBUG_VIA_IER      = 	DEBUG_VIA_BASE+14	; Interrupt enable register
=32719					DEBUG_VIA_ORA_IRA  =	DEBUG_VIA_BASE+15	; Port A IO register, but no handshake
=$01					PB0 = MASK0
=$02					PB1 = MASK1
=$04					PB2 = MASK2
=$08					PB3 = MASK3
=$10					PB4 = MASK4
=$20					PB5 = MASK5
=$40					PB6 = MASK6
=$80					PB7 = MASK7
=$01					PA0 = MASK0
=$02					PA1 = MASK1
=$04					PA2 = MASK2
=$08					PA3 = MASK3
=$10					PA4 = MASK4
=$20					PA5 = MASK5
=$40					PA6 = MASK6
=$80					PA7 = MASK7

;******  Return to file: monitor.asm


;******  Processing file: acia_symbols.inc

=$7f80					ACIA_BASE = $7F80		; This is where the 6551 ACIA starts
=$7f80					SDR = ACIA_BASE       		; RX'ed bytes read, TX bytes written, here
=32641					SSR = ACIA_BASE+1     		; Serial data status register
=32642					SCMD = ACIA_BASE+2     		; Serial command reg. ()
=32643					SCTL = ACIA_BASE+3     		; Serial control reg. ()
=$10					TX_RDY = MASK4
=$08					RX_RDY = MASK3
=$00					ALL_INPUTS = $00
=$ff					ALL_OUTPUTS = $FF

;******  Return to file: monitor.asm

=$03					CTRL_C	= $03
=$08					BS		= $08
=$0a					LF		= $0A
=$0d					CR		= $0D
=$20					SP		= $20
=$7f					DEL     = $7F
=$01					MASK0		= %00000001
=$02					MASK1		= %00000010
=$04					MASK2		= %00000100
=$08					MASK3		= %00001000
=$10					MASK4		= %00010000
=$20					MASK5		= %00100000
=$40					MASK6 		= %01000000
=$80					MASK7		= %10000000
=$80					N_FLAG		= MASK7
=$40					V_FLAG		= MASK6
=$20					M_FLAG		= MASK5
=$10					X_FLAG		= MASK4
=$08					D_FLAG		= MASK3
=$04					I_FLAG		= MASK2
=$02					Z_FLAG		= MASK1
=$01					C_FLAG		= MASK0
=$43					TERMFLAGS = $43
=$01					RDRDY	= $01				; 1 = character waiting
=$04					XONXOFF = $04				; 0 = hardware handshake 1= XON/XOFF
=$20					ECHOOFF = $20
>00e0					REC_TYPE	.byte 	?
>00e1					DP_START	.byte	?
>00e2					PTR_L		.byte	?	; Generic pointer
>00e3					PTR_H		.byte	?
>00e4					PTR_B		.byte	?
=$e2					PTR			=		PTR_L
>00e5					CTR_L		.byte	?	; Counter
>00e6					CTR_H		.byte	?
>00e7					CTR_B		.byte	?
=$e5					CTR			= 		CTR_L
>00e8					SA_L		.byte 	?	; Starting address storage for various commands & loader
>00e9					SA_H		.byte 	?
>00ea					SA_B		.byte	?
=$e8					SA			=		SA_L
>00eb					EA_L		.byte 	?	; Starting address storage for various commands
>00ec					EA_H		.byte 	?
>00ed					EA_B		.byte	?
=$eb					EA			=		EA_L
>00ee					DATA_CNT	.byte 	?	; Count of record's actual storable data bytes
>00ef					FIFO_PIT	.byte	?
>00f0					SUBTEMP 	.byte	?	; Any subroutine that doesn't call others can use as local scratchpad space
>00f1					HEXASSY		.byte	?
>0400					CMDBUF 		.fill	256	; can be smaller than 256 but must not cross 8 bit page boundary
>0500					CB_RDPTR	.word	?	; Use LDA/STA 0,X typically
>0502					CB_WRPTR	.word 	?	; Use LAD/STA 0,Y typically
>0504					PRM_SA	.word	?		; Parameter start address
>0506					PRM_SIZ	.byte	?		; Size of current parameter
>0507					EOLFLAG	.byte	?		; 0 = EOL not found, !0 = EOL has been encountered
>0508					BYTECNT	.byte 	?
>0509					HEXIO_L	.byte	?
>050a					HEXIO_H	.byte	?
>050b					HEXIO_B	.byte	?
=$0509					HEXIO		=	HEXIO_L				; 24 bit HEX value to print
=$7eff					STACKTOP	=	$7EFF				; Top of RAM = $07EFF (I/O is $7F00-$7FFF)
.f800					START
.f800	78		sei					SEI
.f801	18		clc					CLC
.f802	fb		xce					XCE
.f803	c2 18		rep #$18				REP	#(X_FLAG | D_FLAG)
.f805	e2 20		sep #$20				SEP	#M_FLAG
.f807	a2 ff 7e	ldx #$7eff				LDX	#STACKTOP
.f80a	9a		txs					TXS
.f80b	20 43 f9	jsr $f943				JSR	INIT_FIFO
.f80e	a0 51 f0	ldy #$f051				LDY	#QBFMSG			; Start of monitor loop
.f811	20 81 fb	jsr $fb81				JSR	PUT_STR
.f814					MONGETL
.f814	20 ab f8	jsr $f8ab				JSR	GETLINE
.f817	20 36 f8	jsr $f836				JSR	PARSELINE
.f81a	80 f8		bra $f814				BRA	MONGETL			; End of monitor loop
.f81c					INITPARS
.f81c	9c 06 05	stz $0506				STZ	PRM_SIZ			; No known parameter size
.f81f	9c 07 05	stz $0507				STZ	EOLFLAG			; No EOL found yet
.f822	a2 00 04	ldx #$0400				LDX	#CMDBUF
.f825	8e 00 05	stx $0500				STX	CB_RDPTR		; Start read pointer at start of command buffer
.f828	8e 04 05	stx $0504				STX	PRM_SA			; First parameter starts at command buffer[0]
.f82b	60		rts					RTS
.f82c					CLRCMD
.f82c	a2 00 04	ldx #$0400				LDX	#CMDBUF			; Point CB_WRPTR to start of command buffer
.f82f	8e 02 05	stx $0502				STX	CB_WRPTR
.f832	9c 00 04	stz $0400				STZ	CMDBUF			; Null terminate the empty buffer
.f835	60		rts					RTS
.f836					PARSELINE
.f836	20 1c f8	jsr $f81c				JSR	INITPARS
.f839					FINDCMD
.f839	20 62 f8	jsr $f862				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.f83c	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.f83f	d0 20		bne $f861				BNE	PLIX2			; We hit an EOL before an actionable character, so quit
.f841	a9 00		lda #$00				LDA	#0
.f843	eb		xba					XBA				; Make B zero so when TAX times comes, MSB of X will be 0! (0 emphasis not 0 factorial)
.f844	ae 00 05	ldx $0500				LDX	CB_RDPTR		; point to command byte
.f847	b5 00		lda $00,x				LDA	0,X			; Get command byte
.f849	e8		inx					INX				; Point past the command byte to save each subroutine from doing this
.f84a	8e 00 05	stx $0500				STX	CB_RDPTR		; "
.f84d	c9 41		cmp #$41				CMP	#'A'
.f84f	90 0d		bcc $f85e				BCC	PLERRXIT		; < 'A', so not a command
.f851	c9 5b		cmp #$5b				CMP	#'Z'+1
.f853	b0 09		bcs $f85e				BCS	PLERRXIT		; > 'Z', so not a command
.f855	e9 40		sbc #$40				SBC	#'A'-1			; Carry clear, so subtract one less to account for borrow
.f857	0a		asl a					ASL	A			; Two bytes per JSR table entry
.f858	aa		tax					TAX						; X now holds offset in MONTABLE
.f859	fc 8d fd	jsr ($fd8d,x)				JSR	(MONTBL,X)		; No JSR indirect indexed.  Each table entry MUST end in RTS not RTL!
.f85c	80 03		bra $f861				BRA	PLIX2			; We're done dispatching.
.f85e					PLERRXIT:
.f85e	20 4b fb	jsr $fb4b				JSR	LOLWUT			; Print non-understood buffer plus ?[CR][LF]
.f861					PLIX2
.f861	60		rts					RTS
.f862					FINDSTART
.f862	ac 00 05	ldy $0500				LDY	CB_RDPTR
.f865					FSN1
.f865	b9 00 00	lda $0000,y				LDA	0,Y			; Get next character
.f868	f0 0f		beq $f879				BEQ	FSEOL			; Null --> End of line encountered.  We are done
.f86a	c9 0d		cmp #$0d				CMP	#CR
.f86c	f0 0b		beq $f879				BEQ	FSEOL			; CR = end of line also
.f86e	c9 03		cmp #$03				CMP	#CTRL_C
.f870	f0 07		beq $f879				BEQ	FSEOL			; CTRL-C = end of line
.f872	c9 21		cmp #$21				CMP	#SP+1			; if space or less, and not CR or CTRL-C, skip over
.f874	b0 08		bcs $f87e				BCS	FSDUN			; A non-whitespace character.  We're done looking
.f876	c8		iny					INY				; Keep looking for a valid parameter byte
.f877	80 ec		bra $f865				BRA	FSN1			; Next character
.f879					FSEOL
.f879	a9 01		lda #$01				LDA	#1
.f87b	8d 07 05	sta $0507				STA	EOLFLAG
.f87e					FSDUN
.f87e	8c 00 05	sty $0500				STY	CB_RDPTR		; Save pointers by current value of Y
.f881	8c 04 05	sty $0504				STY	PRM_SA			; Save pointers by current value of Y
.f884	60		rts					RTS
.f885					FINDEND
.f885	9c 06 05	stz $0506				STZ	PRM_SIZ			; No known parameter bytes yet
.f888	ac 00 05	ldy $0500				LDY	CB_RDPTR
.f88b					FEN1
.f88b	b9 00 00	lda $0000,y				LDA	0,Y			; Get next character
.f88e	f0 12		beq $f8a2				BEQ	FEEOL			; Null --> End of line encountered.  We are done
.f890	c9 0d		cmp #$0d				CMP	#CR
.f892	f0 0e		beq $f8a2				BEQ	FEEOL			; CR = end of line also
.f894	c9 03		cmp #$03				CMP	#CTRL_C
.f896	f0 0a		beq $f8a2				BEQ	FEEOL			; CTRL-C = end of line
.f898	c9 21		cmp #$21				CMP	#SP+1			; if space or less, and not CR or CTRL-C,
.f89a	90 0b		bcc $f8a7				BCC	FEDUN1			; A whitespace character.  We're done looking
.f89c	c8		iny					INY
.f89d	ee 06 05	inc $0506				INC	PRM_SIZ			; add one more to size of parameter
.f8a0	80 e9		bra $f88b				BRA	FEN1
.f8a2					FEEOL
.f8a2	a9 01		lda #$01				LDA	#1
.f8a4	8d 07 05	sta $0507				STA	EOLFLAG
.f8a7					FEDUN1
.f8a7	8c 00 05	sty $0500				STY	CB_RDPTR		; Save pointers by current value of read pointer (don't update PRM_SA)
.f8aa	60		rts					RTS
.f8ab					GETLINE
.f8ab	20 5c fb	jsr $fb5c				JSR	CRLF
.f8ae	a9 3e		lda #$3e				LDA	#'>'
.f8b0	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.f8b3	20 2c f8	jsr $f82c				JSR	CLRCMD
.f8b6					GLLP1
.f8b6	20 9c fb	jsr $fb9c				JSR	GETCHAR				; Do not echo
.f8b9	c9 0d		cmp #$0d				CMP	#CR
.f8bb	d0 05		bne $f8c2				BNE	GLNC0
.f8bd	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.f8c0	80 43		bra $f905				BRA	GLXIT1				; end of message
.f8c2					GLNC0
.f8c2	c9 03		cmp #$03				CMP	#CTRL_C
.f8c4	d0 14		bne $f8da				BNE	GLNC1
.f8c6	a9 5e		lda #$5e				LDA	#'^'
.f8c8	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.f8cb	a9 43		lda #$43				LDA	#'C'
.f8cd	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.f8d0	a9 0d		lda #$0d				LDA	#CR
.f8d2	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.f8d5	20 2c f8	jsr $f82c				JSR	CLRCMD				; zotch out any command in buffer
.f8d8	80 2b		bra $f905				BRA	GLXIT1
.f8da					GLNC1
.f8da	c9 0a		cmp #$0a				CMP	#LF
.f8dc	d0 02		bne $f8e0				BNE	GLNC2
.f8de	80 d6		bra $f8b6				BRA	GLLP1
.f8e0					GLNC2
.f8e0	c9 08		cmp #$08				CMP	#BS				; We will not tolerate BS here
.f8e2	d0 16		bne $f8fa				BNE	GLNC9
.f8e4	c9 7f		cmp #$7f				CMP	#DEL
.f8e6	d0 12		bne $f8fa				BNE	GLNC9
.f8e8	74 00		stz $00,x				STZ	0,X
.f8ea	e0 00 04	cpx #$0400				CPX	#CMDBUF
.f8ed	f0 c7		beq $f8b6				BEQ	GLLP1				; Already backed over the first character. No index to decrement
.f8ef	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.f8f2	ca		dex					DEX					; change buffer pointer
.f8f3	8e 02 05	stx $0502				STX	CB_WRPTR
.f8f6	74 00		stz $00,x				STZ	0,X				; Character we backed over is now end of string
.f8f8	80 bc		bra $f8b6				BRA	GLLP1
.f8fa					GLNC9
.f8fa	95 00		sta $00,x				STA	0,X				; store it
.f8fc	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.f8ff	e8		inx					INX
.f900	8e 02 05	stx $0502				STX	CB_WRPTR
.f903	80 b1		bra $f8b6				BRA	GLLP1
.f905					GLXIT1
.f905	74 00		stz $00,x				STZ	0,X				; null-terminate the line
.f907	60		rts					RTS
.f908					TOPUPPER
.f908	c9 61		cmp #$61				CMP	#'a'				; Make character PupperCase
.f90a	90 06		bcc $f912				BCC	PUPX1				; A < 'a' so can't be lowercase char
.f90c	c9 7b		cmp #$7b				CMP	#'z'+1
.f90e	b0 02		bcs $f912				BCS	PUPX1				; A > 'z', so can't be lowercase char
.f910	e9 1f		sbc #$1f				SBC	#'a'-'A'-1			; Adjust upper case to lower case
.f912					PUPX1
.f912	60		rts					RTS
=$01					FIFO_TXE = PB0
=$02					FIFO_RXF = PB1
=$04					FIFO_WR = PB2
=$08					FIFO_RD = PB3
=$20					FIFO_PWREN = PB5
=$80					FIFO_DEBUG = PB7		; Handy debug toggle output free for any use
.f913					PUT_FIFO
.f913	20 6b f9	jsr $f96b				JSR	PUT_FRAW
.f916	b0 fb		bcs $f913				BCS	PUT_FIFO
.f918	60		rts					RTS
.f919					GET_FIFO
.f919	20 95 f9	jsr $f995				JSR 	GET_FRAW
.f91c	b0 fb		bcs $f919				BCS	GET_FIFO
.f91e	60		rts					RTS
.f91f					SEL_BANK3
.f91f	a9 ff		lda #$ff				LDA	#%11111111
.f921	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f924	60		rts					RTS
.f925					SEL_BANK2
.f925	a9 fd		lda #$fd				LDA	#%11111101
.f927	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f92a	60		rts					RTS
.f92b					SEL_BANK1
.f92b	a9 df		lda #$df				LDA	#%11011111
.f92d	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f930	60		rts					RTS
.f931					SEL_BANK0
.f931	a9 dd		lda #$dd				LDA	#%11011101
.f933	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f936	60		rts					RTS
.f937					INIT_SYSVIA
.f937	a9 ff		lda #$ff				LDA	#$FF
.f939	8d ec 7f	sta $7fec				STA	SYSTEM_VIA_PCR
.f93c	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA
.f93f	9c e2 7f	stz $7fe2				STZ	SYSTEM_VIA_DDRB
.f942	60		rts					RTS
.f943					INIT_FIFO
.f943	a9 ff		lda #$ff				LDA	#$FF
.f945	8d ec 7f	sta $7fec				STA 	SYSTEM_VIA_PCR			; CB2=FAMS=flash A16=1;  CA2=FA15=A15=1; Select flash Bank #3
.f948	9c eb 7f	stz $7feb				STZ 	SYSTEM_VIA_ACR			; Disable PB7, shift register, timer T1 interrupt.  Not absolutely required while interrupts are disabled FIXME: set up timer
.f94b	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Set PA0-PA7 to all inputs
.f94e	9c e2 7f	stz $7fe2				STZ	SYSTEM_VIA_DDRB			; In case we're not coming off a reset, make PORT B an input and change output register when it's NOT outputting
.f951	a9 08		lda #$08				LDA	#FIFO_RD				;
.f953	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Avoid possible glitch by writing to output latch while Port B is still an input (after reset)
.f956	a9 0c		lda #$0c				LDA	#(FIFO_RD + FIFO_WR)		; Make FIFO RD & WR pins outputs so we can strobe data in and out of the FIFO
.f958	8d e2 7f	sta $7fe2				STA	SYSTEM_VIA_DDRB			; Port B: PB2 and PB3 are outputs; rest are inputs from earlier IORB write
.f95b	20 b6 f9	jsr $f9b6				JSR	TXCHDLY				; Should wait (with timeout!) on PWERENB signal going low on power up or after.
.f95e	20 b6 f9	jsr $f9b6				JSR	TXCHDLY				; Timeout is essential in case board is powered off RS232 port,
.f961	20 b6 f9	jsr $f9b6				JSR	TXCHDLY				; in which case the FIFO will not get power and this pin will never be (active) low.
.f964	20 b6 f9	jsr $f9b6				JSR	TXCHDLY
.f967	20 b6 f9	jsr $f9b6				JSR	TXCHDLY
.f96a	60		rts					RTS
.f96b					PUT_FRAW
.f96b	85 ef		sta $ef					STA	FIFO_PIT
.f96d	ad e0 7f	lda $7fe0				LDA	SYSTEM_VIA_IORB			; Read in FIFO status Port for FIFO
.f970	29 01		and #$01				AND	#FIFO_TXE				; If TXE is low, we can accept data into FIFO.  If high, return immmediately
.f972	38		sec					SEC							; FIFO is full, so don't try to queue it!
.f973	d0 1d		bne $f992				BNE	OFX1					; 0 = OK to write to FIFO; 1 = Wait, FIFO full!
.f975					OFCONT
.f975	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; (Defensive) Start with Port A input/floating
.f978	a9 0c		lda #$0c				LDA	#(FIFO_RD + FIFO_WR)	; RD=1 WR=1 (WR must go 1->0 for FIFO write)
.f97a	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Make sure write is high (and read too!)
.f97d	a5 ef		lda $ef					LDA 	FIFO_PIT			; Restore the data to send
.f97f	8d e1 7f	sta $7fe1				STA	SYSTEM_VIA_IORA			; Set up output value in advance in Port A (still input so doesn't go out yet)
.f982	a9 ff		lda #$ff				LDA	#$FF				; make Port A all outputs with stable output value already set in prior lines
.f984	8d e3 7f	sta $7fe3				STA	SYSTEM_VIA_DDRA			; Save data to output latches
.f987	ea		nop					NOP					; Some settling time of data output just to be safe
.f988	a9 08		lda #$08				LDA	#(FIFO_RD)			; RD=1 WR=0 (WR1->0 transition triggers FIFO transfer!)
.f98a	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; Low-going WR pulse should latch data
.f98d	ea		nop					NOP							; Hold time following write strobe, to ensure value is latched OK
.f98e	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Make port A an input again
.f991	18		clc					CLC					; signal success of write to caller
.f992					OFX1
.f992	a5 ef		lda $ef					LDA	FIFO_PIT
.f994	60		rts					RTS
.f995					GET_FRAW
.f995	ad e0 7f	lda $7fe0				LDA	SYSTEM_VIA_IORB			; Check RXF flag
.f998	29 02		and #$02				AND	#FIFO_RXF			; If clear, we're OK to read.  If set, there's no data waiting
.f99a	38		sec					SEC
.f99b	d0 18		bne $f9b5				BNE 	INFXIT				; If RXF is 1, then no character is waiting!
.f99d	9c e3 7f	stz $7fe3				STZ	SYSTEM_VIA_DDRA			; Make Port A inputs
.f9a0	a9 08		lda #$08				LDA	#FIFO_RD
.f9a2	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB			; RD=1 WR=0 (RD must go to 0 to read
.f9a5	ea		nop					NOP
.f9a6	9c e0 7f	stz $7fe0				STZ	SYSTEM_VIA_IORB			; RD=0 WR=0	- FIFO presents data to port A
.f9a9	ea		nop					NOP
.f9aa	ad e1 7f	lda $7fe1				LDA	SYSTEM_VIA_IORA			; read data in
.f9ad	48		pha					PHA
.f9ae	a9 08		lda #$08				LDA	#FIFO_RD			; Restore back to inactive signals RD=1 and WR=0
.f9b0	8d e0 7f	sta $7fe0				STA	SYSTEM_VIA_IORB
.f9b3	68		pla					PLA
.f9b4	18		clc					CLC					; we got a byte!
.f9b5					INFXIT
.f9b5	60		rts					RTS
=$0940					TX_DLY_CYCLES = $0940						; Not tuned.  As it's temporary, optimum settings are unimportant.
.f9b6					TXCHDLY
.f9b6	5a		phy					PHY
.f9b7	a0 40 09	ldy #$0940				LDY	#TX_DLY_CYCLES		; FIXME: Very bad work-around until timers are up
.f9ba					DLY_Y
.f9ba	88		dey					DEY
.f9bb	ea		nop					NOP
.f9bc	ea		nop					NOP
.f9bd	ea		nop					NOP
.f9be	d0 fa		bne $f9ba				BNE	DLY_Y
.f9c0	7a		ply					PLY
.f9c1	60		rts					RTS
.f9c2					CMD_DUMPHEX
.f9c2	20 5c fb	jsr $fb5c				JSR	CRLF			; Give some space
.f9c5	20 62 f8	jsr $f862				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.f9c8	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.f9cb	f0 03		beq $f9d0				BEQ	CDH_NOTEOL		; Not EOL, so start dumping data
.f9cd	82 d6 00	brl $faa6				BRL	DHEXX2			; We hit an EOL before an actionable character, so quit
.f9d0					CDH_NOTEOL
.f9d0	9c 08 05	stz $0508				STZ	BYTECNT			; First line and every 16 bytes will show current address
.f9d3	20 85 f8	jsr $f885				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.f9d6	20 b8 fc	jsr $fcb8				JSR	CONVHEX			; Get starting address in HEXIO
.f9d9	ad 0b 05	lda $050b				LDA	HEXIO_B			; Put starting address in PTR
.f9dc	85 e4		sta $e4					STA	PTR_B
.f9de	ad 0a 05	lda $050a				LDA	HEXIO_H
.f9e1	85 e3		sta $e3					STA	PTR_H
.f9e3	ad 09 05	lda $0509				LDA	HEXIO_L
.f9e6	85 e2		sta $e2					STA	PTR_L
.f9e8	20 62 f8	jsr $f862				JSR	FINDSTART		;Get next parameter
.f9eb	ad 07 05	lda $0507				LDA	EOLFLAG			; is there one?
.f9ee	f0 0b		beq $f9fb				BEQ	DHSAVEA			; save end address if not EOL after start address read
.f9f0	64 e7		stz $e7					STZ	CTR_B
.f9f2	64 e6		stz $e6					STZ	CTR_H
.f9f4	a9 01		lda #$01				LDA	#1
.f9f6	85 e5		sta $e5					STA	CTR_L
.f9f8	82 3b 00	brl $fa36				BRL	DUMPITNOW
.f9fb					DHSAVEA
.f9fb	20 85 f8	jsr $f885				JSR	FINDEND
.f9fe	20 b8 fc	jsr $fcb8				JSR	CONVHEX			; get 8 to 24 bit end address
.fa01	ad 0b 05	lda $050b				LDA	HEXIO_B
.fa04	85 ed		sta $ed					STA	EA_B
.fa06	ad 0a 05	lda $050a				LDA	HEXIO_H
.fa09	85 ec		sta $ec					STA	EA_H
.fa0b	ad 09 05	lda $0509				LDA	HEXIO_L
.fa0e	85 eb		sta $eb					STA	EA_L
.fa10	38		sec					SEC
.fa11	a5 eb		lda $eb					LDA	EA_L
.fa13	e5 e2		sbc $e2					SBC	PTR_L
.fa15	85 e5		sta $e5					STA	CTR_L
.fa17	a5 ec		lda $ec					LDA	EA_H
.fa19	e5 e3		sbc $e3					SBC	PTR_H
.fa1b	85 e6		sta $e6					STA	CTR_H
.fa1d	a5 ed		lda $ed					LDA	EA_B
.fa1f	e5 e4		sbc $e4					SBC	PTR_B			; Just to be thorough, should we support > 64K dump someday
.fa21	85 e7		sta $e7					STA	CTR_B
.fa23	18		clc					CLC				; Probably can make this more efficient
.fa24	a5 e5		lda $e5					LDA	CTR_L			; Calculate byte count of dump in CTR
.fa26	69 01		adc #$01				ADC	#1
.fa28	85 e5		sta $e5					STA	CTR_L
.fa2a	a5 e6		lda $e6					LDA	CTR_H
.fa2c	69 00		adc #$00				ADC	#0
.fa2e	85 e6		sta $e6					STA	CTR_H
.fa30	a5 e7		lda $e7					LDA	CTR_B
.fa32	69 00		adc #$00				ADC	#0
.fa34	85 e7		sta $e7					STA	CTR_B
.fa36					DUMPITNOW
.fa36	a5 e5		lda $e5					LDA	CTR_L			; Check for done
.fa38	05 e6		ora $e6					ORA	CTR_H
.fa3a	05 e7		ora $e7					ORA	CTR_B
.fa3c	f0 68		beq $faa6				BEQ 	DHEXX1			; We're done
.fa3e	ad 08 05	lda $0508				LDA	BYTECNT
.fa41	d0 24		bne $fa67				BNE	DUMPITN1		;
.fa43					DHEXC6
.fa43	20 5c fb	jsr $fb5c				JSR	CRLF
.fa46	a5 e4		lda $e4					LDA	PTR_B
.fa48	8d 0b 05	sta $050b				STA	HEXIO_B
.fa4b	a5 e3		lda $e3					LDA	PTR_H
.fa4d	8d 0a 05	sta $050a				STA	HEXIO_H
.fa50	a5 e2		lda $e2					LDA	PTR_L
.fa52	8d 09 05	sta $0509				STA	HEXIO_L
.fa55	20 32 fd	jsr $fd32				JSR	PUTHEX24		; Print the address
.fa58	a9 3a		lda #$3a				LDA	#':'
.fa5a	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fa5d	a9 20		lda #$20				LDA	#SP
.fa5f	20 7d fb	jsr $fb7d				JSR	PUTCHAR			;
.fa62	a9 20		lda #$20				LDA	#SP
.fa64	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fa67					DUMPITN1
.fa67	a7 e2		lda [$e2]				LDA	[PTR]			; Dump CTR bytes starting at [PTR]
.fa69	20 4a fd	jsr $fd4a				JSR	PUTHEXA
.fa6c	a9 20		lda #$20				LDA	#' '
.fa6e	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fa71	18		clc					CLC
.fa72	a5 e2		lda $e2					LDA	PTR_L
.fa74	69 01		adc #$01				ADC	#1
.fa76	85 e2		sta $e2					STA	PTR_L
.fa78	a5 e3		lda $e3					LDA	PTR_H
.fa7a	69 00		adc #$00				ADC	#0
.fa7c	85 e3		sta $e3					STA	PTR_H
.fa7e	a5 e4		lda $e4					LDA	PTR_B
.fa80	69 00		adc #$00				ADC	#0
.fa82	85 e4		sta $e4					STA	PTR_B
.fa84					DHEXC3
.fa84	38		sec					SEC
.fa85	a5 e5		lda $e5					LDA	CTR_L			; one less byte to print out
.fa87	e9 01		sbc #$01				SBC	#1
.fa89	85 e5		sta $e5					STA	CTR_L
.fa8b	a5 e6		lda $e6					LDA	CTR_H
.fa8d	e9 00		sbc #$00				SBC	#0
.fa8f	85 e6		sta $e6					STA	CTR_H
.fa91	a5 e7		lda $e7					LDA	CTR_B
.fa93	e9 00		sbc #$00				SBC	#0
.fa95	85 e7		sta $e7					STA	CTR_B
.fa97	ee 08 05	inc $0508				INC 	BYTECNT
.fa9a	ad 08 05	lda $0508				LDA	BYTECNT
.fa9d	c9 10		cmp #$10				CMP	#16
.fa9f	d0 95		bne $fa36				BNE	DUMPITNOW
.faa1	9c 08 05	stz $0508				STZ	BYTECNT
.faa4	80 90		bra $fa36				BRA	DUMPITNOW		; Print the address at start of new line
.faa6					DHEXX1
.faa6					DHEXX2
.faa6	60		rts					RTS
.faa7					CMD_WRITEBYTES
.faa7	20 5c fb	jsr $fb5c				JSR	CRLF			; Give some space
.faaa	20 62 f8	jsr $f862				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.faad	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.fab0	d0 5e		bne $fb10				BNE	CWBXX2			; We hit an EOL before an actionable character, so quit
.fab2	20 85 f8	jsr $f885				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.fab5	20 b8 fc	jsr $fcb8				JSR	CONVHEX			; Get starting address in HEXIO
.fab8	ad 0b 05	lda $050b				LDA	HEXIO_B			; Transfer starting address from HEXIO to PTR
.fabb	85 e4		sta $e4					STA	PTR_B
.fabd	ad 0a 05	lda $050a				LDA	HEXIO_H
.fac0	85 e3		sta $e3					STA	PTR_H
.fac2	ad 09 05	lda $0509				LDA	HEXIO_L
.fac5	85 e2		sta $e2					STA	PTR_L
.fac7					CWLOOP1
.fac7	20 62 f8	jsr $f862				JSR	FINDSTART		; Get next byte
.faca	ad 07 05	lda $0507				LDA	EOLFLAG
.facd	d0 41		bne $fb10				BNE	CWBXX2
.facf	20 85 f8	jsr $f885				JSR	FINDEND			; Find end of Parameter
.fad2	20 91 fc	jsr $fc91				JSR	RDHEX8
.fad5	87 e2		sta [$e2]				STA	[PTR]			; Attempt to store.  If ROM, output will show failure to write
.fad7	a5 e4		lda $e4					LDA	PTR_B
.fad9	8d 0b 05	sta $050b				STA	HEXIO_B
.fadc	a5 e3		lda $e3					LDA	PTR_H
.fade	8d 0a 05	sta $050a				STA	HEXIO_H
.fae1	a5 e2		lda $e2					LDA	PTR_L
.fae3	8d 09 05	sta $0509				STA	HEXIO_L
.fae6	20 32 fd	jsr $fd32				JSR	PUTHEX24
.fae9	a9 3c		lda #$3c				LDA	#'<'
.faeb	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.faee	a9 2d		lda #$2d				LDA	#'-'
.faf0	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.faf3	a7 e2		lda [$e2]				LDA	[PTR]			; Read the actual byte (if ROM, won't match input)
.faf5	20 4a fd	jsr $fd4a				JSR	PUTHEXA
.faf8	20 5c fb	jsr $fb5c				JSR	CRLF
.fafb	18		clc					CLC
.fafc	a5 e2		lda $e2					LDA	PTR_L
.fafe	69 01		adc #$01				ADC	#1
.fb00	85 e2		sta $e2					STA	PTR_L
.fb02	a5 e3		lda $e3					LDA	PTR_H
.fb04	69 00		adc #$00				ADC	#0
.fb06	85 e3		sta $e3					STA	PTR_H
.fb08	a5 e4		lda $e4					LDA	PTR_B
.fb0a	69 00		adc #$00				ADC	#0
.fb0c	85 e4		sta $e4					STA	PTR_B
.fb0e	80 b7		bra $fac7				BRA	CWLOOP1
.fb10					CWBXX2
.fb10	60		rts					RTS
.fb11					CMD_LOAD
.fb11	a0 49 f2	ldy #$f249				LDY	#MSG_LOAD
.fb14	20 81 fb	jsr $fb81				JSR	PUT_STR
.fb17	20 ab fb	jsr $fbab				JSR	SREC_LOADER
.fb1a	60		rts					RTS
.fb1b					CMD_GO
.fb1b	20 5c fb	jsr $fb5c				JSR	CRLF			; Give some space
.fb1e	20 62 f8	jsr $f862				JSR	FINDSTART		; Skip over whitespace.  On return CB_RDPTR, PRM_SA hold start of first/next parameter
.fb21	ad 07 05	lda $0507				LDA	EOLFLAG			; OR if we hit EOL, then there's no command byte on the line and we have nothing to process
.fb24	d0 24		bne $fb4a				BNE	CGXIT1			; We hit an EOL before an actionable character, so quit
.fb26	20 85 f8	jsr $f885				JSR	FINDEND			; Get the next parameter's start address in PRM_SA and length in PRM_SIZ
.fb29	20 b8 fc	jsr $fcb8				JSR	CONVHEX			; Get starting address in HEXIO
.fb2c	ad 0b 05	lda $050b				LDA	HEXIO_B			; Transfer starting address from HEXIO to PTR
.fb2f	85 e4		sta $e4					STA	PTR_B
.fb31	ad 0a 05	lda $050a				LDA	HEXIO_H
.fb34	85 e3		sta $e3					STA	PTR_H
.fb36	ad 09 05	lda $0509				LDA	HEXIO_L
.fb39	85 e2		sta $e2					STA	PTR_L
.fb3b	a0 6b f2	ldy #$f26b				LDY	#MSG_JUMP
.fb3e	20 81 fb	jsr $fb81				JSR	PUT_STR
.fb41	20 32 fd	jsr $fd32				JSR	PUTHEX24
.fb44	20 5c fb	jsr $fb5c				JSR	CRLF			; get rid of return address since we're not returing!
.fb47	dc e2 00	jmp [$00e2]				JML	[PTR]			; There's really no exit
.fb4a					CGXIT1
.fb4a	60		rts					RTS						; Might return if no valid jump address
.fb4b					LOLWUT
.fb4b	20 5c fb	jsr $fb5c				JSR	CRLF
.fb4e	a0 00 04	ldy #$0400				LDY	#CMDBUF
.fb51	20 8d fb	jsr $fb8d				JSR	PUT_STR_CTRL		; Display buffer contents not understood; show non-printing too!
.fb54	20 5c fb	jsr $fb5c				JSR	CRLF
.fb57	a9 3f		lda #$3f				LDA	#'?'
.fb59	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fb5c					CRLF
.fb5c	a9 0a		lda #$0a				LDA	#LF
.fb5e	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fb61					JUSTCR
.fb61	a9 0d		lda #$0d				LDA	#CR
.fb63	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fb66	60		rts					RTS
.fb67					CMD_A
.fb67					CMD_B
.fb67					CMD_C
.fb67					CMD_D
.fb67					CMD_E
.fb67					CMD_F
.fb67					CMD_H
.fb67					CMD_I
.fb67					CMD_J
.fb67					CMD_K
.fb67					CMD_M
.fb67					CMD_N
.fb67					CMD_O
.fb67					CMD_P
.fb67					CMD_Q
.fb67					CMD_R
.fb67					CMD_S
.fb67					CMD_T
.fb67					CMD_U
.fb67					CMD_V
.fb67					CMD_X
.fb67					CMD_Y
.fb67					CMD_Z
.fb67	a0 00 f0	ldy #$f000				LDY	#MSG_UNIMPLEMENTED
.fb6a	20 81 fb	jsr $fb81				JSR	PUT_STR
.fb6d	60		rts					RTS
.fb6e					PUTCHARTR
.fb6e	c9 20		cmp #$20				CMP	#$20
.fb70	b0 0b		bcs $fb7d				BCS	PUTCHAR
.fb72	48		pha					PHA					; Display as hex value
.fb73	a9 5c		lda #$5c				LDA	#'\'
.fb75	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fb78	68		pla					PLA
.fb79	20 4a fd	jsr $fd4a				JSR	PUTHEXA
.fb7c					PUTCRX1
.fb7c	60		rts					RTS
.fb7d					PUTCHAR
.fb7d	20 13 f9	jsr $f913				JSR	PUT_FIFO
.fb80	60		rts					RTS
.fb81					PUT_STR
.fb81	b9 00 00	lda $0000,y				LDA	0,Y				; Y points directly to string
.fb84	f0 06		beq $fb8c				BEQ	PUTSX
.fb86	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fb89	c8		iny					INY					; point to next character
.fb8a	80 f5		bra $fb81				BRA	PUT_STR
.fb8c					PUTSX
.fb8c	60		rts					RTS
.fb8d					PUT_STR_CTRL
.fb8d	b9 00 00	lda $0000,y				LDA	0,Y				; Y points directly to string
.fb90	f0 06		beq $fb98				BEQ	PUTSRX
.fb92	20 6e fb	jsr $fb6e				JSR	PUTCHARTR			; Show control characters, etc.
.fb95	c8		iny					INY					; point to next character
.fb96	80 f5		bra $fb8d				BRA	PUT_STR_CTRL
.fb98					PUTSRX
.fb98	60		rts					RTS
.fb99					GET_RAW
.fb99	82 7d fd	brl $f919				BRL	GET_FIFO
.fb9c					GETCHAR
.fb9c	a5 43		lda $43					LDA	TERMFLAGS		; relying on W265 SBC char in buffer (temporarily)
.fb9e	29 df		and #$df				AND	#%11011111		; Turn off ECHO
.fba0	09 10		ora #$10				ORA	#%00010000		; Turn off hardware handshaking to 265 (not run)
.fba2	85 43		sta $43					STA 	TERMFLAGS
.fba4	20 99 fb	jsr $fb99				JSR	GET_RAW
.fba7	20 08 f9	jsr $f908				JSR	TOPUPPER		; Make alphabetics Puppercase
.fbaa	60		rts					RTS
.fbab					SREC_LOADER
.fbab					SYNC
.fbab	20 9c fb	jsr $fb9c				JSR	GETCHAR			; Wait for "S" to start a new record
.fbae	c9 53		cmp #$53				CMP	#'S'
.fbb0	d0 f9		bne $fbab				BNE	SYNC
.fbb2	a9 40		lda #$40				LDA	#'@'
.fbb4	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fbb7	20 9c fb	jsr $fb9c				JSR	GETCHAR
.fbba	85 e0		sta $e0					STA	REC_TYPE
.fbbc	20 fd fc	jsr $fcfd				JSR	GETHEX			; Get message length byte
.fbbf	85 ee		sta $ee					STA	DATA_CNT		; Save number of bytes in record
.fbc1	a5 e0		lda $e0					LDA	REC_TYPE		; Decode and dispatch
.fbc3	f0 23		beq $fbe8				BEQ	GETREMS			; read the comment block
.fbc5	c9 31		cmp #$31				CMP	#'1'
.fbc7	f0 3e		beq $fc07				BEQ	GET16ADDR
.fbc9	c9 32		cmp #$32				CMP	#'2'
.fbcb	f0 27		beq $fbf4				BEQ	GET24ADDR
.fbcd	c9 35		cmp #$35				CMP	#'5'
.fbcf	d0 02		bne $fbd3				BNE	SLC4
.fbd1	80 64		bra $fc37				BRA	CNT16
.fbd3					SLC4
.fbd3	c9 36		cmp #$36				CMP	#'6'
.fbd5	d0 02		bne $fbd9				BNE	SLC2
.fbd7	80 67		bra $fc40				BRA	CNT24
.fbd9					SLC2
.fbd9	c9 38		cmp #$38				CMP	#'8'
.fbdb	d0 03		bne $fbe0				BNE	SLC1
.fbdd	82 85 00	brl $fc65				BRL	SA24			; Too far for relative branch
.fbe0					SLC1
.fbe0	c9 39		cmp #$39				CMP	#'9'
.fbe2	d0 02		bne $fbe6				BNE	SLC3
.fbe4	80 76		bra $fc5c				BRA	SA16
.fbe6					SLC3
.fbe6	80 c3		bra $fbab				BRA	SYNC
.fbe8					GETREMS
.fbe8	a9 30		lda #$30				LDA	#'0'
.fbea	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fbed	a9 23		lda #$23				LDA	#'#'
.fbef	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fbf2	80 b7		bra $fbab				BRA	SYNC
.fbf4					GET24ADDR
.fbf4	a9 32		lda #$32				LDA	#'2'
.fbf6	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fbf9	a5 ee		lda $ee					LDA	DATA_CNT
.fbfb	38		sec					SEC
.fbfc	e9 04		sbc #$04				SBC	#4			; Data length -= 3 bytes address + 1 byte checksum
.fbfe	85 ee		sta $ee					STA	DATA_CNT		; Adjust data count to include only payload data bytes
.fc00	20 fd fc	jsr $fcfd				JSR	GETHEX
.fc03	85 e4		sta $e4					STA	PTR_B
.fc05	80 0e		bra $fc15				BRA	GET1624
.fc07					GET16ADDR
.fc07	a9 31		lda #$31				LDA	#'1'
.fc09	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fc0c	a5 ee		lda $ee					LDA	DATA_CNT
.fc0e	38		sec					SEC
.fc0f	e9 03		sbc #$03				SBC	#3			; Data length -= 2 bytes address + 1 byte checksum
.fc11	85 ee		sta $ee					STA	DATA_CNT		; Adjust data count to include only payload data bytes
.fc13	64 e4		stz $e4					STZ	PTR_B			; 16 bit records.  Default Bank to 0!  (0+! NOT 0!=1)
.fc15					GET1624
.fc15	20 fd fc	jsr $fcfd				JSR	GETHEX			; Got bank value (or set to 0). Now get high and low address
.fc18	85 e3		sta $e3					STA	PTR_H
.fc1a	20 fd fc	jsr $fcfd				JSR	GETHEX
.fc1d	85 e2		sta $e2					STA	PTR_L
.fc1f					SAVDAT:
.fc1f	a5 ee		lda $ee					LDA	DATA_CNT		; A record can have 0 data bytes, theoretically. So check at top
.fc21	f0 0c		beq $fc2f				BEQ	SAVDX1			; No more data to PARSELINE
.fc23					SAVDAT2
.fc23	20 fd fc	jsr $fcfd				JSR	GETHEX
.fc26	87 e2		sta [$e2]				STA	[PTR]			; 24 bit indirect save
.fc28	20 86 fc	jsr $fc86				JSR	INC_PTR			; Point to next byte
.fc2b	c6 ee		dec $ee					DEC	DATA_CNT
.fc2d	d0 f4		bne $fc23				BNE	SAVDAT2
.fc2f					SAVDX1
.fc2f	a9 23		lda #$23				LDA	#'#'
.fc31	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fc34	82 74 ff	brl $fbab				BRL	SYNC			; FIXME: parse the checksum and end of line
.fc37					CNT16
.fc37	a9 35		lda #$35				LDA	#'5'
.fc39	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fc3c	64 e7		stz $e7					STZ	CTR_B
.fc3e	80 0a		bra $fc4a				BRA	CN16C1
.fc40					CNT24:
.fc40	a9 36		lda #$36				LDA	#'6'
.fc42	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fc45	20 fd fc	jsr $fcfd				JSR	GETHEX
.fc48	85 e7		sta $e7					STA	CTR_B
.fc4a					CN16C1
.fc4a	20 fd fc	jsr $fcfd				JSR	GETHEX			; bits 15-8
.fc4d	85 e6		sta $e6					STA	CTR_H
.fc4f	20 fd fc	jsr $fcfd				JSR	GETHEX			; bits 7-0
.fc52	85 e5		sta $e5					STA	CTR_L
.fc54	a9 23		lda #$23				LDA	#'#'
.fc56	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fc59	82 4f ff	brl $fbab				BRL	SYNC			; FIXME: parse the rest of the record & end of line
.fc5c					SA16
.fc5c	a9 39		lda #$39				LDA	#'9'
.fc5e	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fc61	64 ea		stz $ea					STZ	SA_B
.fc63	80 0a		bra $fc6f				BRA	SA16C1
.fc65					SA24
.fc65	a9 38		lda #$38				LDA	#'8'
.fc67	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fc6a	20 fd fc	jsr $fcfd				JSR	GETHEX			; length byte
.fc6d	64 ea		stz $ea					STZ	SA_B
.fc6f					SA16C1
.fc6f	20 fd fc	jsr $fcfd				JSR	GETHEX			; bits 15-8
.fc72	85 e9		sta $e9					STA	SA_H
.fc74	20 fd fc	jsr $fcfd				JSR	GETHEX			; bits 7-0
.fc77	85 e8		sta $e8					STA	SA_L
.fc79	a9 26		lda #$26				LDA	#'&'
.fc7b	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fc7e					GOEOL
.fc7e	20 9c fb	jsr $fb9c				JSR	GETCHAR
.fc81	c9 0d		cmp #$0d				CMP	#CR
.fc83	d0 f9		bne $fc7e				BNE	GOEOL
.fc85	60		rts					RTS
.fc86					INC_PTR
.fc86	e6 e2		inc $e2					INC	PTR_L			; point to the next byte to save to
.fc88	d0 06		bne $fc90				BNE	INCPX1
.fc8a	e6 e3		inc $e3					INC	PTR_H
.fc8c	d0 02		bne $fc90				BNE	INCPX1
.fc8e	e6 e4		inc $e4					INC	PTR_B
.fc90					INCPX1
.fc90	60		rts					RTS
.fc91					RDHEX8
.fc91	5a		phy					PHY
.fc92	ac 04 05	ldy $0504				LDY	PRM_SA			; Start at beginning of current parameter
.fc95					RDHX8L1
.fc95	b9 00 00	lda $0000,y				LDA	0,Y			; Get MSB from *(parameter)
.fc98	c8		iny					INY				; advance to (hopefully) ASCII LSB
.fc99	c9 3a		cmp #$3a				CMP	#':'			; Kludgey special handling for ':'
.fc9b	f0 f8		beq $fc95				BEQ	RDHX8L1
.fc9d					RDHX8C1
.fc9d	20 61 fd	jsr $fd61				JSR	MKNIBL
.fca0	0a		asl a					ASL	A			; Note: MKNIBL ANDs off higher 4 bits, so no '1' sign extension can occur
.fca1	0a		asl a					ASL	A
.fca2	0a		asl a					ASL	A
.fca3	0a		asl a					ASL	A			; shift left 4 because upper nibble
.fca4	85 f1		sta $f1					STA	HEXASSY			; temporary storage.  Only used within this function. Can re-use in any foreground context.
.fca6					RDHX8L2
.fca6	b9 00 00	lda $0000,y				LDA	0,Y			; Get LSB *(parameter+1)
.fca9	c8		iny					INY				; point to next ASCII hex byte (if any)
.fcaa	c9 3a		cmp #$3a				CMP	#':'
.fcac	f0 f8		beq $fca6				BEQ	RDHX8L2			; Anti-metamucel (ignore colons) Note pathological buffer with all ':' is possible.  We will tolerate.
.fcae	8c 04 05	sty $0504				STY	PRM_SA			;	"
.fcb1	20 61 fd	jsr $fd61				JSR	MKNIBL
.fcb4	05 f1		ora $f1					ORA	HEXASSY			; Assemble the parts
.fcb6	7a		ply					PLY
.fcb7	60		rts					RTS				; return the byte in A
.fcb8					CONVHEX
.fcb8	9c 0b 05	stz $050b				STZ	HEXIO_B			; Only write bytes explicitly set in buffer parameter string, else 0
.fcbb	9c 0a 05	stz $050a				STZ	HEXIO_H
.fcbe	9c 09 05	stz $0509				STZ	HEXIO_L
.fcc1	ad 06 05	lda $0506				LDA	PRM_SIZ			; 24 bit cases are "00:1234" or "001234", 16 bit is "1234", 8 bit is "2A"
.fcc4	c9 02		cmp #$02				CMP	#2			; See if not even 8 bits (must be two digits to qualify as a hex value by fiat)
.fcc6	90 34		bcc $fcfc				BCC	CVHKWIT			; Too short to be a valid hex parameter.  Must be 2 or more characters
.fcc8	c9 03		cmp #$03				CMP	#3
.fcca	b0 08		bcs $fcd4				BCS	CHXCHK16
.fccc	20 91 fc	jsr $fc91				JSR	RDHEX8
.fccf	8d 09 05	sta $0509				STA	HEXIO_L
.fcd2	80 28		bra $fcfc				BRA	CVHKWIT
.fcd4					CHXCHK16
.fcd4	c9 05		cmp #$05				CMP	#5
.fcd6	b0 0e		bcs $fce6				BCS	CHXCHK24
.fcd8	20 91 fc	jsr $fc91				JSR	RDHEX8
.fcdb	8d 0a 05	sta $050a				STA	HEXIO_H
.fcde	20 91 fc	jsr $fc91				JSR	RDHEX8
.fce1	8d 09 05	sta $0509				STA	HEXIO_L
.fce4	80 16		bra $fcfc				BRA	CVHKWIT
.fce6					CHXCHK24
.fce6	c9 08		cmp #$08				CMP	#8
.fce8	b0 12		bcs $fcfc				BCS	CVHKWIT			; Give up if >= 8 characters!
.fcea	20 91 fc	jsr $fc91				JSR	RDHEX8
.fced	8d 0b 05	sta $050b				STA	HEXIO_B
.fcf0	20 91 fc	jsr $fc91				JSR	RDHEX8
.fcf3	8d 0a 05	sta $050a				STA	HEXIO_H
.fcf6	20 91 fc	jsr $fc91				JSR	RDHEX8
.fcf9	8d 09 05	sta $0509				STA	HEXIO_L
.fcfc					CVHKWIT
.fcfc	60		rts					RTS
.fcfd					GETHEX
.fcfd	20 9c fb	jsr $fb9c				JSR 	GETCHAR
.fd00	c9 03		cmp #$03				CMP	#CTRL_C
.fd02	d0 0b		bne $fd0f				BNE	GHECC1
.fd04	a9 5e		lda #$5e				LDA	#'^'
.fd06	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fd09	a9 43		lda #$43				LDA	#'C'
.fd0b	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fd0e	60		rts		       		RTS				; bail
.fd0f					GHECC1
.fd0f	20 61 fd	jsr $fd61				JSR     MKNIBL  		; Convert to 0..F numeric
.fd12	0a		asl a					ASL     A
.fd13	0a		asl a					ASL     A
.fd14	0a		asl a					ASL     A
.fd15	0a		asl a					ASL     A       		; This is the upper nibble
.fd16	29 f0		and #$f0				AND     #$F0
.fd18	85 f0		sta $f0					STA     SUBTEMP
.fd1a	20 9c fb	jsr $fb9c				JSR     GETCHAR
.fd1d	c9 03		cmp #$03				CMP	#CTRL_C
.fd1f	d0 0b		bne $fd2c				BNE	GHECC2
.fd21	a9 5e		lda #$5e				LDA	#'^'
.fd23	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fd26	a9 43		lda #$43				LDA	#'C'
.fd28	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fd2b	60		rts					RTS				; bail
.fd2c					GHECC2
.fd2c	20 61 fd	jsr $fd61				JSR     MKNIBL
.fd2f	05 f0		ora $f0		        		ORA    	SUBTEMP
.fd31	60		rts		        		RTS
.fd32					PUTHEX24:
.fd32	ad 0b 05	lda $050b				LDA	HEXIO_B
.fd35	20 4a fd	jsr $fd4a				JSR	PUTHEXA
.fd38	a9 3a		lda #$3a				LDA	#':'
.fd3a	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fd3d					PUTHEX16:
.fd3d	ad 0a 05	lda $050a				LDA	HEXIO_H
.fd40	20 4a fd	jsr $fd4a				JSR	PUTHEXA
.fd43					PUTHEX8:
.fd43	ad 09 05	lda $0509				LDA	HEXIO_L
.fd46	20 4a fd	jsr $fd4a				JSR	PUTHEXA
.fd49	60		rts					RTS
.fd4a					PUTHEXA
.fd4a	48		pha					PHA             	;
.fd4b	4a		lsr a		        		LSR 	A
.fd4c	4a		lsr a		        		LSR 	A
.fd4d	4a		lsr a					LSR 	A
.fd4e	4a		lsr a					LSR 	A
.fd4f	20 53 fd	jsr $fd53	        		JSR     PRNIBL
.fd52	68		pla		        		PLA
.fd53					PRNIBL
.fd53	29 0f		and #$0f				AND     #$0F    	; strip off the low nibble
.fd55	c9 0a		cmp #$0a	       		 	CMP     #$0A
.fd57	90 02		bcc $fd5b	       		 	BCC  	NOTHEX  	; if it's 0-9, add '0' else also add 7
.fd59	69 06		adc #$06	       		 	ADC     #6      	; Add 7 (6+carry=1), result will be carry clear
.fd5b					NOTHEX
.fd5b	69 30		adc #$30				ADC     #'0'    	; If carry clear, we're 0-9
.fd5d					PUTCH
.fd5d	20 7d fb	jsr $fb7d				JSR	PUTCHAR
.fd60	60		rts					RTS
.fd61					MKNIBL
.fd61	c9 3a		cmp #$3a				CMP     #'9'+1  	; See if it's 0-9 or 'A'..'F' (no lowercase yet)
.fd63	90 02		bcc $fd67	 		    BCC     MKNNH   	; If we borrowed, we lost the carry so 0..9
.fd65	e9 08		sbc #$08	        		SBC     #7+1    	; Subtract off extra 7 (sbc subtracts off one less)
.fd67					MKNNH
.fd67	e9 2f		sbc #$2f				SBC     #'0'-1  	; subtract off '0' (if carry clear coming in)
.fd69	29 0f		and #$0f	        		AND     #$0F    	; no upper nibble no matter what
.fd6b	60		rts		        		RTS             	; and return the nibble
=$1e					SCTL_V  = %00011110       ; 9600 baud, 8 bits, 1 stop bit, rxclock = txclock
=$0b					SCMD_V  = %00001011       ; No parity, no echo, no tx or rx IRQ (for now), DTR*
.fd6c					INIT_SER
.fd6c	a9 1e		lda #$1e				LDA     #SCTL_V 	; 9600,n,8,1.  rxclock = txclock
.fd6e	8d 83 7f	sta $7f83				STA 	SCTL
.fd71	a9 0b		lda #$0b				LDA     #SCMD_V 	; No parity, no echo, no tx or rx IRQ (for now), DTR*
.fd73	8d 82 7f	sta $7f82				STA     SCMD
.fd76	60		rts					RTS
.fd77					GETSER
.fd77	ad 81 7f	lda $7f81				LDA	SSR
.fd7a	29 08		and #$08				AND	#RX_RDY
.fd7c	f0 f9		beq $fd77				BEQ	GETSER
.fd7e	ad 80 7f	lda $7f80				LDA	SDR
.fd81	18		clc					CLC			; Temporary compatibility return value for blocking/non-blocking
.fd82	60		rts					RTS
.fd83					PUTSER
.fd83	48		pha					PHA
.fd84	8d 80 7f	sta $7f80				STA	SDR
.fd87	20 b6 f9	jsr $f9b6				JSR	TXCHDLY		; Awful kludge
.fd8a	68		pla					PLA
.fd8b	18		clc					CLC			; Temporary compatibility return value for integration for blocking/non-blocking
.fd8c	60		rts					RTS
.fd8d					MONTBL
>fd8d	67 fb							.word 	CMD_A		; Index 0 = "A"
>fd8f	67 fb							.word	CMD_B
>fd91	67 fb							.word	CMD_C
>fd93	67 fb							.word	CMD_D
>fd95	67 fb							.word	CMD_E
>fd97	67 fb							.word	CMD_F
>fd99	1b fb							.word	CMD_GO
>fd9b	67 fb							.word	CMD_H
>fd9d	67 fb							.word	CMD_I
>fd9f	1b fb							.word	CMD_GO
>fda1	67 fb							.word	CMD_K
>fda3	11 fb							.word	CMD_LOAD
>fda5	67 fb							.word	CMD_M
>fda7	67 fb							.word	CMD_N
>fda9	67 fb							.word	CMD_O
>fdab	67 fb							.word	CMD_P
>fdad	67 fb							.word	CMD_Q
>fdaf	c2 f9							.word	CMD_DUMPHEX
>fdb1	67 fb							.word	CMD_S
>fdb3	67 fb							.word	CMD_T
>fdb5	67 fb							.word	CMD_U
>fdb7	67 fb							.word	CMD_V
>fdb9	a7 fa							.word	CMD_WRITEBYTES
>fdbb	67 fb							.word	CMD_X
>fdbd	67 fb							.word	CMD_Y
>fdbf	67 fb							.word	CMD_Z
.f000					MSG_UNIMPLEMENTED
>f000	0d 55 6e 69 6d 70 6c 65				.text	CR,"Unimplemented instruction",CR
>f008	6d 65 6e 74 65 64 20 69 6e 73 74 72 75 63 74 69
>f018	6f 6e 0d
>f01b	00						.text	0
.f01c					MSG_6HEX
>f01c	0d 45 6e 74 65 72 20 36				.text	CR,"Enter 6 digit hex address:",0
>f024	20 64 69 67 69 74 20 68 65 78 20 61 64 64 72 65
>f034	73 73 3a 00
.f038					MSG_CONFIRM
>f038	0d 49 73 20 74 68 69 73				.text	CR,"Is this correct (Y/x)?:",0
>f040	20 63 6f 72 72 65 63 74 20 28 59 2f 78 29 3f 3a
>f050	00
.f051					QBFMSG
>f051	0d 0a 0d 0a					.text 		CR,LF,CR,LF
>f055	20 20 20 20 20 20 20 20				.text	"                  VCBmon v 1.00",CR,LF
>f05d	20 20 20 20 20 20 20 20 20 20 56 43 42 6d 6f 6e
>f06d	20 76 20 31 2e 30 30 0d 0a
>f076	20 20 20 20 20 20 20 20				.text 	"          ******************************",CR,LF
>f07e	20 20 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f08e	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f09e	0d 0a
>f0a0	20 20 20 20 20 20 20 20				.text 	"          *                            *",CR,LF
>f0a8	20 20 2a 20 20 20 20 20 20 20 20 20 20 20 20 20
>f0b8	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 2a
>f0c8	0d 0a
>f0ca	20 20 20 20 20 20 20 20				.text 	"          *    The Quick brown Dog     *",CR,LF
>f0d2	20 20 2a 20 20 20 20 54 68 65 20 51 75 69 63 6b
>f0e2	20 62 72 6f 77 6e 20 44 6f 67 20 20 20 20 20 2a
>f0f2	0d 0a
>f0f4	20 20 20 20 20 20 20 20				.text 	"          *  Jumps over the Lazy Fox!  *",CR,LF
>f0fc	20 20 2a 20 20 4a 75 6d 70 73 20 6f 76 65 72 20
>f10c	74 68 65 20 4c 61 7a 79 20 46 6f 78 21 20 20 2a
>f11c	0d 0a
>f11e	20 20 20 20 20 20 20 20				.text 	"          *                            *",CR,LF
>f126	20 20 2a 20 20 20 20 20 20 20 20 20 20 20 20 20
>f136	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 2a
>f146	0d 0a
>f148	20 20 20 20 20 20 20 20				.text 	"          ******************************",CR,LF
>f150	20 20 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f160	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
>f170	0d 0a
.f172					PROMPT
>f172	0d 0a						.text	CR,LF
>f174	20 20 20 20 20 20 20 20				.text	"        _,-=._              /|_/|",CR,LF
>f17c	5f 2c 2d 3d 2e 5f 20 20 20 20 20 20 20 20 20 20
>f18c	20 20 20 20 2f 7c 5f 2f 7c 0d 0a
>f197	20 20 20 20 20 20 20 2a		 		.text	"       *-.}   `=._,.-=-._.,  @ @._,",CR,LF
>f19f	2d 2e 7d 20 20 20 60 3d 2e 5f 2c 2e 2d 3d 2d 2e
>f1af	5f 2e 2c 20 20 40 20 40 2e 5f 2c 0d 0a
>f1bc	20 20 20 20 20 20 20 20		 		.text   "          `._ _,-.   )      _,.-'",CR,LF
>f1c4	20 20 60 2e 5f 20 5f 2c 2d 2e 20 20 20 29 20 20
>f1d4	20 20 20 20 5f 2c 2e 2d 27 0d 0a
>f1df	20 20 20 20 20 20 20 20				 .text   "             `    G.m-'^m'm'",CR,CR,LF
>f1e7	20 20 20 20 20 60 20 20 20 20 47 2e 6d 2d 27 5e
>f1f7	6d 27 6d 27 0d 0d 0a
>f1fe	00				   		 .text	0
.f1ff					ANYKEY
>f1ff	0d 0a 0d 0a					.text	CR,LF,CR,LF
>f203	50 72 65 73 73 20 74 68				.text 	"Press the ANY key (CTRL-C) to return to monitor",CR
>f20b	65 20 41 4e 59 20 6b 65 79 20 28 43 54 52 4c 2d
>f21b	43 29 20 74 6f 20 72 65 74 75 72 6e 20 74 6f 20
>f22b	6d 6f 6e 69 74 6f 72 0d
>f233	65 6c 73 65 20 63 6f 6e				.text   "else continue foxing:"
>f23b	74 69 6e 75 65 20 66 6f 78 69 6e 67 3a
>f248	00						.text	0
.f249					MSG_LOAD
>f249	0d 53 45 4e 44 20 53 31				.text 	CR,"SEND S19 or S28 S-RECORD file:",CR,LF
>f251	39 20 6f 72 20 53 32 38 20 53 2d 52 45 43 4f 52
>f261	44 20 66 69 6c 65 3a 0d 0a
>f26a	00						.text 	0
.f26b					MSG_JUMP
>f26b	0d 4a 75 6d 70 69 6e 67				.text 	CR,"Jumping to address: $"
>f273	20 74 6f 20 61 64 64 72 65 73 73 3a 20 24
>f281	00						.text 	0
.ffe4					NCOP
>ffe4	00 f8						.word	START		; COP exception in native mode
.ffe6					NBRK
>ffe6	00 f8						.word	START		; BRK in native mode
.ffe8					NABORT
>ffe8	00 f8						.word	START
.ffea					NNMI
>ffea	00 f8						.word	START		; NMI interrupt in native mode
.ffee					NIRQ
>ffee	00 f8						.word	START
.fff4					ECOP
>fff4	00 f8						.word	START		; COP exception in 65c02 emulation mode
.fff8					EABORT
>fff8	00 f8						.word	START
.fffa					ENMI
>fffa	00 f8						.word	START		; NMI interrupt in 65c02 emulation mode
.fffc					ERESET
>fffc	00 f8						.word	START		; RESET exception in all modes
.fffe					EIRQ
>fffe	00 f8						.word	START

;******  End of listing
